/* XplannerSOAPC.cpp
   Generated by gSOAP 2.7.10 from Xplanner.h
   Copyright(C) 2000-2008, Robert van Engelen, Genivia Inc. All Rights Reserved.
   This part of the software is released under one of the following licenses:
   GPL, the gSOAP public license, or Genivia's license for commercial use.
*/

#include "XplannerSOAPH.h"

SOAP_SOURCE_STAMP("@(#) XplannerSOAPC.cpp ver 2.7.10 2015-02-02 06:05:40 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, NULL))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", NULL, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (!soap->header)
	{	soap->header = soap_new_SOAP_ENV__Header(soap, -1);
		soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (!soap->fault)
	{	soap->fault = soap_new_SOAP_ENV__Fault(soap, -1);
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = soap_new_SOAP_ENV__Code(soap, -1);
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
	{	soap->fault->SOAP_ENV__Reason = soap_new_SOAP_ENV__Reason(soap, -1);
		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", NULL);
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (!soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = soap_new_SOAP_ENV__Code(soap, -1);
			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 1)
	{	if (!soap->fault->detail)
		{	soap->fault->detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
			soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
		}
		return (const char**)&soap->fault->detail->__any;
	}
	if (!soap->fault->SOAP_ENV__Detail)
	{	soap->fault->SOAP_ENV__Detail = soap_new_SOAP_ENV__Detail(soap, -1);
		soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
	}
	return (const char**)&soap->fault->SOAP_ENV__Detail->__any;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	for (;;)
		if (!soap_getelement(soap, &t))
			if (soap->error || soap_ignore_element(soap))
				break;
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{
	if (soap_peek_element(soap))
		return NULL;
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_double:
		return soap_in_double(soap, NULL, NULL, "xsd:double");
	case SOAP_TYPE_time:
		return soap_in_time(soap, NULL, NULL, "xsd:dateTime");
	case SOAP_TYPE_bool:
		return soap_in_bool(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE_ns5__QueryException:
		return soap_in_ns5__QueryException(soap, NULL, NULL, "ns5:QueryException");
	case SOAP_TYPE_ArrayOf_USCOREtns1_USCORENoteData:
		return soap_in_ArrayOf_USCOREtns1_USCORENoteData(soap, NULL, NULL, "ns4:NoteData");
	case SOAP_TYPE_ArrayOf_USCOREtns1_USCOREProjectData:
		return soap_in_ArrayOf_USCOREtns1_USCOREProjectData(soap, NULL, NULL, "ns4:ProjectData");
	case SOAP_TYPE_ArrayOf_USCOREtns1_USCOREPersonData:
		return soap_in_ArrayOf_USCOREtns1_USCOREPersonData(soap, NULL, NULL, "ns4:PersonData");
	case SOAP_TYPE_ArrayOf_USCOREtns1_USCORETimeEntryData:
		return soap_in_ArrayOf_USCOREtns1_USCORETimeEntryData(soap, NULL, NULL, "ns4:TimeEntryData");
	case SOAP_TYPE_ArrayOf_USCOREtns1_USCORETaskData:
		return soap_in_ArrayOf_USCOREtns1_USCORETaskData(soap, NULL, NULL, "ns4:TaskData");
	case SOAP_TYPE_ArrayOf_USCOREtns1_USCOREUserStoryData:
		return soap_in_ArrayOf_USCOREtns1_USCOREUserStoryData(soap, NULL, NULL, "ns4:UserStoryData");
	case SOAP_TYPE_ArrayOf_USCOREtns1_USCOREIterationData:
		return soap_in_ArrayOf_USCOREtns1_USCOREIterationData(soap, NULL, NULL, "ns4:IterationData");
	case SOAP_TYPE_ns4__IterationData:
		return soap_in_ns4__IterationData(soap, NULL, NULL, "ns4:IterationData");
	case SOAP_TYPE_ns4__TaskData:
		return soap_in_ns4__TaskData(soap, NULL, NULL, "ns4:TaskData");
	case SOAP_TYPE_ns4__TimeEntryData:
		return soap_in_ns4__TimeEntryData(soap, NULL, NULL, "ns4:TimeEntryData");
	case SOAP_TYPE_ns4__PersonData:
		return soap_in_ns4__PersonData(soap, NULL, NULL, "ns4:PersonData");
	case SOAP_TYPE_ns4__UserStoryData:
		return soap_in_ns4__UserStoryData(soap, NULL, NULL, "ns4:UserStoryData");
	case SOAP_TYPE_ns4__ProjectData:
		return soap_in_ns4__ProjectData(soap, NULL, NULL, "ns4:ProjectData");
	case SOAP_TYPE_ns4__NoteData:
		return soap_in_ns4__NoteData(soap, NULL, NULL, "ns4:NoteData");
	case SOAP_TYPE_ns3__DomainData:
		return soap_in_ns3__DomainData(soap, NULL, NULL, "ns3:DomainData");
	case SOAP_TYPE_ns2__Map:
		return soap_in_ns2__Map(soap, NULL, NULL, "ns2:Map");
	case SOAP_TYPE_ns2__mapItem:
		return soap_in_ns2__mapItem(soap, NULL, NULL, "ns2:mapItem");
	case SOAP_TYPE_xsd__int:
		return soap_in_xsd__int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_xsd__double:
		return soap_in_xsd__double(soap, NULL, NULL, "xsd:double");
	case SOAP_TYPE_xsd__dateTime:
		return soap_in_xsd__dateTime(soap, NULL, NULL, "xsd:dateTime");
	case SOAP_TYPE_xsd__boolean:
		return soap_in_xsd__boolean(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE_xsd__anyType:
		return soap_in_xsd__anyType(soap, NULL, NULL, "xsd:anyType");
	case SOAP_TYPE_ns6__getAttributesWithPrefix:
		return soap_in_ns6__getAttributesWithPrefix(soap, NULL, NULL, "ns6:getAttributesWithPrefix");
	case SOAP_TYPE_ns6__getAttributesWithPrefixResponse:
		return soap_in_ns6__getAttributesWithPrefixResponse(soap, NULL, NULL, "ns6:getAttributesWithPrefixResponse");
	case SOAP_TYPE_ns6__deleteAttribute:
		return soap_in_ns6__deleteAttribute(soap, NULL, NULL, "ns6:deleteAttribute");
	case SOAP_TYPE_ns6__deleteAttributeResponse:
		return soap_in_ns6__deleteAttributeResponse(soap, NULL, NULL, "ns6:deleteAttributeResponse");
	case SOAP_TYPE_ns6__removePerson:
		return soap_in_ns6__removePerson(soap, NULL, NULL, "ns6:removePerson");
	case SOAP_TYPE_ns6__removePersonResponse:
		return soap_in_ns6__removePersonResponse(soap, NULL, NULL, "ns6:removePersonResponse");
	case SOAP_TYPE_ns6__addPerson:
		return soap_in_ns6__addPerson(soap, NULL, NULL, "ns6:addPerson");
	case SOAP_TYPE_ns6__addPersonResponse:
		return soap_in_ns6__addPersonResponse(soap, NULL, NULL, "ns6:addPersonResponse");
	case SOAP_TYPE_ns6__getNotesForObject:
		return soap_in_ns6__getNotesForObject(soap, NULL, NULL, "ns6:getNotesForObject");
	case SOAP_TYPE_ns6__getNotesForObjectResponse:
		return soap_in_ns6__getNotesForObjectResponse(soap, NULL, NULL, "ns6:getNotesForObjectResponse");
	case SOAP_TYPE_ns6__addNote:
		return soap_in_ns6__addNote(soap, NULL, NULL, "ns6:addNote");
	case SOAP_TYPE_ns6__addNoteResponse:
		return soap_in_ns6__addNoteResponse(soap, NULL, NULL, "ns6:addNoteResponse");
	case SOAP_TYPE_ns6__removeTimeEntry:
		return soap_in_ns6__removeTimeEntry(soap, NULL, NULL, "ns6:removeTimeEntry");
	case SOAP_TYPE_ns6__removeTimeEntryResponse:
		return soap_in_ns6__removeTimeEntryResponse(soap, NULL, NULL, "ns6:removeTimeEntryResponse");
	case SOAP_TYPE_ns6__addTimeEntry:
		return soap_in_ns6__addTimeEntry(soap, NULL, NULL, "ns6:addTimeEntry");
	case SOAP_TYPE_ns6__addTimeEntryResponse:
		return soap_in_ns6__addTimeEntryResponse(soap, NULL, NULL, "ns6:addTimeEntryResponse");
	case SOAP_TYPE_ns6__getTimeEntry:
		return soap_in_ns6__getTimeEntry(soap, NULL, NULL, "ns6:getTimeEntry");
	case SOAP_TYPE_ns6__getTimeEntryResponse:
		return soap_in_ns6__getTimeEntryResponse(soap, NULL, NULL, "ns6:getTimeEntryResponse");
	case SOAP_TYPE_ns6__removeTask:
		return soap_in_ns6__removeTask(soap, NULL, NULL, "ns6:removeTask");
	case SOAP_TYPE_ns6__removeTaskResponse:
		return soap_in_ns6__removeTaskResponse(soap, NULL, NULL, "ns6:removeTaskResponse");
	case SOAP_TYPE_ns6__getPlannedTasksForPerson:
		return soap_in_ns6__getPlannedTasksForPerson(soap, NULL, NULL, "ns6:getPlannedTasksForPerson");
	case SOAP_TYPE_ns6__getPlannedTasksForPersonResponse:
		return soap_in_ns6__getPlannedTasksForPersonResponse(soap, NULL, NULL, "ns6:getPlannedTasksForPersonResponse");
	case SOAP_TYPE_ns6__removeUserStory:
		return soap_in_ns6__removeUserStory(soap, NULL, NULL, "ns6:removeUserStory");
	case SOAP_TYPE_ns6__removeUserStoryResponse:
		return soap_in_ns6__removeUserStoryResponse(soap, NULL, NULL, "ns6:removeUserStoryResponse");
	case SOAP_TYPE_ns6__addUserStory:
		return soap_in_ns6__addUserStory(soap, NULL, NULL, "ns6:addUserStory");
	case SOAP_TYPE_ns6__addUserStoryResponse:
		return soap_in_ns6__addUserStoryResponse(soap, NULL, NULL, "ns6:addUserStoryResponse");
	case SOAP_TYPE_ns6__removeIteration:
		return soap_in_ns6__removeIteration(soap, NULL, NULL, "ns6:removeIteration");
	case SOAP_TYPE_ns6__removeIterationResponse:
		return soap_in_ns6__removeIterationResponse(soap, NULL, NULL, "ns6:removeIterationResponse");
	case SOAP_TYPE_ns6__addIteration:
		return soap_in_ns6__addIteration(soap, NULL, NULL, "ns6:addIteration");
	case SOAP_TYPE_ns6__addIterationResponse:
		return soap_in_ns6__addIterationResponse(soap, NULL, NULL, "ns6:addIterationResponse");
	case SOAP_TYPE_ns6__removeProject:
		return soap_in_ns6__removeProject(soap, NULL, NULL, "ns6:removeProject");
	case SOAP_TYPE_ns6__removeProjectResponse:
		return soap_in_ns6__removeProjectResponse(soap, NULL, NULL, "ns6:removeProjectResponse");
	case SOAP_TYPE_ns6__addProject:
		return soap_in_ns6__addProject(soap, NULL, NULL, "ns6:addProject");
	case SOAP_TYPE_ns6__addProjectResponse:
		return soap_in_ns6__addProjectResponse(soap, NULL, NULL, "ns6:addProjectResponse");
	case SOAP_TYPE_ns6__getProjects:
		return soap_in_ns6__getProjects(soap, NULL, NULL, "ns6:getProjects");
	case SOAP_TYPE_ns6__getProjectsResponse:
		return soap_in_ns6__getProjectsResponse(soap, NULL, NULL, "ns6:getProjectsResponse");
	case SOAP_TYPE_ns6__getUserStory:
		return soap_in_ns6__getUserStory(soap, NULL, NULL, "ns6:getUserStory");
	case SOAP_TYPE_ns6__getUserStoryResponse:
		return soap_in_ns6__getUserStoryResponse(soap, NULL, NULL, "ns6:getUserStoryResponse");
	case SOAP_TYPE_ns6__getTask:
		return soap_in_ns6__getTask(soap, NULL, NULL, "ns6:getTask");
	case SOAP_TYPE_ns6__getTaskResponse:
		return soap_in_ns6__getTaskResponse(soap, NULL, NULL, "ns6:getTaskResponse");
	case SOAP_TYPE_ns6__getIteration:
		return soap_in_ns6__getIteration(soap, NULL, NULL, "ns6:getIteration");
	case SOAP_TYPE_ns6__getIterationResponse:
		return soap_in_ns6__getIterationResponse(soap, NULL, NULL, "ns6:getIterationResponse");
	case SOAP_TYPE_ns6__getProject:
		return soap_in_ns6__getProject(soap, NULL, NULL, "ns6:getProject");
	case SOAP_TYPE_ns6__getProjectResponse:
		return soap_in_ns6__getProjectResponse(soap, NULL, NULL, "ns6:getProjectResponse");
	case SOAP_TYPE_ns6__getPeople:
		return soap_in_ns6__getPeople(soap, NULL, NULL, "ns6:getPeople");
	case SOAP_TYPE_ns6__getPeopleResponse:
		return soap_in_ns6__getPeopleResponse(soap, NULL, NULL, "ns6:getPeopleResponse");
	case SOAP_TYPE_ns6__addTask:
		return soap_in_ns6__addTask(soap, NULL, NULL, "ns6:addTask");
	case SOAP_TYPE_ns6__addTaskResponse:
		return soap_in_ns6__addTaskResponse(soap, NULL, NULL, "ns6:addTaskResponse");
	case SOAP_TYPE_ns6__getCurrentTasksForPerson:
		return soap_in_ns6__getCurrentTasksForPerson(soap, NULL, NULL, "ns6:getCurrentTasksForPerson");
	case SOAP_TYPE_ns6__getCurrentTasksForPersonResponse:
		return soap_in_ns6__getCurrentTasksForPersonResponse(soap, NULL, NULL, "ns6:getCurrentTasksForPersonResponse");
	case SOAP_TYPE_ns6__getTimeEntries:
		return soap_in_ns6__getTimeEntries(soap, NULL, NULL, "ns6:getTimeEntries");
	case SOAP_TYPE_ns6__getTimeEntriesResponse:
		return soap_in_ns6__getTimeEntriesResponse(soap, NULL, NULL, "ns6:getTimeEntriesResponse");
	case SOAP_TYPE_ns6__getTasks:
		return soap_in_ns6__getTasks(soap, NULL, NULL, "ns6:getTasks");
	case SOAP_TYPE_ns6__getTasksResponse:
		return soap_in_ns6__getTasksResponse(soap, NULL, NULL, "ns6:getTasksResponse");
	case SOAP_TYPE_ns6__getUserStories:
		return soap_in_ns6__getUserStories(soap, NULL, NULL, "ns6:getUserStories");
	case SOAP_TYPE_ns6__getUserStoriesResponse:
		return soap_in_ns6__getUserStoriesResponse(soap, NULL, NULL, "ns6:getUserStoriesResponse");
	case SOAP_TYPE_ns6__getCurrentIteration:
		return soap_in_ns6__getCurrentIteration(soap, NULL, NULL, "ns6:getCurrentIteration");
	case SOAP_TYPE_ns6__getCurrentIterationResponse:
		return soap_in_ns6__getCurrentIterationResponse(soap, NULL, NULL, "ns6:getCurrentIterationResponse");
	case SOAP_TYPE_ns6__getIterations:
		return soap_in_ns6__getIterations(soap, NULL, NULL, "ns6:getIterations");
	case SOAP_TYPE_ns6__getIterationsResponse:
		return soap_in_ns6__getIterationsResponse(soap, NULL, NULL, "ns6:getIterationsResponse");
	case SOAP_TYPE_ns6__getPerson:
		return soap_in_ns6__getPerson(soap, NULL, NULL, "ns6:getPerson");
	case SOAP_TYPE_ns6__getPersonResponse:
		return soap_in_ns6__getPersonResponse(soap, NULL, NULL, "ns6:getPersonResponse");
	case SOAP_TYPE_ns6__removeNote:
		return soap_in_ns6__removeNote(soap, NULL, NULL, "ns6:removeNote");
	case SOAP_TYPE_ns6__removeNoteResponse:
		return soap_in_ns6__removeNoteResponse(soap, NULL, NULL, "ns6:removeNoteResponse");
	case SOAP_TYPE_ns6__getNote:
		return soap_in_ns6__getNote(soap, NULL, NULL, "ns6:getNote");
	case SOAP_TYPE_ns6__getNoteResponse:
		return soap_in_ns6__getNoteResponse(soap, NULL, NULL, "ns6:getNoteResponse");
	case SOAP_TYPE_ns6__setAttribute:
		return soap_in_ns6__setAttribute(soap, NULL, NULL, "ns6:setAttribute");
	case SOAP_TYPE_ns6__setAttributeResponse:
		return soap_in_ns6__setAttributeResponse(soap, NULL, NULL, "ns6:setAttributeResponse");
	case SOAP_TYPE_ns6__getAttribute:
		return soap_in_ns6__getAttribute(soap, NULL, NULL, "ns6:getAttribute");
	case SOAP_TYPE_ns6__getAttributeResponse:
		return soap_in_ns6__getAttributeResponse(soap, NULL, NULL, "ns6:getAttributeResponse");
	case SOAP_TYPE_ns6__update______:
		return soap_in_ns6__update______(soap, NULL, NULL, "ns6:update");
	case SOAP_TYPE_ns6__updateResponse______:
		return soap_in_ns6__updateResponse______(soap, NULL, NULL, "ns6:updateResponse");
	case SOAP_TYPE_ns6__update_____:
		return soap_in_ns6__update_____(soap, NULL, NULL, "ns6:update");
	case SOAP_TYPE_ns6__updateResponse_____:
		return soap_in_ns6__updateResponse_____(soap, NULL, NULL, "ns6:updateResponse");
	case SOAP_TYPE_ns6__update____:
		return soap_in_ns6__update____(soap, NULL, NULL, "ns6:update");
	case SOAP_TYPE_ns6__updateResponse____:
		return soap_in_ns6__updateResponse____(soap, NULL, NULL, "ns6:updateResponse");
	case SOAP_TYPE_ns6__update___:
		return soap_in_ns6__update___(soap, NULL, NULL, "ns6:update");
	case SOAP_TYPE_ns6__updateResponse___:
		return soap_in_ns6__updateResponse___(soap, NULL, NULL, "ns6:updateResponse");
	case SOAP_TYPE_ns6__update__:
		return soap_in_ns6__update__(soap, NULL, NULL, "ns6:update");
	case SOAP_TYPE_ns6__updateResponse__:
		return soap_in_ns6__updateResponse__(soap, NULL, NULL, "ns6:updateResponse");
	case SOAP_TYPE_ns6__update_:
		return soap_in_ns6__update_(soap, NULL, NULL, "ns6:update");
	case SOAP_TYPE_ns6__updateResponse_:
		return soap_in_ns6__updateResponse_(soap, NULL, NULL, "ns6:updateResponse");
	case SOAP_TYPE_ns6__update:
		return soap_in_ns6__update(soap, NULL, NULL, "ns6:update");
	case SOAP_TYPE_ns6__updateResponse:
		return soap_in_ns6__updateResponse(soap, NULL, NULL, "ns6:updateResponse");
	case SOAP_TYPE_ns6__getAttributes:
		return soap_in_ns6__getAttributes(soap, NULL, NULL, "ns6:getAttributes");
	case SOAP_TYPE_ns6__getAttributesResponse:
		return soap_in_ns6__getAttributesResponse(soap, NULL, NULL, "ns6:getAttributesResponse");
	case SOAP_TYPE_PointerToArrayOf_USCOREtns1_USCORENoteData:
		return soap_in_PointerToArrayOf_USCOREtns1_USCORENoteData(soap, NULL, NULL, "ns4:NoteData");
	case SOAP_TYPE_PointerToArrayOf_USCOREtns1_USCOREProjectData:
		return soap_in_PointerToArrayOf_USCOREtns1_USCOREProjectData(soap, NULL, NULL, "ns4:ProjectData");
	case SOAP_TYPE_PointerToArrayOf_USCOREtns1_USCOREPersonData:
		return soap_in_PointerToArrayOf_USCOREtns1_USCOREPersonData(soap, NULL, NULL, "ns4:PersonData");
	case SOAP_TYPE_PointerToArrayOf_USCOREtns1_USCORETimeEntryData:
		return soap_in_PointerToArrayOf_USCOREtns1_USCORETimeEntryData(soap, NULL, NULL, "ns4:TimeEntryData");
	case SOAP_TYPE_PointerToArrayOf_USCOREtns1_USCORETaskData:
		return soap_in_PointerToArrayOf_USCOREtns1_USCORETaskData(soap, NULL, NULL, "ns4:TaskData");
	case SOAP_TYPE_PointerToArrayOf_USCOREtns1_USCOREUserStoryData:
		return soap_in_PointerToArrayOf_USCOREtns1_USCOREUserStoryData(soap, NULL, NULL, "ns4:UserStoryData");
	case SOAP_TYPE_PointerToArrayOf_USCOREtns1_USCOREIterationData:
		return soap_in_PointerToArrayOf_USCOREtns1_USCOREIterationData(soap, NULL, NULL, "ns4:IterationData");
	case SOAP_TYPE_PointerTons2__Map:
		return soap_in_PointerTons2__Map(soap, NULL, NULL, "ns2:Map");
	case SOAP_TYPE_PointerTo_ns1__QueryException:
		return soap_in_PointerTo_ns1__QueryException(soap, NULL, NULL, "ns1:QueryException");
	case SOAP_TYPE_PointerTons5__QueryException:
		return soap_in_PointerTons5__QueryException(soap, NULL, NULL, "ns5:QueryException");
	case SOAP_TYPE_PointerToPointerTons4__NoteData:
		return soap_in_PointerToPointerTons4__NoteData(soap, NULL, NULL, "ns4:NoteData");
	case SOAP_TYPE_PointerTons4__NoteData:
		return soap_in_PointerTons4__NoteData(soap, NULL, NULL, "ns4:NoteData");
	case SOAP_TYPE_PointerToPointerTons4__ProjectData:
		return soap_in_PointerToPointerTons4__ProjectData(soap, NULL, NULL, "ns4:ProjectData");
	case SOAP_TYPE_PointerTons4__ProjectData:
		return soap_in_PointerTons4__ProjectData(soap, NULL, NULL, "ns4:ProjectData");
	case SOAP_TYPE_PointerToPointerTons4__PersonData:
		return soap_in_PointerToPointerTons4__PersonData(soap, NULL, NULL, "ns4:PersonData");
	case SOAP_TYPE_PointerTons4__PersonData:
		return soap_in_PointerTons4__PersonData(soap, NULL, NULL, "ns4:PersonData");
	case SOAP_TYPE_PointerToPointerTons4__TimeEntryData:
		return soap_in_PointerToPointerTons4__TimeEntryData(soap, NULL, NULL, "ns4:TimeEntryData");
	case SOAP_TYPE_PointerTons4__TimeEntryData:
		return soap_in_PointerTons4__TimeEntryData(soap, NULL, NULL, "ns4:TimeEntryData");
	case SOAP_TYPE_PointerToPointerTons4__TaskData:
		return soap_in_PointerToPointerTons4__TaskData(soap, NULL, NULL, "ns4:TaskData");
	case SOAP_TYPE_PointerTons4__TaskData:
		return soap_in_PointerTons4__TaskData(soap, NULL, NULL, "ns4:TaskData");
	case SOAP_TYPE_PointerToPointerTons4__UserStoryData:
		return soap_in_PointerToPointerTons4__UserStoryData(soap, NULL, NULL, "ns4:UserStoryData");
	case SOAP_TYPE_PointerTons4__UserStoryData:
		return soap_in_PointerTons4__UserStoryData(soap, NULL, NULL, "ns4:UserStoryData");
	case SOAP_TYPE_PointerToPointerTons4__IterationData:
		return soap_in_PointerToPointerTons4__IterationData(soap, NULL, NULL, "ns4:IterationData");
	case SOAP_TYPE_PointerTons4__IterationData:
		return soap_in_PointerTons4__IterationData(soap, NULL, NULL, "ns4:IterationData");
	case SOAP_TYPE_PointerTotime:
		return soap_in_PointerTotime(soap, NULL, NULL, "xsd:dateTime");
	case SOAP_TYPE_PointerToPointerTons2__mapItem:
		return soap_in_PointerToPointerTons2__mapItem(soap, NULL, NULL, "ns2:mapItem");
	case SOAP_TYPE_PointerTons2__mapItem:
		return soap_in_PointerTons2__mapItem(soap, NULL, NULL, "ns2:mapItem");
	case SOAP_TYPE_PointerToxsd__anyType:
		return soap_in_PointerToxsd__anyType(soap, NULL, NULL, "xsd:anyType");
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "ns5:QueryException"))
		{	*type = SOAP_TYPE_ns5__QueryException;
			return soap_in_ns5__QueryException(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns4:NoteData"))
		{	*type = SOAP_TYPE_ArrayOf_USCOREtns1_USCORENoteData;
			return soap_in_ArrayOf_USCOREtns1_USCORENoteData(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns4:ProjectData"))
		{	*type = SOAP_TYPE_ArrayOf_USCOREtns1_USCOREProjectData;
			return soap_in_ArrayOf_USCOREtns1_USCOREProjectData(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns4:PersonData"))
		{	*type = SOAP_TYPE_ArrayOf_USCOREtns1_USCOREPersonData;
			return soap_in_ArrayOf_USCOREtns1_USCOREPersonData(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns4:TimeEntryData"))
		{	*type = SOAP_TYPE_ArrayOf_USCOREtns1_USCORETimeEntryData;
			return soap_in_ArrayOf_USCOREtns1_USCORETimeEntryData(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns4:TaskData"))
		{	*type = SOAP_TYPE_ArrayOf_USCOREtns1_USCORETaskData;
			return soap_in_ArrayOf_USCOREtns1_USCORETaskData(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns4:UserStoryData"))
		{	*type = SOAP_TYPE_ArrayOf_USCOREtns1_USCOREUserStoryData;
			return soap_in_ArrayOf_USCOREtns1_USCOREUserStoryData(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns4:IterationData"))
		{	*type = SOAP_TYPE_ArrayOf_USCOREtns1_USCOREIterationData;
			return soap_in_ArrayOf_USCOREtns1_USCOREIterationData(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:IterationData"))
		{	*type = SOAP_TYPE_ns4__IterationData;
			return soap_in_ns4__IterationData(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:TaskData"))
		{	*type = SOAP_TYPE_ns4__TaskData;
			return soap_in_ns4__TaskData(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:TimeEntryData"))
		{	*type = SOAP_TYPE_ns4__TimeEntryData;
			return soap_in_ns4__TimeEntryData(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:PersonData"))
		{	*type = SOAP_TYPE_ns4__PersonData;
			return soap_in_ns4__PersonData(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:UserStoryData"))
		{	*type = SOAP_TYPE_ns4__UserStoryData;
			return soap_in_ns4__UserStoryData(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:ProjectData"))
		{	*type = SOAP_TYPE_ns4__ProjectData;
			return soap_in_ns4__ProjectData(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns4:NoteData"))
		{	*type = SOAP_TYPE_ns4__NoteData;
			return soap_in_ns4__NoteData(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns3:DomainData"))
		{	*type = SOAP_TYPE_ns3__DomainData;
			return soap_in_ns3__DomainData(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:Map"))
		{	*type = SOAP_TYPE_ns2__Map;
			return soap_in_ns2__Map(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:mapItem"))
		{	*type = SOAP_TYPE_ns2__mapItem;
			return soap_in_ns2__mapItem(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_xsd__int;
			return soap_in_xsd__int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:double"))
		{	*type = SOAP_TYPE_xsd__double;
			return soap_in_xsd__double(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:dateTime"))
		{	*type = SOAP_TYPE_xsd__dateTime;
			return soap_in_xsd__dateTime(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:boolean"))
		{	*type = SOAP_TYPE_xsd__boolean;
			return soap_in_xsd__boolean(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:anyType"))
		{	*type = SOAP_TYPE_xsd__anyType;
			return soap_in_xsd__anyType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:double"))
		{	*type = SOAP_TYPE_double;
			return soap_in_double(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:dateTime"))
		{	*type = SOAP_TYPE_time;
			return soap_in_time(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:boolean"))
		{	*type = SOAP_TYPE_bool;
			return soap_in_bool(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:getAttributesWithPrefix"))
		{	*type = SOAP_TYPE_ns6__getAttributesWithPrefix;
			return soap_in_ns6__getAttributesWithPrefix(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:getAttributesWithPrefixResponse"))
		{	*type = SOAP_TYPE_ns6__getAttributesWithPrefixResponse;
			return soap_in_ns6__getAttributesWithPrefixResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:deleteAttribute"))
		{	*type = SOAP_TYPE_ns6__deleteAttribute;
			return soap_in_ns6__deleteAttribute(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:deleteAttributeResponse"))
		{	*type = SOAP_TYPE_ns6__deleteAttributeResponse;
			return soap_in_ns6__deleteAttributeResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:removePerson"))
		{	*type = SOAP_TYPE_ns6__removePerson;
			return soap_in_ns6__removePerson(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:removePersonResponse"))
		{	*type = SOAP_TYPE_ns6__removePersonResponse;
			return soap_in_ns6__removePersonResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:addPerson"))
		{	*type = SOAP_TYPE_ns6__addPerson;
			return soap_in_ns6__addPerson(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:addPersonResponse"))
		{	*type = SOAP_TYPE_ns6__addPersonResponse;
			return soap_in_ns6__addPersonResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:getNotesForObject"))
		{	*type = SOAP_TYPE_ns6__getNotesForObject;
			return soap_in_ns6__getNotesForObject(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:getNotesForObjectResponse"))
		{	*type = SOAP_TYPE_ns6__getNotesForObjectResponse;
			return soap_in_ns6__getNotesForObjectResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:addNote"))
		{	*type = SOAP_TYPE_ns6__addNote;
			return soap_in_ns6__addNote(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:addNoteResponse"))
		{	*type = SOAP_TYPE_ns6__addNoteResponse;
			return soap_in_ns6__addNoteResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:removeTimeEntry"))
		{	*type = SOAP_TYPE_ns6__removeTimeEntry;
			return soap_in_ns6__removeTimeEntry(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:removeTimeEntryResponse"))
		{	*type = SOAP_TYPE_ns6__removeTimeEntryResponse;
			return soap_in_ns6__removeTimeEntryResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:addTimeEntry"))
		{	*type = SOAP_TYPE_ns6__addTimeEntry;
			return soap_in_ns6__addTimeEntry(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:addTimeEntryResponse"))
		{	*type = SOAP_TYPE_ns6__addTimeEntryResponse;
			return soap_in_ns6__addTimeEntryResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:getTimeEntry"))
		{	*type = SOAP_TYPE_ns6__getTimeEntry;
			return soap_in_ns6__getTimeEntry(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:getTimeEntryResponse"))
		{	*type = SOAP_TYPE_ns6__getTimeEntryResponse;
			return soap_in_ns6__getTimeEntryResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:removeTask"))
		{	*type = SOAP_TYPE_ns6__removeTask;
			return soap_in_ns6__removeTask(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:removeTaskResponse"))
		{	*type = SOAP_TYPE_ns6__removeTaskResponse;
			return soap_in_ns6__removeTaskResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:getPlannedTasksForPerson"))
		{	*type = SOAP_TYPE_ns6__getPlannedTasksForPerson;
			return soap_in_ns6__getPlannedTasksForPerson(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:getPlannedTasksForPersonResponse"))
		{	*type = SOAP_TYPE_ns6__getPlannedTasksForPersonResponse;
			return soap_in_ns6__getPlannedTasksForPersonResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:removeUserStory"))
		{	*type = SOAP_TYPE_ns6__removeUserStory;
			return soap_in_ns6__removeUserStory(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:removeUserStoryResponse"))
		{	*type = SOAP_TYPE_ns6__removeUserStoryResponse;
			return soap_in_ns6__removeUserStoryResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:addUserStory"))
		{	*type = SOAP_TYPE_ns6__addUserStory;
			return soap_in_ns6__addUserStory(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:addUserStoryResponse"))
		{	*type = SOAP_TYPE_ns6__addUserStoryResponse;
			return soap_in_ns6__addUserStoryResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:removeIteration"))
		{	*type = SOAP_TYPE_ns6__removeIteration;
			return soap_in_ns6__removeIteration(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:removeIterationResponse"))
		{	*type = SOAP_TYPE_ns6__removeIterationResponse;
			return soap_in_ns6__removeIterationResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:addIteration"))
		{	*type = SOAP_TYPE_ns6__addIteration;
			return soap_in_ns6__addIteration(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:addIterationResponse"))
		{	*type = SOAP_TYPE_ns6__addIterationResponse;
			return soap_in_ns6__addIterationResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:removeProject"))
		{	*type = SOAP_TYPE_ns6__removeProject;
			return soap_in_ns6__removeProject(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:removeProjectResponse"))
		{	*type = SOAP_TYPE_ns6__removeProjectResponse;
			return soap_in_ns6__removeProjectResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:addProject"))
		{	*type = SOAP_TYPE_ns6__addProject;
			return soap_in_ns6__addProject(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:addProjectResponse"))
		{	*type = SOAP_TYPE_ns6__addProjectResponse;
			return soap_in_ns6__addProjectResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:getProjects"))
		{	*type = SOAP_TYPE_ns6__getProjects;
			return soap_in_ns6__getProjects(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:getProjectsResponse"))
		{	*type = SOAP_TYPE_ns6__getProjectsResponse;
			return soap_in_ns6__getProjectsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:getUserStory"))
		{	*type = SOAP_TYPE_ns6__getUserStory;
			return soap_in_ns6__getUserStory(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:getUserStoryResponse"))
		{	*type = SOAP_TYPE_ns6__getUserStoryResponse;
			return soap_in_ns6__getUserStoryResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:getTask"))
		{	*type = SOAP_TYPE_ns6__getTask;
			return soap_in_ns6__getTask(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:getTaskResponse"))
		{	*type = SOAP_TYPE_ns6__getTaskResponse;
			return soap_in_ns6__getTaskResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:getIteration"))
		{	*type = SOAP_TYPE_ns6__getIteration;
			return soap_in_ns6__getIteration(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:getIterationResponse"))
		{	*type = SOAP_TYPE_ns6__getIterationResponse;
			return soap_in_ns6__getIterationResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:getProject"))
		{	*type = SOAP_TYPE_ns6__getProject;
			return soap_in_ns6__getProject(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:getProjectResponse"))
		{	*type = SOAP_TYPE_ns6__getProjectResponse;
			return soap_in_ns6__getProjectResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:getPeople"))
		{	*type = SOAP_TYPE_ns6__getPeople;
			return soap_in_ns6__getPeople(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:getPeopleResponse"))
		{	*type = SOAP_TYPE_ns6__getPeopleResponse;
			return soap_in_ns6__getPeopleResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:addTask"))
		{	*type = SOAP_TYPE_ns6__addTask;
			return soap_in_ns6__addTask(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:addTaskResponse"))
		{	*type = SOAP_TYPE_ns6__addTaskResponse;
			return soap_in_ns6__addTaskResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:getCurrentTasksForPerson"))
		{	*type = SOAP_TYPE_ns6__getCurrentTasksForPerson;
			return soap_in_ns6__getCurrentTasksForPerson(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:getCurrentTasksForPersonResponse"))
		{	*type = SOAP_TYPE_ns6__getCurrentTasksForPersonResponse;
			return soap_in_ns6__getCurrentTasksForPersonResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:getTimeEntries"))
		{	*type = SOAP_TYPE_ns6__getTimeEntries;
			return soap_in_ns6__getTimeEntries(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:getTimeEntriesResponse"))
		{	*type = SOAP_TYPE_ns6__getTimeEntriesResponse;
			return soap_in_ns6__getTimeEntriesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:getTasks"))
		{	*type = SOAP_TYPE_ns6__getTasks;
			return soap_in_ns6__getTasks(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:getTasksResponse"))
		{	*type = SOAP_TYPE_ns6__getTasksResponse;
			return soap_in_ns6__getTasksResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:getUserStories"))
		{	*type = SOAP_TYPE_ns6__getUserStories;
			return soap_in_ns6__getUserStories(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:getUserStoriesResponse"))
		{	*type = SOAP_TYPE_ns6__getUserStoriesResponse;
			return soap_in_ns6__getUserStoriesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:getCurrentIteration"))
		{	*type = SOAP_TYPE_ns6__getCurrentIteration;
			return soap_in_ns6__getCurrentIteration(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:getCurrentIterationResponse"))
		{	*type = SOAP_TYPE_ns6__getCurrentIterationResponse;
			return soap_in_ns6__getCurrentIterationResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:getIterations"))
		{	*type = SOAP_TYPE_ns6__getIterations;
			return soap_in_ns6__getIterations(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:getIterationsResponse"))
		{	*type = SOAP_TYPE_ns6__getIterationsResponse;
			return soap_in_ns6__getIterationsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:getPerson"))
		{	*type = SOAP_TYPE_ns6__getPerson;
			return soap_in_ns6__getPerson(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:getPersonResponse"))
		{	*type = SOAP_TYPE_ns6__getPersonResponse;
			return soap_in_ns6__getPersonResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:removeNote"))
		{	*type = SOAP_TYPE_ns6__removeNote;
			return soap_in_ns6__removeNote(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:removeNoteResponse"))
		{	*type = SOAP_TYPE_ns6__removeNoteResponse;
			return soap_in_ns6__removeNoteResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:getNote"))
		{	*type = SOAP_TYPE_ns6__getNote;
			return soap_in_ns6__getNote(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:getNoteResponse"))
		{	*type = SOAP_TYPE_ns6__getNoteResponse;
			return soap_in_ns6__getNoteResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:setAttribute"))
		{	*type = SOAP_TYPE_ns6__setAttribute;
			return soap_in_ns6__setAttribute(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:setAttributeResponse"))
		{	*type = SOAP_TYPE_ns6__setAttributeResponse;
			return soap_in_ns6__setAttributeResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:getAttribute"))
		{	*type = SOAP_TYPE_ns6__getAttribute;
			return soap_in_ns6__getAttribute(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:getAttributeResponse"))
		{	*type = SOAP_TYPE_ns6__getAttributeResponse;
			return soap_in_ns6__getAttributeResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:update"))
		{	*type = SOAP_TYPE_ns6__update______;
			return soap_in_ns6__update______(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:updateResponse"))
		{	*type = SOAP_TYPE_ns6__updateResponse______;
			return soap_in_ns6__updateResponse______(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:update"))
		{	*type = SOAP_TYPE_ns6__update_____;
			return soap_in_ns6__update_____(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:updateResponse"))
		{	*type = SOAP_TYPE_ns6__updateResponse_____;
			return soap_in_ns6__updateResponse_____(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:update"))
		{	*type = SOAP_TYPE_ns6__update____;
			return soap_in_ns6__update____(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:updateResponse"))
		{	*type = SOAP_TYPE_ns6__updateResponse____;
			return soap_in_ns6__updateResponse____(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:update"))
		{	*type = SOAP_TYPE_ns6__update___;
			return soap_in_ns6__update___(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:updateResponse"))
		{	*type = SOAP_TYPE_ns6__updateResponse___;
			return soap_in_ns6__updateResponse___(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:update"))
		{	*type = SOAP_TYPE_ns6__update__;
			return soap_in_ns6__update__(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:updateResponse"))
		{	*type = SOAP_TYPE_ns6__updateResponse__;
			return soap_in_ns6__updateResponse__(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:update"))
		{	*type = SOAP_TYPE_ns6__update_;
			return soap_in_ns6__update_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:updateResponse"))
		{	*type = SOAP_TYPE_ns6__updateResponse_;
			return soap_in_ns6__updateResponse_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:update"))
		{	*type = SOAP_TYPE_ns6__update;
			return soap_in_ns6__update(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:updateResponse"))
		{	*type = SOAP_TYPE_ns6__updateResponse;
			return soap_in_ns6__updateResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:getAttributes"))
		{	*type = SOAP_TYPE_ns6__getAttributes;
			return soap_in_ns6__getAttributes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns6:getAttributesResponse"))
		{	*type = SOAP_TYPE_ns6__getAttributesResponse;
			return soap_in_ns6__getAttributesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
		if (!soap_match_tag(soap, t, "ns1:QueryException"))
		{	*type = SOAP_TYPE__ns1__QueryException;
			return soap_in__ns1__QueryException(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
	}
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

#ifdef __cplusplus
}
#endif
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input (level=%u, %d)\n", soap->tag, soap->level, soap->body));
		if (soap->mustUnderstand && !soap->other)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body)
			{	soap->level++;
				while (!soap_ignore_element(soap))
					;
				if (soap->error == SOAP_NO_TAG)
					soap->error = soap_element_end_in(soap, NULL);
			}
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, "id", pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{
	switch (type)
	{
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_double:
		return soap_out_double(soap, tag, id, (const double *)ptr, "xsd:double");
	case SOAP_TYPE_time:
		return soap_out_time(soap, tag, id, (const time_t *)ptr, "xsd:dateTime");
	case SOAP_TYPE_bool:
		return soap_out_bool(soap, tag, id, (const bool *)ptr, "xsd:boolean");
	case SOAP_TYPE__ns1__QueryException:
		return ((_ns1__QueryException *)ptr)->soap_out(soap, "ns1:QueryException", id, NULL);
	case SOAP_TYPE_ns5__QueryException:
		return ((ns5__QueryException *)ptr)->soap_out(soap, tag, id, "ns5:QueryException");
	case SOAP_TYPE_ArrayOf_USCOREtns1_USCORENoteData:
		return ((ArrayOf_USCOREtns1_USCORENoteData *)ptr)->soap_out(soap, tag, id, "ns4:NoteData");
	case SOAP_TYPE_ArrayOf_USCOREtns1_USCOREProjectData:
		return ((ArrayOf_USCOREtns1_USCOREProjectData *)ptr)->soap_out(soap, tag, id, "ns4:ProjectData");
	case SOAP_TYPE_ArrayOf_USCOREtns1_USCOREPersonData:
		return ((ArrayOf_USCOREtns1_USCOREPersonData *)ptr)->soap_out(soap, tag, id, "ns4:PersonData");
	case SOAP_TYPE_ArrayOf_USCOREtns1_USCORETimeEntryData:
		return ((ArrayOf_USCOREtns1_USCORETimeEntryData *)ptr)->soap_out(soap, tag, id, "ns4:TimeEntryData");
	case SOAP_TYPE_ArrayOf_USCOREtns1_USCORETaskData:
		return ((ArrayOf_USCOREtns1_USCORETaskData *)ptr)->soap_out(soap, tag, id, "ns4:TaskData");
	case SOAP_TYPE_ArrayOf_USCOREtns1_USCOREUserStoryData:
		return ((ArrayOf_USCOREtns1_USCOREUserStoryData *)ptr)->soap_out(soap, tag, id, "ns4:UserStoryData");
	case SOAP_TYPE_ArrayOf_USCOREtns1_USCOREIterationData:
		return ((ArrayOf_USCOREtns1_USCOREIterationData *)ptr)->soap_out(soap, tag, id, "ns4:IterationData");
	case SOAP_TYPE_ns4__IterationData:
		return ((ns4__IterationData *)ptr)->soap_out(soap, tag, id, "ns4:IterationData");
	case SOAP_TYPE_ns4__TaskData:
		return ((ns4__TaskData *)ptr)->soap_out(soap, tag, id, "ns4:TaskData");
	case SOAP_TYPE_ns4__TimeEntryData:
		return ((ns4__TimeEntryData *)ptr)->soap_out(soap, tag, id, "ns4:TimeEntryData");
	case SOAP_TYPE_ns4__PersonData:
		return ((ns4__PersonData *)ptr)->soap_out(soap, tag, id, "ns4:PersonData");
	case SOAP_TYPE_ns4__UserStoryData:
		return ((ns4__UserStoryData *)ptr)->soap_out(soap, tag, id, "ns4:UserStoryData");
	case SOAP_TYPE_ns4__ProjectData:
		return ((ns4__ProjectData *)ptr)->soap_out(soap, tag, id, "ns4:ProjectData");
	case SOAP_TYPE_ns4__NoteData:
		return ((ns4__NoteData *)ptr)->soap_out(soap, tag, id, "ns4:NoteData");
	case SOAP_TYPE_ns3__DomainData:
		return ((ns3__DomainData *)ptr)->soap_out(soap, tag, id, "ns3:DomainData");
	case SOAP_TYPE_ns2__Map:
		return ((ns2__Map *)ptr)->soap_out(soap, tag, id, "ns2:Map");
	case SOAP_TYPE_ns2__mapItem:
		return ((ns2__mapItem *)ptr)->soap_out(soap, tag, id, "ns2:mapItem");
	case SOAP_TYPE_xsd__int:
		return ((xsd__int *)ptr)->soap_out(soap, tag, id, "xsd:int");
	case SOAP_TYPE_xsd__double:
		return ((xsd__double *)ptr)->soap_out(soap, tag, id, "xsd:double");
	case SOAP_TYPE_xsd__dateTime:
		return ((xsd__dateTime *)ptr)->soap_out(soap, tag, id, "xsd:dateTime");
	case SOAP_TYPE_xsd__boolean:
		return ((xsd__boolean *)ptr)->soap_out(soap, tag, id, "xsd:boolean");
	case SOAP_TYPE_xsd__anyType:
		return ((xsd__anyType *)ptr)->soap_out(soap, tag, id, "xsd:anyType");
	case SOAP_TYPE_ns6__getAttributesWithPrefix:
		return soap_out_ns6__getAttributesWithPrefix(soap, tag, id, (const struct ns6__getAttributesWithPrefix *)ptr, "ns6:getAttributesWithPrefix");
	case SOAP_TYPE_ns6__getAttributesWithPrefixResponse:
		return soap_out_ns6__getAttributesWithPrefixResponse(soap, tag, id, (const struct ns6__getAttributesWithPrefixResponse *)ptr, "ns6:getAttributesWithPrefixResponse");
	case SOAP_TYPE_ns6__deleteAttribute:
		return soap_out_ns6__deleteAttribute(soap, tag, id, (const struct ns6__deleteAttribute *)ptr, "ns6:deleteAttribute");
	case SOAP_TYPE_ns6__deleteAttributeResponse:
		return soap_out_ns6__deleteAttributeResponse(soap, tag, id, (const struct ns6__deleteAttributeResponse *)ptr, "ns6:deleteAttributeResponse");
	case SOAP_TYPE_ns6__removePerson:
		return soap_out_ns6__removePerson(soap, tag, id, (const struct ns6__removePerson *)ptr, "ns6:removePerson");
	case SOAP_TYPE_ns6__removePersonResponse:
		return soap_out_ns6__removePersonResponse(soap, tag, id, (const struct ns6__removePersonResponse *)ptr, "ns6:removePersonResponse");
	case SOAP_TYPE_ns6__addPerson:
		return soap_out_ns6__addPerson(soap, tag, id, (const struct ns6__addPerson *)ptr, "ns6:addPerson");
	case SOAP_TYPE_ns6__addPersonResponse:
		return soap_out_ns6__addPersonResponse(soap, tag, id, (const struct ns6__addPersonResponse *)ptr, "ns6:addPersonResponse");
	case SOAP_TYPE_ns6__getNotesForObject:
		return soap_out_ns6__getNotesForObject(soap, tag, id, (const struct ns6__getNotesForObject *)ptr, "ns6:getNotesForObject");
	case SOAP_TYPE_ns6__getNotesForObjectResponse:
		return soap_out_ns6__getNotesForObjectResponse(soap, tag, id, (const struct ns6__getNotesForObjectResponse *)ptr, "ns6:getNotesForObjectResponse");
	case SOAP_TYPE_ns6__addNote:
		return soap_out_ns6__addNote(soap, tag, id, (const struct ns6__addNote *)ptr, "ns6:addNote");
	case SOAP_TYPE_ns6__addNoteResponse:
		return soap_out_ns6__addNoteResponse(soap, tag, id, (const struct ns6__addNoteResponse *)ptr, "ns6:addNoteResponse");
	case SOAP_TYPE_ns6__removeTimeEntry:
		return soap_out_ns6__removeTimeEntry(soap, tag, id, (const struct ns6__removeTimeEntry *)ptr, "ns6:removeTimeEntry");
	case SOAP_TYPE_ns6__removeTimeEntryResponse:
		return soap_out_ns6__removeTimeEntryResponse(soap, tag, id, (const struct ns6__removeTimeEntryResponse *)ptr, "ns6:removeTimeEntryResponse");
	case SOAP_TYPE_ns6__addTimeEntry:
		return soap_out_ns6__addTimeEntry(soap, tag, id, (const struct ns6__addTimeEntry *)ptr, "ns6:addTimeEntry");
	case SOAP_TYPE_ns6__addTimeEntryResponse:
		return soap_out_ns6__addTimeEntryResponse(soap, tag, id, (const struct ns6__addTimeEntryResponse *)ptr, "ns6:addTimeEntryResponse");
	case SOAP_TYPE_ns6__getTimeEntry:
		return soap_out_ns6__getTimeEntry(soap, tag, id, (const struct ns6__getTimeEntry *)ptr, "ns6:getTimeEntry");
	case SOAP_TYPE_ns6__getTimeEntryResponse:
		return soap_out_ns6__getTimeEntryResponse(soap, tag, id, (const struct ns6__getTimeEntryResponse *)ptr, "ns6:getTimeEntryResponse");
	case SOAP_TYPE_ns6__removeTask:
		return soap_out_ns6__removeTask(soap, tag, id, (const struct ns6__removeTask *)ptr, "ns6:removeTask");
	case SOAP_TYPE_ns6__removeTaskResponse:
		return soap_out_ns6__removeTaskResponse(soap, tag, id, (const struct ns6__removeTaskResponse *)ptr, "ns6:removeTaskResponse");
	case SOAP_TYPE_ns6__getPlannedTasksForPerson:
		return soap_out_ns6__getPlannedTasksForPerson(soap, tag, id, (const struct ns6__getPlannedTasksForPerson *)ptr, "ns6:getPlannedTasksForPerson");
	case SOAP_TYPE_ns6__getPlannedTasksForPersonResponse:
		return soap_out_ns6__getPlannedTasksForPersonResponse(soap, tag, id, (const struct ns6__getPlannedTasksForPersonResponse *)ptr, "ns6:getPlannedTasksForPersonResponse");
	case SOAP_TYPE_ns6__removeUserStory:
		return soap_out_ns6__removeUserStory(soap, tag, id, (const struct ns6__removeUserStory *)ptr, "ns6:removeUserStory");
	case SOAP_TYPE_ns6__removeUserStoryResponse:
		return soap_out_ns6__removeUserStoryResponse(soap, tag, id, (const struct ns6__removeUserStoryResponse *)ptr, "ns6:removeUserStoryResponse");
	case SOAP_TYPE_ns6__addUserStory:
		return soap_out_ns6__addUserStory(soap, tag, id, (const struct ns6__addUserStory *)ptr, "ns6:addUserStory");
	case SOAP_TYPE_ns6__addUserStoryResponse:
		return soap_out_ns6__addUserStoryResponse(soap, tag, id, (const struct ns6__addUserStoryResponse *)ptr, "ns6:addUserStoryResponse");
	case SOAP_TYPE_ns6__removeIteration:
		return soap_out_ns6__removeIteration(soap, tag, id, (const struct ns6__removeIteration *)ptr, "ns6:removeIteration");
	case SOAP_TYPE_ns6__removeIterationResponse:
		return soap_out_ns6__removeIterationResponse(soap, tag, id, (const struct ns6__removeIterationResponse *)ptr, "ns6:removeIterationResponse");
	case SOAP_TYPE_ns6__addIteration:
		return soap_out_ns6__addIteration(soap, tag, id, (const struct ns6__addIteration *)ptr, "ns6:addIteration");
	case SOAP_TYPE_ns6__addIterationResponse:
		return soap_out_ns6__addIterationResponse(soap, tag, id, (const struct ns6__addIterationResponse *)ptr, "ns6:addIterationResponse");
	case SOAP_TYPE_ns6__removeProject:
		return soap_out_ns6__removeProject(soap, tag, id, (const struct ns6__removeProject *)ptr, "ns6:removeProject");
	case SOAP_TYPE_ns6__removeProjectResponse:
		return soap_out_ns6__removeProjectResponse(soap, tag, id, (const struct ns6__removeProjectResponse *)ptr, "ns6:removeProjectResponse");
	case SOAP_TYPE_ns6__addProject:
		return soap_out_ns6__addProject(soap, tag, id, (const struct ns6__addProject *)ptr, "ns6:addProject");
	case SOAP_TYPE_ns6__addProjectResponse:
		return soap_out_ns6__addProjectResponse(soap, tag, id, (const struct ns6__addProjectResponse *)ptr, "ns6:addProjectResponse");
	case SOAP_TYPE_ns6__getProjects:
		return soap_out_ns6__getProjects(soap, tag, id, (const struct ns6__getProjects *)ptr, "ns6:getProjects");
	case SOAP_TYPE_ns6__getProjectsResponse:
		return soap_out_ns6__getProjectsResponse(soap, tag, id, (const struct ns6__getProjectsResponse *)ptr, "ns6:getProjectsResponse");
	case SOAP_TYPE_ns6__getUserStory:
		return soap_out_ns6__getUserStory(soap, tag, id, (const struct ns6__getUserStory *)ptr, "ns6:getUserStory");
	case SOAP_TYPE_ns6__getUserStoryResponse:
		return soap_out_ns6__getUserStoryResponse(soap, tag, id, (const struct ns6__getUserStoryResponse *)ptr, "ns6:getUserStoryResponse");
	case SOAP_TYPE_ns6__getTask:
		return soap_out_ns6__getTask(soap, tag, id, (const struct ns6__getTask *)ptr, "ns6:getTask");
	case SOAP_TYPE_ns6__getTaskResponse:
		return soap_out_ns6__getTaskResponse(soap, tag, id, (const struct ns6__getTaskResponse *)ptr, "ns6:getTaskResponse");
	case SOAP_TYPE_ns6__getIteration:
		return soap_out_ns6__getIteration(soap, tag, id, (const struct ns6__getIteration *)ptr, "ns6:getIteration");
	case SOAP_TYPE_ns6__getIterationResponse:
		return soap_out_ns6__getIterationResponse(soap, tag, id, (const struct ns6__getIterationResponse *)ptr, "ns6:getIterationResponse");
	case SOAP_TYPE_ns6__getProject:
		return soap_out_ns6__getProject(soap, tag, id, (const struct ns6__getProject *)ptr, "ns6:getProject");
	case SOAP_TYPE_ns6__getProjectResponse:
		return soap_out_ns6__getProjectResponse(soap, tag, id, (const struct ns6__getProjectResponse *)ptr, "ns6:getProjectResponse");
	case SOAP_TYPE_ns6__getPeople:
		return soap_out_ns6__getPeople(soap, tag, id, (const struct ns6__getPeople *)ptr, "ns6:getPeople");
	case SOAP_TYPE_ns6__getPeopleResponse:
		return soap_out_ns6__getPeopleResponse(soap, tag, id, (const struct ns6__getPeopleResponse *)ptr, "ns6:getPeopleResponse");
	case SOAP_TYPE_ns6__addTask:
		return soap_out_ns6__addTask(soap, tag, id, (const struct ns6__addTask *)ptr, "ns6:addTask");
	case SOAP_TYPE_ns6__addTaskResponse:
		return soap_out_ns6__addTaskResponse(soap, tag, id, (const struct ns6__addTaskResponse *)ptr, "ns6:addTaskResponse");
	case SOAP_TYPE_ns6__getCurrentTasksForPerson:
		return soap_out_ns6__getCurrentTasksForPerson(soap, tag, id, (const struct ns6__getCurrentTasksForPerson *)ptr, "ns6:getCurrentTasksForPerson");
	case SOAP_TYPE_ns6__getCurrentTasksForPersonResponse:
		return soap_out_ns6__getCurrentTasksForPersonResponse(soap, tag, id, (const struct ns6__getCurrentTasksForPersonResponse *)ptr, "ns6:getCurrentTasksForPersonResponse");
	case SOAP_TYPE_ns6__getTimeEntries:
		return soap_out_ns6__getTimeEntries(soap, tag, id, (const struct ns6__getTimeEntries *)ptr, "ns6:getTimeEntries");
	case SOAP_TYPE_ns6__getTimeEntriesResponse:
		return soap_out_ns6__getTimeEntriesResponse(soap, tag, id, (const struct ns6__getTimeEntriesResponse *)ptr, "ns6:getTimeEntriesResponse");
	case SOAP_TYPE_ns6__getTasks:
		return soap_out_ns6__getTasks(soap, tag, id, (const struct ns6__getTasks *)ptr, "ns6:getTasks");
	case SOAP_TYPE_ns6__getTasksResponse:
		return soap_out_ns6__getTasksResponse(soap, tag, id, (const struct ns6__getTasksResponse *)ptr, "ns6:getTasksResponse");
	case SOAP_TYPE_ns6__getUserStories:
		return soap_out_ns6__getUserStories(soap, tag, id, (const struct ns6__getUserStories *)ptr, "ns6:getUserStories");
	case SOAP_TYPE_ns6__getUserStoriesResponse:
		return soap_out_ns6__getUserStoriesResponse(soap, tag, id, (const struct ns6__getUserStoriesResponse *)ptr, "ns6:getUserStoriesResponse");
	case SOAP_TYPE_ns6__getCurrentIteration:
		return soap_out_ns6__getCurrentIteration(soap, tag, id, (const struct ns6__getCurrentIteration *)ptr, "ns6:getCurrentIteration");
	case SOAP_TYPE_ns6__getCurrentIterationResponse:
		return soap_out_ns6__getCurrentIterationResponse(soap, tag, id, (const struct ns6__getCurrentIterationResponse *)ptr, "ns6:getCurrentIterationResponse");
	case SOAP_TYPE_ns6__getIterations:
		return soap_out_ns6__getIterations(soap, tag, id, (const struct ns6__getIterations *)ptr, "ns6:getIterations");
	case SOAP_TYPE_ns6__getIterationsResponse:
		return soap_out_ns6__getIterationsResponse(soap, tag, id, (const struct ns6__getIterationsResponse *)ptr, "ns6:getIterationsResponse");
	case SOAP_TYPE_ns6__getPerson:
		return soap_out_ns6__getPerson(soap, tag, id, (const struct ns6__getPerson *)ptr, "ns6:getPerson");
	case SOAP_TYPE_ns6__getPersonResponse:
		return soap_out_ns6__getPersonResponse(soap, tag, id, (const struct ns6__getPersonResponse *)ptr, "ns6:getPersonResponse");
	case SOAP_TYPE_ns6__removeNote:
		return soap_out_ns6__removeNote(soap, tag, id, (const struct ns6__removeNote *)ptr, "ns6:removeNote");
	case SOAP_TYPE_ns6__removeNoteResponse:
		return soap_out_ns6__removeNoteResponse(soap, tag, id, (const struct ns6__removeNoteResponse *)ptr, "ns6:removeNoteResponse");
	case SOAP_TYPE_ns6__getNote:
		return soap_out_ns6__getNote(soap, tag, id, (const struct ns6__getNote *)ptr, "ns6:getNote");
	case SOAP_TYPE_ns6__getNoteResponse:
		return soap_out_ns6__getNoteResponse(soap, tag, id, (const struct ns6__getNoteResponse *)ptr, "ns6:getNoteResponse");
	case SOAP_TYPE_ns6__setAttribute:
		return soap_out_ns6__setAttribute(soap, tag, id, (const struct ns6__setAttribute *)ptr, "ns6:setAttribute");
	case SOAP_TYPE_ns6__setAttributeResponse:
		return soap_out_ns6__setAttributeResponse(soap, tag, id, (const struct ns6__setAttributeResponse *)ptr, "ns6:setAttributeResponse");
	case SOAP_TYPE_ns6__getAttribute:
		return soap_out_ns6__getAttribute(soap, tag, id, (const struct ns6__getAttribute *)ptr, "ns6:getAttribute");
	case SOAP_TYPE_ns6__getAttributeResponse:
		return soap_out_ns6__getAttributeResponse(soap, tag, id, (const struct ns6__getAttributeResponse *)ptr, "ns6:getAttributeResponse");
	case SOAP_TYPE_ns6__update______:
		return soap_out_ns6__update______(soap, tag, id, (const struct ns6__update______ *)ptr, "ns6:update");
	case SOAP_TYPE_ns6__updateResponse______:
		return soap_out_ns6__updateResponse______(soap, tag, id, (const struct ns6__updateResponse______ *)ptr, "ns6:updateResponse");
	case SOAP_TYPE_ns6__update_____:
		return soap_out_ns6__update_____(soap, tag, id, (const struct ns6__update_____ *)ptr, "ns6:update");
	case SOAP_TYPE_ns6__updateResponse_____:
		return soap_out_ns6__updateResponse_____(soap, tag, id, (const struct ns6__updateResponse_____ *)ptr, "ns6:updateResponse");
	case SOAP_TYPE_ns6__update____:
		return soap_out_ns6__update____(soap, tag, id, (const struct ns6__update____ *)ptr, "ns6:update");
	case SOAP_TYPE_ns6__updateResponse____:
		return soap_out_ns6__updateResponse____(soap, tag, id, (const struct ns6__updateResponse____ *)ptr, "ns6:updateResponse");
	case SOAP_TYPE_ns6__update___:
		return soap_out_ns6__update___(soap, tag, id, (const struct ns6__update___ *)ptr, "ns6:update");
	case SOAP_TYPE_ns6__updateResponse___:
		return soap_out_ns6__updateResponse___(soap, tag, id, (const struct ns6__updateResponse___ *)ptr, "ns6:updateResponse");
	case SOAP_TYPE_ns6__update__:
		return soap_out_ns6__update__(soap, tag, id, (const struct ns6__update__ *)ptr, "ns6:update");
	case SOAP_TYPE_ns6__updateResponse__:
		return soap_out_ns6__updateResponse__(soap, tag, id, (const struct ns6__updateResponse__ *)ptr, "ns6:updateResponse");
	case SOAP_TYPE_ns6__update_:
		return soap_out_ns6__update_(soap, tag, id, (const struct ns6__update_ *)ptr, "ns6:update");
	case SOAP_TYPE_ns6__updateResponse_:
		return soap_out_ns6__updateResponse_(soap, tag, id, (const struct ns6__updateResponse_ *)ptr, "ns6:updateResponse");
	case SOAP_TYPE_ns6__update:
		return soap_out_ns6__update(soap, tag, id, (const struct ns6__update *)ptr, "ns6:update");
	case SOAP_TYPE_ns6__updateResponse:
		return soap_out_ns6__updateResponse(soap, tag, id, (const struct ns6__updateResponse *)ptr, "ns6:updateResponse");
	case SOAP_TYPE_ns6__getAttributes:
		return soap_out_ns6__getAttributes(soap, tag, id, (const struct ns6__getAttributes *)ptr, "ns6:getAttributes");
	case SOAP_TYPE_ns6__getAttributesResponse:
		return soap_out_ns6__getAttributesResponse(soap, tag, id, (const struct ns6__getAttributesResponse *)ptr, "ns6:getAttributesResponse");
	case SOAP_TYPE_PointerToArrayOf_USCOREtns1_USCORENoteData:
		return soap_out_PointerToArrayOf_USCOREtns1_USCORENoteData(soap, tag, id, (ArrayOf_USCOREtns1_USCORENoteData *const*)ptr, "ns4:NoteData");
	case SOAP_TYPE_PointerToArrayOf_USCOREtns1_USCOREProjectData:
		return soap_out_PointerToArrayOf_USCOREtns1_USCOREProjectData(soap, tag, id, (ArrayOf_USCOREtns1_USCOREProjectData *const*)ptr, "ns4:ProjectData");
	case SOAP_TYPE_PointerToArrayOf_USCOREtns1_USCOREPersonData:
		return soap_out_PointerToArrayOf_USCOREtns1_USCOREPersonData(soap, tag, id, (ArrayOf_USCOREtns1_USCOREPersonData *const*)ptr, "ns4:PersonData");
	case SOAP_TYPE_PointerToArrayOf_USCOREtns1_USCORETimeEntryData:
		return soap_out_PointerToArrayOf_USCOREtns1_USCORETimeEntryData(soap, tag, id, (ArrayOf_USCOREtns1_USCORETimeEntryData *const*)ptr, "ns4:TimeEntryData");
	case SOAP_TYPE_PointerToArrayOf_USCOREtns1_USCORETaskData:
		return soap_out_PointerToArrayOf_USCOREtns1_USCORETaskData(soap, tag, id, (ArrayOf_USCOREtns1_USCORETaskData *const*)ptr, "ns4:TaskData");
	case SOAP_TYPE_PointerToArrayOf_USCOREtns1_USCOREUserStoryData:
		return soap_out_PointerToArrayOf_USCOREtns1_USCOREUserStoryData(soap, tag, id, (ArrayOf_USCOREtns1_USCOREUserStoryData *const*)ptr, "ns4:UserStoryData");
	case SOAP_TYPE_PointerToArrayOf_USCOREtns1_USCOREIterationData:
		return soap_out_PointerToArrayOf_USCOREtns1_USCOREIterationData(soap, tag, id, (ArrayOf_USCOREtns1_USCOREIterationData *const*)ptr, "ns4:IterationData");
	case SOAP_TYPE_PointerTons2__Map:
		return soap_out_PointerTons2__Map(soap, tag, id, (ns2__Map *const*)ptr, "ns2:Map");
	case SOAP_TYPE_PointerTo_ns1__QueryException:
		return soap_out_PointerTo_ns1__QueryException(soap, tag, id, (_ns1__QueryException *const*)ptr, "ns1:QueryException");
	case SOAP_TYPE_PointerTons5__QueryException:
		return soap_out_PointerTons5__QueryException(soap, tag, id, (ns5__QueryException *const*)ptr, "ns5:QueryException");
	case SOAP_TYPE_PointerToPointerTons4__NoteData:
		return soap_out_PointerToPointerTons4__NoteData(soap, tag, id, (ns4__NoteData **const*)ptr, "ns4:NoteData");
	case SOAP_TYPE_PointerTons4__NoteData:
		return soap_out_PointerTons4__NoteData(soap, tag, id, (ns4__NoteData *const*)ptr, "ns4:NoteData");
	case SOAP_TYPE_PointerToPointerTons4__ProjectData:
		return soap_out_PointerToPointerTons4__ProjectData(soap, tag, id, (ns4__ProjectData **const*)ptr, "ns4:ProjectData");
	case SOAP_TYPE_PointerTons4__ProjectData:
		return soap_out_PointerTons4__ProjectData(soap, tag, id, (ns4__ProjectData *const*)ptr, "ns4:ProjectData");
	case SOAP_TYPE_PointerToPointerTons4__PersonData:
		return soap_out_PointerToPointerTons4__PersonData(soap, tag, id, (ns4__PersonData **const*)ptr, "ns4:PersonData");
	case SOAP_TYPE_PointerTons4__PersonData:
		return soap_out_PointerTons4__PersonData(soap, tag, id, (ns4__PersonData *const*)ptr, "ns4:PersonData");
	case SOAP_TYPE_PointerToPointerTons4__TimeEntryData:
		return soap_out_PointerToPointerTons4__TimeEntryData(soap, tag, id, (ns4__TimeEntryData **const*)ptr, "ns4:TimeEntryData");
	case SOAP_TYPE_PointerTons4__TimeEntryData:
		return soap_out_PointerTons4__TimeEntryData(soap, tag, id, (ns4__TimeEntryData *const*)ptr, "ns4:TimeEntryData");
	case SOAP_TYPE_PointerToPointerTons4__TaskData:
		return soap_out_PointerToPointerTons4__TaskData(soap, tag, id, (ns4__TaskData **const*)ptr, "ns4:TaskData");
	case SOAP_TYPE_PointerTons4__TaskData:
		return soap_out_PointerTons4__TaskData(soap, tag, id, (ns4__TaskData *const*)ptr, "ns4:TaskData");
	case SOAP_TYPE_PointerToPointerTons4__UserStoryData:
		return soap_out_PointerToPointerTons4__UserStoryData(soap, tag, id, (ns4__UserStoryData **const*)ptr, "ns4:UserStoryData");
	case SOAP_TYPE_PointerTons4__UserStoryData:
		return soap_out_PointerTons4__UserStoryData(soap, tag, id, (ns4__UserStoryData *const*)ptr, "ns4:UserStoryData");
	case SOAP_TYPE_PointerToPointerTons4__IterationData:
		return soap_out_PointerToPointerTons4__IterationData(soap, tag, id, (ns4__IterationData **const*)ptr, "ns4:IterationData");
	case SOAP_TYPE_PointerTons4__IterationData:
		return soap_out_PointerTons4__IterationData(soap, tag, id, (ns4__IterationData *const*)ptr, "ns4:IterationData");
	case SOAP_TYPE_PointerTotime:
		return soap_out_PointerTotime(soap, tag, id, (time_t *const*)ptr, "xsd:dateTime");
	case SOAP_TYPE_PointerToPointerTons2__mapItem:
		return soap_out_PointerToPointerTons2__mapItem(soap, tag, id, (ns2__mapItem **const*)ptr, "ns2:mapItem");
	case SOAP_TYPE_PointerTons2__mapItem:
		return soap_out_PointerTons2__mapItem(soap, tag, id, (ns2__mapItem *const*)ptr, "ns2:mapItem");
	case SOAP_TYPE_PointerToxsd__anyType:
		return soap_out_PointerToxsd__anyType(soap, tag, id, (xsd__anyType *const*)ptr, "xsd:anyType");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, "xsd:QName", id, (char*const*)&ptr, NULL);
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:string");
	}
	return SOAP_OK;
}

#ifdef __cplusplus
}
#endif
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE__ns1__QueryException:
		((_ns1__QueryException *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns5__QueryException:
		((ns5__QueryException *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ArrayOf_USCOREtns1_USCORENoteData:
		((ArrayOf_USCOREtns1_USCORENoteData *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ArrayOf_USCOREtns1_USCOREProjectData:
		((ArrayOf_USCOREtns1_USCOREProjectData *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ArrayOf_USCOREtns1_USCOREPersonData:
		((ArrayOf_USCOREtns1_USCOREPersonData *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ArrayOf_USCOREtns1_USCORETimeEntryData:
		((ArrayOf_USCOREtns1_USCORETimeEntryData *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ArrayOf_USCOREtns1_USCORETaskData:
		((ArrayOf_USCOREtns1_USCORETaskData *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ArrayOf_USCOREtns1_USCOREUserStoryData:
		((ArrayOf_USCOREtns1_USCOREUserStoryData *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ArrayOf_USCOREtns1_USCOREIterationData:
		((ArrayOf_USCOREtns1_USCOREIterationData *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns4__IterationData:
		((ns4__IterationData *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns4__TaskData:
		((ns4__TaskData *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns4__TimeEntryData:
		((ns4__TimeEntryData *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns4__PersonData:
		((ns4__PersonData *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns4__UserStoryData:
		((ns4__UserStoryData *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns4__ProjectData:
		((ns4__ProjectData *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns4__NoteData:
		((ns4__NoteData *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns3__DomainData:
		((ns3__DomainData *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__Map:
		((ns2__Map *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__mapItem:
		((ns2__mapItem *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__int:
		((xsd__int *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__double:
		((xsd__double *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__dateTime:
		((xsd__dateTime *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__boolean:
		((xsd__boolean *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__anyType:
		((xsd__anyType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns6__getAttributesWithPrefix:
		soap_serialize_ns6__getAttributesWithPrefix(soap, (const struct ns6__getAttributesWithPrefix *)ptr);
		break;
	case SOAP_TYPE_ns6__getAttributesWithPrefixResponse:
		soap_serialize_ns6__getAttributesWithPrefixResponse(soap, (const struct ns6__getAttributesWithPrefixResponse *)ptr);
		break;
	case SOAP_TYPE_ns6__deleteAttribute:
		soap_serialize_ns6__deleteAttribute(soap, (const struct ns6__deleteAttribute *)ptr);
		break;
	case SOAP_TYPE_ns6__deleteAttributeResponse:
		soap_serialize_ns6__deleteAttributeResponse(soap, (const struct ns6__deleteAttributeResponse *)ptr);
		break;
	case SOAP_TYPE_ns6__removePerson:
		soap_serialize_ns6__removePerson(soap, (const struct ns6__removePerson *)ptr);
		break;
	case SOAP_TYPE_ns6__removePersonResponse:
		soap_serialize_ns6__removePersonResponse(soap, (const struct ns6__removePersonResponse *)ptr);
		break;
	case SOAP_TYPE_ns6__addPerson:
		soap_serialize_ns6__addPerson(soap, (const struct ns6__addPerson *)ptr);
		break;
	case SOAP_TYPE_ns6__addPersonResponse:
		soap_serialize_ns6__addPersonResponse(soap, (const struct ns6__addPersonResponse *)ptr);
		break;
	case SOAP_TYPE_ns6__getNotesForObject:
		soap_serialize_ns6__getNotesForObject(soap, (const struct ns6__getNotesForObject *)ptr);
		break;
	case SOAP_TYPE_ns6__getNotesForObjectResponse:
		soap_serialize_ns6__getNotesForObjectResponse(soap, (const struct ns6__getNotesForObjectResponse *)ptr);
		break;
	case SOAP_TYPE_ns6__addNote:
		soap_serialize_ns6__addNote(soap, (const struct ns6__addNote *)ptr);
		break;
	case SOAP_TYPE_ns6__addNoteResponse:
		soap_serialize_ns6__addNoteResponse(soap, (const struct ns6__addNoteResponse *)ptr);
		break;
	case SOAP_TYPE_ns6__removeTimeEntry:
		soap_serialize_ns6__removeTimeEntry(soap, (const struct ns6__removeTimeEntry *)ptr);
		break;
	case SOAP_TYPE_ns6__removeTimeEntryResponse:
		soap_serialize_ns6__removeTimeEntryResponse(soap, (const struct ns6__removeTimeEntryResponse *)ptr);
		break;
	case SOAP_TYPE_ns6__addTimeEntry:
		soap_serialize_ns6__addTimeEntry(soap, (const struct ns6__addTimeEntry *)ptr);
		break;
	case SOAP_TYPE_ns6__addTimeEntryResponse:
		soap_serialize_ns6__addTimeEntryResponse(soap, (const struct ns6__addTimeEntryResponse *)ptr);
		break;
	case SOAP_TYPE_ns6__getTimeEntry:
		soap_serialize_ns6__getTimeEntry(soap, (const struct ns6__getTimeEntry *)ptr);
		break;
	case SOAP_TYPE_ns6__getTimeEntryResponse:
		soap_serialize_ns6__getTimeEntryResponse(soap, (const struct ns6__getTimeEntryResponse *)ptr);
		break;
	case SOAP_TYPE_ns6__removeTask:
		soap_serialize_ns6__removeTask(soap, (const struct ns6__removeTask *)ptr);
		break;
	case SOAP_TYPE_ns6__removeTaskResponse:
		soap_serialize_ns6__removeTaskResponse(soap, (const struct ns6__removeTaskResponse *)ptr);
		break;
	case SOAP_TYPE_ns6__getPlannedTasksForPerson:
		soap_serialize_ns6__getPlannedTasksForPerson(soap, (const struct ns6__getPlannedTasksForPerson *)ptr);
		break;
	case SOAP_TYPE_ns6__getPlannedTasksForPersonResponse:
		soap_serialize_ns6__getPlannedTasksForPersonResponse(soap, (const struct ns6__getPlannedTasksForPersonResponse *)ptr);
		break;
	case SOAP_TYPE_ns6__removeUserStory:
		soap_serialize_ns6__removeUserStory(soap, (const struct ns6__removeUserStory *)ptr);
		break;
	case SOAP_TYPE_ns6__removeUserStoryResponse:
		soap_serialize_ns6__removeUserStoryResponse(soap, (const struct ns6__removeUserStoryResponse *)ptr);
		break;
	case SOAP_TYPE_ns6__addUserStory:
		soap_serialize_ns6__addUserStory(soap, (const struct ns6__addUserStory *)ptr);
		break;
	case SOAP_TYPE_ns6__addUserStoryResponse:
		soap_serialize_ns6__addUserStoryResponse(soap, (const struct ns6__addUserStoryResponse *)ptr);
		break;
	case SOAP_TYPE_ns6__removeIteration:
		soap_serialize_ns6__removeIteration(soap, (const struct ns6__removeIteration *)ptr);
		break;
	case SOAP_TYPE_ns6__removeIterationResponse:
		soap_serialize_ns6__removeIterationResponse(soap, (const struct ns6__removeIterationResponse *)ptr);
		break;
	case SOAP_TYPE_ns6__addIteration:
		soap_serialize_ns6__addIteration(soap, (const struct ns6__addIteration *)ptr);
		break;
	case SOAP_TYPE_ns6__addIterationResponse:
		soap_serialize_ns6__addIterationResponse(soap, (const struct ns6__addIterationResponse *)ptr);
		break;
	case SOAP_TYPE_ns6__removeProject:
		soap_serialize_ns6__removeProject(soap, (const struct ns6__removeProject *)ptr);
		break;
	case SOAP_TYPE_ns6__removeProjectResponse:
		soap_serialize_ns6__removeProjectResponse(soap, (const struct ns6__removeProjectResponse *)ptr);
		break;
	case SOAP_TYPE_ns6__addProject:
		soap_serialize_ns6__addProject(soap, (const struct ns6__addProject *)ptr);
		break;
	case SOAP_TYPE_ns6__addProjectResponse:
		soap_serialize_ns6__addProjectResponse(soap, (const struct ns6__addProjectResponse *)ptr);
		break;
	case SOAP_TYPE_ns6__getProjects:
		soap_serialize_ns6__getProjects(soap, (const struct ns6__getProjects *)ptr);
		break;
	case SOAP_TYPE_ns6__getProjectsResponse:
		soap_serialize_ns6__getProjectsResponse(soap, (const struct ns6__getProjectsResponse *)ptr);
		break;
	case SOAP_TYPE_ns6__getUserStory:
		soap_serialize_ns6__getUserStory(soap, (const struct ns6__getUserStory *)ptr);
		break;
	case SOAP_TYPE_ns6__getUserStoryResponse:
		soap_serialize_ns6__getUserStoryResponse(soap, (const struct ns6__getUserStoryResponse *)ptr);
		break;
	case SOAP_TYPE_ns6__getTask:
		soap_serialize_ns6__getTask(soap, (const struct ns6__getTask *)ptr);
		break;
	case SOAP_TYPE_ns6__getTaskResponse:
		soap_serialize_ns6__getTaskResponse(soap, (const struct ns6__getTaskResponse *)ptr);
		break;
	case SOAP_TYPE_ns6__getIteration:
		soap_serialize_ns6__getIteration(soap, (const struct ns6__getIteration *)ptr);
		break;
	case SOAP_TYPE_ns6__getIterationResponse:
		soap_serialize_ns6__getIterationResponse(soap, (const struct ns6__getIterationResponse *)ptr);
		break;
	case SOAP_TYPE_ns6__getProject:
		soap_serialize_ns6__getProject(soap, (const struct ns6__getProject *)ptr);
		break;
	case SOAP_TYPE_ns6__getProjectResponse:
		soap_serialize_ns6__getProjectResponse(soap, (const struct ns6__getProjectResponse *)ptr);
		break;
	case SOAP_TYPE_ns6__getPeople:
		soap_serialize_ns6__getPeople(soap, (const struct ns6__getPeople *)ptr);
		break;
	case SOAP_TYPE_ns6__getPeopleResponse:
		soap_serialize_ns6__getPeopleResponse(soap, (const struct ns6__getPeopleResponse *)ptr);
		break;
	case SOAP_TYPE_ns6__addTask:
		soap_serialize_ns6__addTask(soap, (const struct ns6__addTask *)ptr);
		break;
	case SOAP_TYPE_ns6__addTaskResponse:
		soap_serialize_ns6__addTaskResponse(soap, (const struct ns6__addTaskResponse *)ptr);
		break;
	case SOAP_TYPE_ns6__getCurrentTasksForPerson:
		soap_serialize_ns6__getCurrentTasksForPerson(soap, (const struct ns6__getCurrentTasksForPerson *)ptr);
		break;
	case SOAP_TYPE_ns6__getCurrentTasksForPersonResponse:
		soap_serialize_ns6__getCurrentTasksForPersonResponse(soap, (const struct ns6__getCurrentTasksForPersonResponse *)ptr);
		break;
	case SOAP_TYPE_ns6__getTimeEntries:
		soap_serialize_ns6__getTimeEntries(soap, (const struct ns6__getTimeEntries *)ptr);
		break;
	case SOAP_TYPE_ns6__getTimeEntriesResponse:
		soap_serialize_ns6__getTimeEntriesResponse(soap, (const struct ns6__getTimeEntriesResponse *)ptr);
		break;
	case SOAP_TYPE_ns6__getTasks:
		soap_serialize_ns6__getTasks(soap, (const struct ns6__getTasks *)ptr);
		break;
	case SOAP_TYPE_ns6__getTasksResponse:
		soap_serialize_ns6__getTasksResponse(soap, (const struct ns6__getTasksResponse *)ptr);
		break;
	case SOAP_TYPE_ns6__getUserStories:
		soap_serialize_ns6__getUserStories(soap, (const struct ns6__getUserStories *)ptr);
		break;
	case SOAP_TYPE_ns6__getUserStoriesResponse:
		soap_serialize_ns6__getUserStoriesResponse(soap, (const struct ns6__getUserStoriesResponse *)ptr);
		break;
	case SOAP_TYPE_ns6__getCurrentIteration:
		soap_serialize_ns6__getCurrentIteration(soap, (const struct ns6__getCurrentIteration *)ptr);
		break;
	case SOAP_TYPE_ns6__getCurrentIterationResponse:
		soap_serialize_ns6__getCurrentIterationResponse(soap, (const struct ns6__getCurrentIterationResponse *)ptr);
		break;
	case SOAP_TYPE_ns6__getIterations:
		soap_serialize_ns6__getIterations(soap, (const struct ns6__getIterations *)ptr);
		break;
	case SOAP_TYPE_ns6__getIterationsResponse:
		soap_serialize_ns6__getIterationsResponse(soap, (const struct ns6__getIterationsResponse *)ptr);
		break;
	case SOAP_TYPE_ns6__getPerson:
		soap_serialize_ns6__getPerson(soap, (const struct ns6__getPerson *)ptr);
		break;
	case SOAP_TYPE_ns6__getPersonResponse:
		soap_serialize_ns6__getPersonResponse(soap, (const struct ns6__getPersonResponse *)ptr);
		break;
	case SOAP_TYPE_ns6__removeNote:
		soap_serialize_ns6__removeNote(soap, (const struct ns6__removeNote *)ptr);
		break;
	case SOAP_TYPE_ns6__removeNoteResponse:
		soap_serialize_ns6__removeNoteResponse(soap, (const struct ns6__removeNoteResponse *)ptr);
		break;
	case SOAP_TYPE_ns6__getNote:
		soap_serialize_ns6__getNote(soap, (const struct ns6__getNote *)ptr);
		break;
	case SOAP_TYPE_ns6__getNoteResponse:
		soap_serialize_ns6__getNoteResponse(soap, (const struct ns6__getNoteResponse *)ptr);
		break;
	case SOAP_TYPE_ns6__setAttribute:
		soap_serialize_ns6__setAttribute(soap, (const struct ns6__setAttribute *)ptr);
		break;
	case SOAP_TYPE_ns6__setAttributeResponse:
		soap_serialize_ns6__setAttributeResponse(soap, (const struct ns6__setAttributeResponse *)ptr);
		break;
	case SOAP_TYPE_ns6__getAttribute:
		soap_serialize_ns6__getAttribute(soap, (const struct ns6__getAttribute *)ptr);
		break;
	case SOAP_TYPE_ns6__getAttributeResponse:
		soap_serialize_ns6__getAttributeResponse(soap, (const struct ns6__getAttributeResponse *)ptr);
		break;
	case SOAP_TYPE_ns6__update______:
		soap_serialize_ns6__update______(soap, (const struct ns6__update______ *)ptr);
		break;
	case SOAP_TYPE_ns6__updateResponse______:
		soap_serialize_ns6__updateResponse______(soap, (const struct ns6__updateResponse______ *)ptr);
		break;
	case SOAP_TYPE_ns6__update_____:
		soap_serialize_ns6__update_____(soap, (const struct ns6__update_____ *)ptr);
		break;
	case SOAP_TYPE_ns6__updateResponse_____:
		soap_serialize_ns6__updateResponse_____(soap, (const struct ns6__updateResponse_____ *)ptr);
		break;
	case SOAP_TYPE_ns6__update____:
		soap_serialize_ns6__update____(soap, (const struct ns6__update____ *)ptr);
		break;
	case SOAP_TYPE_ns6__updateResponse____:
		soap_serialize_ns6__updateResponse____(soap, (const struct ns6__updateResponse____ *)ptr);
		break;
	case SOAP_TYPE_ns6__update___:
		soap_serialize_ns6__update___(soap, (const struct ns6__update___ *)ptr);
		break;
	case SOAP_TYPE_ns6__updateResponse___:
		soap_serialize_ns6__updateResponse___(soap, (const struct ns6__updateResponse___ *)ptr);
		break;
	case SOAP_TYPE_ns6__update__:
		soap_serialize_ns6__update__(soap, (const struct ns6__update__ *)ptr);
		break;
	case SOAP_TYPE_ns6__updateResponse__:
		soap_serialize_ns6__updateResponse__(soap, (const struct ns6__updateResponse__ *)ptr);
		break;
	case SOAP_TYPE_ns6__update_:
		soap_serialize_ns6__update_(soap, (const struct ns6__update_ *)ptr);
		break;
	case SOAP_TYPE_ns6__updateResponse_:
		soap_serialize_ns6__updateResponse_(soap, (const struct ns6__updateResponse_ *)ptr);
		break;
	case SOAP_TYPE_ns6__update:
		soap_serialize_ns6__update(soap, (const struct ns6__update *)ptr);
		break;
	case SOAP_TYPE_ns6__updateResponse:
		soap_serialize_ns6__updateResponse(soap, (const struct ns6__updateResponse *)ptr);
		break;
	case SOAP_TYPE_ns6__getAttributes:
		soap_serialize_ns6__getAttributes(soap, (const struct ns6__getAttributes *)ptr);
		break;
	case SOAP_TYPE_ns6__getAttributesResponse:
		soap_serialize_ns6__getAttributesResponse(soap, (const struct ns6__getAttributesResponse *)ptr);
		break;
	case SOAP_TYPE_PointerToArrayOf_USCOREtns1_USCORENoteData:
		soap_serialize_PointerToArrayOf_USCOREtns1_USCORENoteData(soap, (ArrayOf_USCOREtns1_USCORENoteData *const*)ptr);
		break;
	case SOAP_TYPE_PointerToArrayOf_USCOREtns1_USCOREProjectData:
		soap_serialize_PointerToArrayOf_USCOREtns1_USCOREProjectData(soap, (ArrayOf_USCOREtns1_USCOREProjectData *const*)ptr);
		break;
	case SOAP_TYPE_PointerToArrayOf_USCOREtns1_USCOREPersonData:
		soap_serialize_PointerToArrayOf_USCOREtns1_USCOREPersonData(soap, (ArrayOf_USCOREtns1_USCOREPersonData *const*)ptr);
		break;
	case SOAP_TYPE_PointerToArrayOf_USCOREtns1_USCORETimeEntryData:
		soap_serialize_PointerToArrayOf_USCOREtns1_USCORETimeEntryData(soap, (ArrayOf_USCOREtns1_USCORETimeEntryData *const*)ptr);
		break;
	case SOAP_TYPE_PointerToArrayOf_USCOREtns1_USCORETaskData:
		soap_serialize_PointerToArrayOf_USCOREtns1_USCORETaskData(soap, (ArrayOf_USCOREtns1_USCORETaskData *const*)ptr);
		break;
	case SOAP_TYPE_PointerToArrayOf_USCOREtns1_USCOREUserStoryData:
		soap_serialize_PointerToArrayOf_USCOREtns1_USCOREUserStoryData(soap, (ArrayOf_USCOREtns1_USCOREUserStoryData *const*)ptr);
		break;
	case SOAP_TYPE_PointerToArrayOf_USCOREtns1_USCOREIterationData:
		soap_serialize_PointerToArrayOf_USCOREtns1_USCOREIterationData(soap, (ArrayOf_USCOREtns1_USCOREIterationData *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__Map:
		soap_serialize_PointerTons2__Map(soap, (ns2__Map *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__QueryException:
		soap_serialize_PointerTo_ns1__QueryException(soap, (_ns1__QueryException *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons5__QueryException:
		soap_serialize_PointerTons5__QueryException(soap, (ns5__QueryException *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons4__NoteData:
		soap_serialize_PointerToPointerTons4__NoteData(soap, (ns4__NoteData **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__NoteData:
		soap_serialize_PointerTons4__NoteData(soap, (ns4__NoteData *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons4__ProjectData:
		soap_serialize_PointerToPointerTons4__ProjectData(soap, (ns4__ProjectData **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__ProjectData:
		soap_serialize_PointerTons4__ProjectData(soap, (ns4__ProjectData *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons4__PersonData:
		soap_serialize_PointerToPointerTons4__PersonData(soap, (ns4__PersonData **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__PersonData:
		soap_serialize_PointerTons4__PersonData(soap, (ns4__PersonData *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons4__TimeEntryData:
		soap_serialize_PointerToPointerTons4__TimeEntryData(soap, (ns4__TimeEntryData **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__TimeEntryData:
		soap_serialize_PointerTons4__TimeEntryData(soap, (ns4__TimeEntryData *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons4__TaskData:
		soap_serialize_PointerToPointerTons4__TaskData(soap, (ns4__TaskData **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__TaskData:
		soap_serialize_PointerTons4__TaskData(soap, (ns4__TaskData *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons4__UserStoryData:
		soap_serialize_PointerToPointerTons4__UserStoryData(soap, (ns4__UserStoryData **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__UserStoryData:
		soap_serialize_PointerTons4__UserStoryData(soap, (ns4__UserStoryData *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons4__IterationData:
		soap_serialize_PointerToPointerTons4__IterationData(soap, (ns4__IterationData **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons4__IterationData:
		soap_serialize_PointerTons4__IterationData(soap, (ns4__IterationData *const*)ptr);
		break;
	case SOAP_TYPE_PointerTotime:
		soap_serialize_PointerTotime(soap, (time_t *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons2__mapItem:
		soap_serialize_PointerToPointerTons2__mapItem(soap, (ns2__mapItem **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__mapItem:
		soap_serialize_PointerTons2__mapItem(soap, (ns2__mapItem *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__anyType:
		soap_serialize_PointerToxsd__anyType(soap, (xsd__anyType *const*)ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	}
}

#ifdef __cplusplus
}
#endif
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
{
	switch (t)
	{
	case SOAP_TYPE_xsd__anyType:
		return (void*)soap_instantiate_xsd__anyType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__boolean:
		return (void*)soap_instantiate_xsd__boolean(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__dateTime:
		return (void*)soap_instantiate_xsd__dateTime(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__double:
		return (void*)soap_instantiate_xsd__double(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__int:
		return (void*)soap_instantiate_xsd__int(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__mapItem:
		return (void*)soap_instantiate_ns2__mapItem(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__Map:
		return (void*)soap_instantiate_ns2__Map(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns3__DomainData:
		return (void*)soap_instantiate_ns3__DomainData(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns5__QueryException:
		return (void*)soap_instantiate_ns5__QueryException(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__NoteData:
		return (void*)soap_instantiate_ns4__NoteData(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__ProjectData:
		return (void*)soap_instantiate_ns4__ProjectData(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__UserStoryData:
		return (void*)soap_instantiate_ns4__UserStoryData(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__PersonData:
		return (void*)soap_instantiate_ns4__PersonData(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__TimeEntryData:
		return (void*)soap_instantiate_ns4__TimeEntryData(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__TaskData:
		return (void*)soap_instantiate_ns4__TaskData(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns4__IterationData:
		return (void*)soap_instantiate_ns4__IterationData(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ArrayOf_USCOREtns1_USCOREIterationData:
		return (void*)soap_instantiate_ArrayOf_USCOREtns1_USCOREIterationData(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ArrayOf_USCOREtns1_USCOREUserStoryData:
		return (void*)soap_instantiate_ArrayOf_USCOREtns1_USCOREUserStoryData(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ArrayOf_USCOREtns1_USCORETaskData:
		return (void*)soap_instantiate_ArrayOf_USCOREtns1_USCORETaskData(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ArrayOf_USCOREtns1_USCORETimeEntryData:
		return (void*)soap_instantiate_ArrayOf_USCOREtns1_USCORETimeEntryData(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ArrayOf_USCOREtns1_USCOREPersonData:
		return (void*)soap_instantiate_ArrayOf_USCOREtns1_USCOREPersonData(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ArrayOf_USCOREtns1_USCOREProjectData:
		return (void*)soap_instantiate_ArrayOf_USCOREtns1_USCOREProjectData(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ArrayOf_USCOREtns1_USCORENoteData:
		return (void*)soap_instantiate_ArrayOf_USCOREtns1_USCORENoteData(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__QueryException:
		return (void*)soap_instantiate__ns1__QueryException(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		return (void*)soap_instantiate_SOAP_ENV__Detail(soap, -1, type, arrayType, n);
#endif
	case SOAP_TYPE_ns6__getAttributesResponse:
		return (void*)soap_instantiate_ns6__getAttributesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__getAttributes:
		return (void*)soap_instantiate_ns6__getAttributes(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__updateResponse:
		return (void*)soap_instantiate_ns6__updateResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__update:
		return (void*)soap_instantiate_ns6__update(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__updateResponse_:
		return (void*)soap_instantiate_ns6__updateResponse_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__update_:
		return (void*)soap_instantiate_ns6__update_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__updateResponse__:
		return (void*)soap_instantiate_ns6__updateResponse__(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__update__:
		return (void*)soap_instantiate_ns6__update__(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__updateResponse___:
		return (void*)soap_instantiate_ns6__updateResponse___(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__update___:
		return (void*)soap_instantiate_ns6__update___(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__updateResponse____:
		return (void*)soap_instantiate_ns6__updateResponse____(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__update____:
		return (void*)soap_instantiate_ns6__update____(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__updateResponse_____:
		return (void*)soap_instantiate_ns6__updateResponse_____(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__update_____:
		return (void*)soap_instantiate_ns6__update_____(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__updateResponse______:
		return (void*)soap_instantiate_ns6__updateResponse______(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__update______:
		return (void*)soap_instantiate_ns6__update______(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__getAttributeResponse:
		return (void*)soap_instantiate_ns6__getAttributeResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__getAttribute:
		return (void*)soap_instantiate_ns6__getAttribute(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__setAttributeResponse:
		return (void*)soap_instantiate_ns6__setAttributeResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__setAttribute:
		return (void*)soap_instantiate_ns6__setAttribute(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__getNoteResponse:
		return (void*)soap_instantiate_ns6__getNoteResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__getNote:
		return (void*)soap_instantiate_ns6__getNote(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__removeNoteResponse:
		return (void*)soap_instantiate_ns6__removeNoteResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__removeNote:
		return (void*)soap_instantiate_ns6__removeNote(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__getPersonResponse:
		return (void*)soap_instantiate_ns6__getPersonResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__getPerson:
		return (void*)soap_instantiate_ns6__getPerson(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__getIterationsResponse:
		return (void*)soap_instantiate_ns6__getIterationsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__getIterations:
		return (void*)soap_instantiate_ns6__getIterations(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__getCurrentIterationResponse:
		return (void*)soap_instantiate_ns6__getCurrentIterationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__getCurrentIteration:
		return (void*)soap_instantiate_ns6__getCurrentIteration(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__getUserStoriesResponse:
		return (void*)soap_instantiate_ns6__getUserStoriesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__getUserStories:
		return (void*)soap_instantiate_ns6__getUserStories(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__getTasksResponse:
		return (void*)soap_instantiate_ns6__getTasksResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__getTasks:
		return (void*)soap_instantiate_ns6__getTasks(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__getTimeEntriesResponse:
		return (void*)soap_instantiate_ns6__getTimeEntriesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__getTimeEntries:
		return (void*)soap_instantiate_ns6__getTimeEntries(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__getCurrentTasksForPersonResponse:
		return (void*)soap_instantiate_ns6__getCurrentTasksForPersonResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__getCurrentTasksForPerson:
		return (void*)soap_instantiate_ns6__getCurrentTasksForPerson(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__addTaskResponse:
		return (void*)soap_instantiate_ns6__addTaskResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__addTask:
		return (void*)soap_instantiate_ns6__addTask(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__getPeopleResponse:
		return (void*)soap_instantiate_ns6__getPeopleResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__getPeople:
		return (void*)soap_instantiate_ns6__getPeople(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__getProjectResponse:
		return (void*)soap_instantiate_ns6__getProjectResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__getProject:
		return (void*)soap_instantiate_ns6__getProject(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__getIterationResponse:
		return (void*)soap_instantiate_ns6__getIterationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__getIteration:
		return (void*)soap_instantiate_ns6__getIteration(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__getTaskResponse:
		return (void*)soap_instantiate_ns6__getTaskResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__getTask:
		return (void*)soap_instantiate_ns6__getTask(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__getUserStoryResponse:
		return (void*)soap_instantiate_ns6__getUserStoryResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__getUserStory:
		return (void*)soap_instantiate_ns6__getUserStory(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__getProjectsResponse:
		return (void*)soap_instantiate_ns6__getProjectsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__getProjects:
		return (void*)soap_instantiate_ns6__getProjects(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__addProjectResponse:
		return (void*)soap_instantiate_ns6__addProjectResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__addProject:
		return (void*)soap_instantiate_ns6__addProject(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__removeProjectResponse:
		return (void*)soap_instantiate_ns6__removeProjectResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__removeProject:
		return (void*)soap_instantiate_ns6__removeProject(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__addIterationResponse:
		return (void*)soap_instantiate_ns6__addIterationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__addIteration:
		return (void*)soap_instantiate_ns6__addIteration(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__removeIterationResponse:
		return (void*)soap_instantiate_ns6__removeIterationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__removeIteration:
		return (void*)soap_instantiate_ns6__removeIteration(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__addUserStoryResponse:
		return (void*)soap_instantiate_ns6__addUserStoryResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__addUserStory:
		return (void*)soap_instantiate_ns6__addUserStory(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__removeUserStoryResponse:
		return (void*)soap_instantiate_ns6__removeUserStoryResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__removeUserStory:
		return (void*)soap_instantiate_ns6__removeUserStory(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__getPlannedTasksForPersonResponse:
		return (void*)soap_instantiate_ns6__getPlannedTasksForPersonResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__getPlannedTasksForPerson:
		return (void*)soap_instantiate_ns6__getPlannedTasksForPerson(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__removeTaskResponse:
		return (void*)soap_instantiate_ns6__removeTaskResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__removeTask:
		return (void*)soap_instantiate_ns6__removeTask(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__getTimeEntryResponse:
		return (void*)soap_instantiate_ns6__getTimeEntryResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__getTimeEntry:
		return (void*)soap_instantiate_ns6__getTimeEntry(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__addTimeEntryResponse:
		return (void*)soap_instantiate_ns6__addTimeEntryResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__addTimeEntry:
		return (void*)soap_instantiate_ns6__addTimeEntry(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__removeTimeEntryResponse:
		return (void*)soap_instantiate_ns6__removeTimeEntryResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__removeTimeEntry:
		return (void*)soap_instantiate_ns6__removeTimeEntry(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__addNoteResponse:
		return (void*)soap_instantiate_ns6__addNoteResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__addNote:
		return (void*)soap_instantiate_ns6__addNote(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__getNotesForObjectResponse:
		return (void*)soap_instantiate_ns6__getNotesForObjectResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__getNotesForObject:
		return (void*)soap_instantiate_ns6__getNotesForObject(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__addPersonResponse:
		return (void*)soap_instantiate_ns6__addPersonResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__addPerson:
		return (void*)soap_instantiate_ns6__addPerson(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__removePersonResponse:
		return (void*)soap_instantiate_ns6__removePersonResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__removePerson:
		return (void*)soap_instantiate_ns6__removePerson(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__deleteAttributeResponse:
		return (void*)soap_instantiate_ns6__deleteAttributeResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__deleteAttribute:
		return (void*)soap_instantiate_ns6__deleteAttribute(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__getAttributesWithPrefixResponse:
		return (void*)soap_instantiate_ns6__getAttributesWithPrefixResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns6__getAttributesWithPrefix:
		return (void*)soap_instantiate_ns6__getAttributesWithPrefix(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		return (void*)soap_instantiate_SOAP_ENV__Header(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		return (void*)soap_instantiate_SOAP_ENV__Code(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		return (void*)soap_instantiate_SOAP_ENV__Reason(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		return (void*)soap_instantiate_SOAP_ENV__Fault(soap, -1, type, arrayType, n);
#endif
	}
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_fdelete(struct soap_clist *p)
{	switch (p->type)
	{
	case SOAP_TYPE_xsd__anyType:
		if (p->size < 0)
			delete (xsd__anyType*)p->ptr;
		else
			delete[] (xsd__anyType*)p->ptr;
		break;
	case SOAP_TYPE_xsd__boolean:
		if (p->size < 0)
			delete (xsd__boolean*)p->ptr;
		else
			delete[] (xsd__boolean*)p->ptr;
		break;
	case SOAP_TYPE_xsd__dateTime:
		if (p->size < 0)
			delete (xsd__dateTime*)p->ptr;
		else
			delete[] (xsd__dateTime*)p->ptr;
		break;
	case SOAP_TYPE_xsd__double:
		if (p->size < 0)
			delete (xsd__double*)p->ptr;
		else
			delete[] (xsd__double*)p->ptr;
		break;
	case SOAP_TYPE_xsd__int:
		if (p->size < 0)
			delete (xsd__int*)p->ptr;
		else
			delete[] (xsd__int*)p->ptr;
		break;
	case SOAP_TYPE_ns2__mapItem:
		if (p->size < 0)
			delete (ns2__mapItem*)p->ptr;
		else
			delete[] (ns2__mapItem*)p->ptr;
		break;
	case SOAP_TYPE_ns2__Map:
		if (p->size < 0)
			delete (ns2__Map*)p->ptr;
		else
			delete[] (ns2__Map*)p->ptr;
		break;
	case SOAP_TYPE_ns3__DomainData:
		if (p->size < 0)
			delete (ns3__DomainData*)p->ptr;
		else
			delete[] (ns3__DomainData*)p->ptr;
		break;
	case SOAP_TYPE_ns5__QueryException:
		if (p->size < 0)
			delete (ns5__QueryException*)p->ptr;
		else
			delete[] (ns5__QueryException*)p->ptr;
		break;
	case SOAP_TYPE_ns4__NoteData:
		if (p->size < 0)
			delete (ns4__NoteData*)p->ptr;
		else
			delete[] (ns4__NoteData*)p->ptr;
		break;
	case SOAP_TYPE_ns4__ProjectData:
		if (p->size < 0)
			delete (ns4__ProjectData*)p->ptr;
		else
			delete[] (ns4__ProjectData*)p->ptr;
		break;
	case SOAP_TYPE_ns4__UserStoryData:
		if (p->size < 0)
			delete (ns4__UserStoryData*)p->ptr;
		else
			delete[] (ns4__UserStoryData*)p->ptr;
		break;
	case SOAP_TYPE_ns4__PersonData:
		if (p->size < 0)
			delete (ns4__PersonData*)p->ptr;
		else
			delete[] (ns4__PersonData*)p->ptr;
		break;
	case SOAP_TYPE_ns4__TimeEntryData:
		if (p->size < 0)
			delete (ns4__TimeEntryData*)p->ptr;
		else
			delete[] (ns4__TimeEntryData*)p->ptr;
		break;
	case SOAP_TYPE_ns4__TaskData:
		if (p->size < 0)
			delete (ns4__TaskData*)p->ptr;
		else
			delete[] (ns4__TaskData*)p->ptr;
		break;
	case SOAP_TYPE_ns4__IterationData:
		if (p->size < 0)
			delete (ns4__IterationData*)p->ptr;
		else
			delete[] (ns4__IterationData*)p->ptr;
		break;
	case SOAP_TYPE_ArrayOf_USCOREtns1_USCOREIterationData:
		if (p->size < 0)
			delete (ArrayOf_USCOREtns1_USCOREIterationData*)p->ptr;
		else
			delete[] (ArrayOf_USCOREtns1_USCOREIterationData*)p->ptr;
		break;
	case SOAP_TYPE_ArrayOf_USCOREtns1_USCOREUserStoryData:
		if (p->size < 0)
			delete (ArrayOf_USCOREtns1_USCOREUserStoryData*)p->ptr;
		else
			delete[] (ArrayOf_USCOREtns1_USCOREUserStoryData*)p->ptr;
		break;
	case SOAP_TYPE_ArrayOf_USCOREtns1_USCORETaskData:
		if (p->size < 0)
			delete (ArrayOf_USCOREtns1_USCORETaskData*)p->ptr;
		else
			delete[] (ArrayOf_USCOREtns1_USCORETaskData*)p->ptr;
		break;
	case SOAP_TYPE_ArrayOf_USCOREtns1_USCORETimeEntryData:
		if (p->size < 0)
			delete (ArrayOf_USCOREtns1_USCORETimeEntryData*)p->ptr;
		else
			delete[] (ArrayOf_USCOREtns1_USCORETimeEntryData*)p->ptr;
		break;
	case SOAP_TYPE_ArrayOf_USCOREtns1_USCOREPersonData:
		if (p->size < 0)
			delete (ArrayOf_USCOREtns1_USCOREPersonData*)p->ptr;
		else
			delete[] (ArrayOf_USCOREtns1_USCOREPersonData*)p->ptr;
		break;
	case SOAP_TYPE_ArrayOf_USCOREtns1_USCOREProjectData:
		if (p->size < 0)
			delete (ArrayOf_USCOREtns1_USCOREProjectData*)p->ptr;
		else
			delete[] (ArrayOf_USCOREtns1_USCOREProjectData*)p->ptr;
		break;
	case SOAP_TYPE_ArrayOf_USCOREtns1_USCORENoteData:
		if (p->size < 0)
			delete (ArrayOf_USCOREtns1_USCORENoteData*)p->ptr;
		else
			delete[] (ArrayOf_USCOREtns1_USCORENoteData*)p->ptr;
		break;
	case SOAP_TYPE__ns1__QueryException:
		if (p->size < 0)
			delete (_ns1__QueryException*)p->ptr;
		else
			delete[] (_ns1__QueryException*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Detail:
		if (p->size < 0)
			delete (struct SOAP_ENV__Detail*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Detail*)p->ptr;
		break;
	case SOAP_TYPE_ns6__getAttributesResponse:
		if (p->size < 0)
			delete (struct ns6__getAttributesResponse*)p->ptr;
		else
			delete[] (struct ns6__getAttributesResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns6__getAttributes:
		if (p->size < 0)
			delete (struct ns6__getAttributes*)p->ptr;
		else
			delete[] (struct ns6__getAttributes*)p->ptr;
		break;
	case SOAP_TYPE_ns6__updateResponse:
		if (p->size < 0)
			delete (struct ns6__updateResponse*)p->ptr;
		else
			delete[] (struct ns6__updateResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns6__update:
		if (p->size < 0)
			delete (struct ns6__update*)p->ptr;
		else
			delete[] (struct ns6__update*)p->ptr;
		break;
	case SOAP_TYPE_ns6__updateResponse_:
		if (p->size < 0)
			delete (struct ns6__updateResponse_*)p->ptr;
		else
			delete[] (struct ns6__updateResponse_*)p->ptr;
		break;
	case SOAP_TYPE_ns6__update_:
		if (p->size < 0)
			delete (struct ns6__update_*)p->ptr;
		else
			delete[] (struct ns6__update_*)p->ptr;
		break;
	case SOAP_TYPE_ns6__updateResponse__:
		if (p->size < 0)
			delete (struct ns6__updateResponse__*)p->ptr;
		else
			delete[] (struct ns6__updateResponse__*)p->ptr;
		break;
	case SOAP_TYPE_ns6__update__:
		if (p->size < 0)
			delete (struct ns6__update__*)p->ptr;
		else
			delete[] (struct ns6__update__*)p->ptr;
		break;
	case SOAP_TYPE_ns6__updateResponse___:
		if (p->size < 0)
			delete (struct ns6__updateResponse___*)p->ptr;
		else
			delete[] (struct ns6__updateResponse___*)p->ptr;
		break;
	case SOAP_TYPE_ns6__update___:
		if (p->size < 0)
			delete (struct ns6__update___*)p->ptr;
		else
			delete[] (struct ns6__update___*)p->ptr;
		break;
	case SOAP_TYPE_ns6__updateResponse____:
		if (p->size < 0)
			delete (struct ns6__updateResponse____*)p->ptr;
		else
			delete[] (struct ns6__updateResponse____*)p->ptr;
		break;
	case SOAP_TYPE_ns6__update____:
		if (p->size < 0)
			delete (struct ns6__update____*)p->ptr;
		else
			delete[] (struct ns6__update____*)p->ptr;
		break;
	case SOAP_TYPE_ns6__updateResponse_____:
		if (p->size < 0)
			delete (struct ns6__updateResponse_____*)p->ptr;
		else
			delete[] (struct ns6__updateResponse_____*)p->ptr;
		break;
	case SOAP_TYPE_ns6__update_____:
		if (p->size < 0)
			delete (struct ns6__update_____*)p->ptr;
		else
			delete[] (struct ns6__update_____*)p->ptr;
		break;
	case SOAP_TYPE_ns6__updateResponse______:
		if (p->size < 0)
			delete (struct ns6__updateResponse______*)p->ptr;
		else
			delete[] (struct ns6__updateResponse______*)p->ptr;
		break;
	case SOAP_TYPE_ns6__update______:
		if (p->size < 0)
			delete (struct ns6__update______*)p->ptr;
		else
			delete[] (struct ns6__update______*)p->ptr;
		break;
	case SOAP_TYPE_ns6__getAttributeResponse:
		if (p->size < 0)
			delete (struct ns6__getAttributeResponse*)p->ptr;
		else
			delete[] (struct ns6__getAttributeResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns6__getAttribute:
		if (p->size < 0)
			delete (struct ns6__getAttribute*)p->ptr;
		else
			delete[] (struct ns6__getAttribute*)p->ptr;
		break;
	case SOAP_TYPE_ns6__setAttributeResponse:
		if (p->size < 0)
			delete (struct ns6__setAttributeResponse*)p->ptr;
		else
			delete[] (struct ns6__setAttributeResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns6__setAttribute:
		if (p->size < 0)
			delete (struct ns6__setAttribute*)p->ptr;
		else
			delete[] (struct ns6__setAttribute*)p->ptr;
		break;
	case SOAP_TYPE_ns6__getNoteResponse:
		if (p->size < 0)
			delete (struct ns6__getNoteResponse*)p->ptr;
		else
			delete[] (struct ns6__getNoteResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns6__getNote:
		if (p->size < 0)
			delete (struct ns6__getNote*)p->ptr;
		else
			delete[] (struct ns6__getNote*)p->ptr;
		break;
	case SOAP_TYPE_ns6__removeNoteResponse:
		if (p->size < 0)
			delete (struct ns6__removeNoteResponse*)p->ptr;
		else
			delete[] (struct ns6__removeNoteResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns6__removeNote:
		if (p->size < 0)
			delete (struct ns6__removeNote*)p->ptr;
		else
			delete[] (struct ns6__removeNote*)p->ptr;
		break;
	case SOAP_TYPE_ns6__getPersonResponse:
		if (p->size < 0)
			delete (struct ns6__getPersonResponse*)p->ptr;
		else
			delete[] (struct ns6__getPersonResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns6__getPerson:
		if (p->size < 0)
			delete (struct ns6__getPerson*)p->ptr;
		else
			delete[] (struct ns6__getPerson*)p->ptr;
		break;
	case SOAP_TYPE_ns6__getIterationsResponse:
		if (p->size < 0)
			delete (struct ns6__getIterationsResponse*)p->ptr;
		else
			delete[] (struct ns6__getIterationsResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns6__getIterations:
		if (p->size < 0)
			delete (struct ns6__getIterations*)p->ptr;
		else
			delete[] (struct ns6__getIterations*)p->ptr;
		break;
	case SOAP_TYPE_ns6__getCurrentIterationResponse:
		if (p->size < 0)
			delete (struct ns6__getCurrentIterationResponse*)p->ptr;
		else
			delete[] (struct ns6__getCurrentIterationResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns6__getCurrentIteration:
		if (p->size < 0)
			delete (struct ns6__getCurrentIteration*)p->ptr;
		else
			delete[] (struct ns6__getCurrentIteration*)p->ptr;
		break;
	case SOAP_TYPE_ns6__getUserStoriesResponse:
		if (p->size < 0)
			delete (struct ns6__getUserStoriesResponse*)p->ptr;
		else
			delete[] (struct ns6__getUserStoriesResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns6__getUserStories:
		if (p->size < 0)
			delete (struct ns6__getUserStories*)p->ptr;
		else
			delete[] (struct ns6__getUserStories*)p->ptr;
		break;
	case SOAP_TYPE_ns6__getTasksResponse:
		if (p->size < 0)
			delete (struct ns6__getTasksResponse*)p->ptr;
		else
			delete[] (struct ns6__getTasksResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns6__getTasks:
		if (p->size < 0)
			delete (struct ns6__getTasks*)p->ptr;
		else
			delete[] (struct ns6__getTasks*)p->ptr;
		break;
	case SOAP_TYPE_ns6__getTimeEntriesResponse:
		if (p->size < 0)
			delete (struct ns6__getTimeEntriesResponse*)p->ptr;
		else
			delete[] (struct ns6__getTimeEntriesResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns6__getTimeEntries:
		if (p->size < 0)
			delete (struct ns6__getTimeEntries*)p->ptr;
		else
			delete[] (struct ns6__getTimeEntries*)p->ptr;
		break;
	case SOAP_TYPE_ns6__getCurrentTasksForPersonResponse:
		if (p->size < 0)
			delete (struct ns6__getCurrentTasksForPersonResponse*)p->ptr;
		else
			delete[] (struct ns6__getCurrentTasksForPersonResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns6__getCurrentTasksForPerson:
		if (p->size < 0)
			delete (struct ns6__getCurrentTasksForPerson*)p->ptr;
		else
			delete[] (struct ns6__getCurrentTasksForPerson*)p->ptr;
		break;
	case SOAP_TYPE_ns6__addTaskResponse:
		if (p->size < 0)
			delete (struct ns6__addTaskResponse*)p->ptr;
		else
			delete[] (struct ns6__addTaskResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns6__addTask:
		if (p->size < 0)
			delete (struct ns6__addTask*)p->ptr;
		else
			delete[] (struct ns6__addTask*)p->ptr;
		break;
	case SOAP_TYPE_ns6__getPeopleResponse:
		if (p->size < 0)
			delete (struct ns6__getPeopleResponse*)p->ptr;
		else
			delete[] (struct ns6__getPeopleResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns6__getPeople:
		if (p->size < 0)
			delete (struct ns6__getPeople*)p->ptr;
		else
			delete[] (struct ns6__getPeople*)p->ptr;
		break;
	case SOAP_TYPE_ns6__getProjectResponse:
		if (p->size < 0)
			delete (struct ns6__getProjectResponse*)p->ptr;
		else
			delete[] (struct ns6__getProjectResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns6__getProject:
		if (p->size < 0)
			delete (struct ns6__getProject*)p->ptr;
		else
			delete[] (struct ns6__getProject*)p->ptr;
		break;
	case SOAP_TYPE_ns6__getIterationResponse:
		if (p->size < 0)
			delete (struct ns6__getIterationResponse*)p->ptr;
		else
			delete[] (struct ns6__getIterationResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns6__getIteration:
		if (p->size < 0)
			delete (struct ns6__getIteration*)p->ptr;
		else
			delete[] (struct ns6__getIteration*)p->ptr;
		break;
	case SOAP_TYPE_ns6__getTaskResponse:
		if (p->size < 0)
			delete (struct ns6__getTaskResponse*)p->ptr;
		else
			delete[] (struct ns6__getTaskResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns6__getTask:
		if (p->size < 0)
			delete (struct ns6__getTask*)p->ptr;
		else
			delete[] (struct ns6__getTask*)p->ptr;
		break;
	case SOAP_TYPE_ns6__getUserStoryResponse:
		if (p->size < 0)
			delete (struct ns6__getUserStoryResponse*)p->ptr;
		else
			delete[] (struct ns6__getUserStoryResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns6__getUserStory:
		if (p->size < 0)
			delete (struct ns6__getUserStory*)p->ptr;
		else
			delete[] (struct ns6__getUserStory*)p->ptr;
		break;
	case SOAP_TYPE_ns6__getProjectsResponse:
		if (p->size < 0)
			delete (struct ns6__getProjectsResponse*)p->ptr;
		else
			delete[] (struct ns6__getProjectsResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns6__getProjects:
		if (p->size < 0)
			delete (struct ns6__getProjects*)p->ptr;
		else
			delete[] (struct ns6__getProjects*)p->ptr;
		break;
	case SOAP_TYPE_ns6__addProjectResponse:
		if (p->size < 0)
			delete (struct ns6__addProjectResponse*)p->ptr;
		else
			delete[] (struct ns6__addProjectResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns6__addProject:
		if (p->size < 0)
			delete (struct ns6__addProject*)p->ptr;
		else
			delete[] (struct ns6__addProject*)p->ptr;
		break;
	case SOAP_TYPE_ns6__removeProjectResponse:
		if (p->size < 0)
			delete (struct ns6__removeProjectResponse*)p->ptr;
		else
			delete[] (struct ns6__removeProjectResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns6__removeProject:
		if (p->size < 0)
			delete (struct ns6__removeProject*)p->ptr;
		else
			delete[] (struct ns6__removeProject*)p->ptr;
		break;
	case SOAP_TYPE_ns6__addIterationResponse:
		if (p->size < 0)
			delete (struct ns6__addIterationResponse*)p->ptr;
		else
			delete[] (struct ns6__addIterationResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns6__addIteration:
		if (p->size < 0)
			delete (struct ns6__addIteration*)p->ptr;
		else
			delete[] (struct ns6__addIteration*)p->ptr;
		break;
	case SOAP_TYPE_ns6__removeIterationResponse:
		if (p->size < 0)
			delete (struct ns6__removeIterationResponse*)p->ptr;
		else
			delete[] (struct ns6__removeIterationResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns6__removeIteration:
		if (p->size < 0)
			delete (struct ns6__removeIteration*)p->ptr;
		else
			delete[] (struct ns6__removeIteration*)p->ptr;
		break;
	case SOAP_TYPE_ns6__addUserStoryResponse:
		if (p->size < 0)
			delete (struct ns6__addUserStoryResponse*)p->ptr;
		else
			delete[] (struct ns6__addUserStoryResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns6__addUserStory:
		if (p->size < 0)
			delete (struct ns6__addUserStory*)p->ptr;
		else
			delete[] (struct ns6__addUserStory*)p->ptr;
		break;
	case SOAP_TYPE_ns6__removeUserStoryResponse:
		if (p->size < 0)
			delete (struct ns6__removeUserStoryResponse*)p->ptr;
		else
			delete[] (struct ns6__removeUserStoryResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns6__removeUserStory:
		if (p->size < 0)
			delete (struct ns6__removeUserStory*)p->ptr;
		else
			delete[] (struct ns6__removeUserStory*)p->ptr;
		break;
	case SOAP_TYPE_ns6__getPlannedTasksForPersonResponse:
		if (p->size < 0)
			delete (struct ns6__getPlannedTasksForPersonResponse*)p->ptr;
		else
			delete[] (struct ns6__getPlannedTasksForPersonResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns6__getPlannedTasksForPerson:
		if (p->size < 0)
			delete (struct ns6__getPlannedTasksForPerson*)p->ptr;
		else
			delete[] (struct ns6__getPlannedTasksForPerson*)p->ptr;
		break;
	case SOAP_TYPE_ns6__removeTaskResponse:
		if (p->size < 0)
			delete (struct ns6__removeTaskResponse*)p->ptr;
		else
			delete[] (struct ns6__removeTaskResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns6__removeTask:
		if (p->size < 0)
			delete (struct ns6__removeTask*)p->ptr;
		else
			delete[] (struct ns6__removeTask*)p->ptr;
		break;
	case SOAP_TYPE_ns6__getTimeEntryResponse:
		if (p->size < 0)
			delete (struct ns6__getTimeEntryResponse*)p->ptr;
		else
			delete[] (struct ns6__getTimeEntryResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns6__getTimeEntry:
		if (p->size < 0)
			delete (struct ns6__getTimeEntry*)p->ptr;
		else
			delete[] (struct ns6__getTimeEntry*)p->ptr;
		break;
	case SOAP_TYPE_ns6__addTimeEntryResponse:
		if (p->size < 0)
			delete (struct ns6__addTimeEntryResponse*)p->ptr;
		else
			delete[] (struct ns6__addTimeEntryResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns6__addTimeEntry:
		if (p->size < 0)
			delete (struct ns6__addTimeEntry*)p->ptr;
		else
			delete[] (struct ns6__addTimeEntry*)p->ptr;
		break;
	case SOAP_TYPE_ns6__removeTimeEntryResponse:
		if (p->size < 0)
			delete (struct ns6__removeTimeEntryResponse*)p->ptr;
		else
			delete[] (struct ns6__removeTimeEntryResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns6__removeTimeEntry:
		if (p->size < 0)
			delete (struct ns6__removeTimeEntry*)p->ptr;
		else
			delete[] (struct ns6__removeTimeEntry*)p->ptr;
		break;
	case SOAP_TYPE_ns6__addNoteResponse:
		if (p->size < 0)
			delete (struct ns6__addNoteResponse*)p->ptr;
		else
			delete[] (struct ns6__addNoteResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns6__addNote:
		if (p->size < 0)
			delete (struct ns6__addNote*)p->ptr;
		else
			delete[] (struct ns6__addNote*)p->ptr;
		break;
	case SOAP_TYPE_ns6__getNotesForObjectResponse:
		if (p->size < 0)
			delete (struct ns6__getNotesForObjectResponse*)p->ptr;
		else
			delete[] (struct ns6__getNotesForObjectResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns6__getNotesForObject:
		if (p->size < 0)
			delete (struct ns6__getNotesForObject*)p->ptr;
		else
			delete[] (struct ns6__getNotesForObject*)p->ptr;
		break;
	case SOAP_TYPE_ns6__addPersonResponse:
		if (p->size < 0)
			delete (struct ns6__addPersonResponse*)p->ptr;
		else
			delete[] (struct ns6__addPersonResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns6__addPerson:
		if (p->size < 0)
			delete (struct ns6__addPerson*)p->ptr;
		else
			delete[] (struct ns6__addPerson*)p->ptr;
		break;
	case SOAP_TYPE_ns6__removePersonResponse:
		if (p->size < 0)
			delete (struct ns6__removePersonResponse*)p->ptr;
		else
			delete[] (struct ns6__removePersonResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns6__removePerson:
		if (p->size < 0)
			delete (struct ns6__removePerson*)p->ptr;
		else
			delete[] (struct ns6__removePerson*)p->ptr;
		break;
	case SOAP_TYPE_ns6__deleteAttributeResponse:
		if (p->size < 0)
			delete (struct ns6__deleteAttributeResponse*)p->ptr;
		else
			delete[] (struct ns6__deleteAttributeResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns6__deleteAttribute:
		if (p->size < 0)
			delete (struct ns6__deleteAttribute*)p->ptr;
		else
			delete[] (struct ns6__deleteAttribute*)p->ptr;
		break;
	case SOAP_TYPE_ns6__getAttributesWithPrefixResponse:
		if (p->size < 0)
			delete (struct ns6__getAttributesWithPrefixResponse*)p->ptr;
		else
			delete[] (struct ns6__getAttributesWithPrefixResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns6__getAttributesWithPrefix:
		if (p->size < 0)
			delete (struct ns6__getAttributesWithPrefix*)p->ptr;
		else
			delete[] (struct ns6__getAttributesWithPrefix*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Header:
		if (p->size < 0)
			delete (struct SOAP_ENV__Header*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Header*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Code:
		if (p->size < 0)
			delete (struct SOAP_ENV__Code*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Code*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Reason:
		if (p->size < 0)
			delete (struct SOAP_ENV__Reason*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Reason*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Fault:
		if (p->size < 0)
			delete (struct SOAP_ENV__Fault*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Fault*)p->ptr;
		break;
	default:	return SOAP_ERR;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_class_id_enter(struct soap *soap, const char *id, void *p, int t, size_t n, const char *type, const char *arrayType)
{	return soap_id_enter(soap, id, p, t, n, 0, type, arrayType, soap_instantiate);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap *soap, char *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_byte
	*a = SOAP_DEFAULT_byte;
#else
	*a = (char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_byte);
	if (soap_out_byte(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{
	return soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap *soap, int *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_int
	*a = SOAP_DEFAULT_int;
#else
	*a = (int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_int);
	if (soap_out_int(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{
	return soap_inint(soap, tag, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_double(struct soap *soap, double *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_double
	*a = SOAP_DEFAULT_double;
#else
	*a = (double)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_double(struct soap *soap, const double *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_double);
	if (soap_out_double(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_double(struct soap *soap, const char *tag, int id, const double *a, const char *type)
{
	return soap_outdouble(soap, tag, id, a, type, SOAP_TYPE_double);
}

SOAP_FMAC3 double * SOAP_FMAC4 soap_get_double(struct soap *soap, double *p, const char *tag, const char *type)
{
	if ((p = soap_in_double(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 double * SOAP_FMAC4 soap_in_double(struct soap *soap, const char *tag, double *a, const char *type)
{
	return soap_indouble(soap, tag, a, type, SOAP_TYPE_double);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_time(struct soap *soap, time_t *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_time
	*a = SOAP_DEFAULT_time;
#else
	*a = (time_t)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_time(struct soap *soap, const time_t *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_time);
	if (soap_out_time(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_time(struct soap *soap, const char *tag, int id, const time_t *a, const char *type)
{
	return soap_outdateTime(soap, tag, id, a, type, SOAP_TYPE_time);
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_get_time(struct soap *soap, time_t *p, const char *tag, const char *type)
{
	if ((p = soap_in_time(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_in_time(struct soap *soap, const char *tag, time_t *a, const char *type)
{
	return soap_indateTime(soap, tag, a, type, SOAP_TYPE_time);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bool(struct soap *soap, bool *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_bool
	*a = SOAP_DEFAULT_bool;
#else
	*a = (bool)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bool(struct soap *soap, const bool *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bool);
	if (soap_out_bool(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_bool[] =
{	{ (long)false, "false" },
	{ (long)true, "true" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_bool2s(struct soap *soap, bool n)
{	return soap_code_str(soap_codes_bool, n!=0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bool(struct soap *soap, const char *tag, int id, const bool *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bool), type) || soap_send(soap, soap_bool2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_get_bool(struct soap *soap, bool *p, const char *tag, const char *type)
{
	if ((p = soap_in_bool(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2bool(struct soap *soap, const char *s, bool *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_bool, s);
	if (map)
		*a = (bool)(map->code != 0);
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (bool)(n != 0);
	}
	return SOAP_OK;
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_in_bool(struct soap *soap, const char *tag, bool *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":boolean"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (bool *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bool, sizeof(bool), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2bool(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (bool *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bool, 0, sizeof(bool), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

void _ns1__QueryException::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__QueryException::fault = NULL;
	/* transient soap skipped */
}

void _ns1__QueryException::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons5__QueryException(soap, &this->_ns1__QueryException::fault);
	/* transient soap skipped */
}

int _ns1__QueryException::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__ns1__QueryException);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _ns1__QueryException::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__QueryException(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__QueryException(struct soap *soap, const char *tag, int id, const _ns1__QueryException *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__QueryException), type))
		return soap->error;
	if (soap_out_PointerTons5__QueryException(soap, "fault", -1, &(a->_ns1__QueryException::fault), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_ns1__QueryException::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__QueryException(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__QueryException * SOAP_FMAC4 soap_get__ns1__QueryException(struct soap *soap, _ns1__QueryException *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__QueryException(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_ns1__QueryException::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__QueryException(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__QueryException * SOAP_FMAC4 soap_in__ns1__QueryException(struct soap *soap, const char *tag, _ns1__QueryException *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__QueryException *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__QueryException, sizeof(_ns1__QueryException), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__ns1__QueryException)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_ns1__QueryException *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_fault1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fault1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons5__QueryException(soap, "fault", &(a->_ns1__QueryException::fault), "ns5:QueryException"))
				{	soap_flag_fault1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__QueryException *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__QueryException, 0, sizeof(_ns1__QueryException), 0, soap_copy__ns1__QueryException);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _ns1__QueryException * SOAP_FMAC6 soap_new__ns1__QueryException(struct soap *soap, int n)
{	return soap_instantiate__ns1__QueryException(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__ns1__QueryException(struct soap *soap, _ns1__QueryException *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _ns1__QueryException * SOAP_FMAC4 soap_instantiate__ns1__QueryException(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__QueryException(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__ns1__QueryException, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _ns1__QueryException;
		if (size)
			*size = sizeof(_ns1__QueryException);
		((_ns1__QueryException*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _ns1__QueryException[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_ns1__QueryException);
		for (int i = 0; i < n; i++)
			((_ns1__QueryException*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_ns1__QueryException*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__ns1__QueryException(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _ns1__QueryException %p -> %p\n", q, p));
	*(_ns1__QueryException*)p = *(_ns1__QueryException*)q;
}

void ns5__QueryException::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns5__QueryException::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int ns5__QueryException::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns5__QueryException);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns5__QueryException::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns5__QueryException(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns5__QueryException(struct soap *soap, const char *tag, int id, const ns5__QueryException *a, const char *type)
{
	return soap_outliteral(soap, tag, &(a->xsd__anyType::__item), "ns5:QueryException");
}

void *ns5__QueryException::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns5__QueryException(soap, this, tag, type);
}

SOAP_FMAC3 ns5__QueryException * SOAP_FMAC4 soap_get_ns5__QueryException(struct soap *soap, ns5__QueryException *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns5__QueryException(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns5__QueryException::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns5__QueryException(soap, tag, this, type);
}

SOAP_FMAC3 ns5__QueryException * SOAP_FMAC4 soap_in_ns5__QueryException(struct soap *soap, const char *tag, ns5__QueryException *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (ns5__QueryException *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns5__QueryException, sizeof(ns5__QueryException), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns5__QueryException)
			return (ns5__QueryException *)a->soap_in(soap, tag, type);
	}
	if (!soap_inliteral(soap, tag, &(a->xsd__anyType::__item)))
		return NULL;
	return a;
}

SOAP_FMAC5 ns5__QueryException * SOAP_FMAC6 soap_new_ns5__QueryException(struct soap *soap, int n)
{	return soap_instantiate_ns5__QueryException(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns5__QueryException(struct soap *soap, ns5__QueryException *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns5__QueryException * SOAP_FMAC4 soap_instantiate_ns5__QueryException(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns5__QueryException(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns5__QueryException, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns5__QueryException;
		if (size)
			*size = sizeof(ns5__QueryException);
		((ns5__QueryException*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns5__QueryException[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns5__QueryException);
		for (int i = 0; i < n; i++)
			((ns5__QueryException*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns5__QueryException*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns5__QueryException(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns5__QueryException %p -> %p\n", q, p));
	*(ns5__QueryException*)p = *(ns5__QueryException*)q;
}

void ArrayOf_USCOREtns1_USCORENoteData::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptr = NULL;
}

void ArrayOf_USCOREtns1_USCORENoteData::soap_serialize(struct soap *soap) const
{
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_ArrayOf_USCOREtns1_USCORENoteData))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerTons4__NoteData(soap, this->__ptr + i);
		}
}

int ArrayOf_USCOREtns1_USCORENoteData::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_ArrayOf_USCOREtns1_USCORENoteData);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ArrayOf_USCOREtns1_USCORENoteData::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ArrayOf_USCOREtns1_USCORENoteData(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOf_USCOREtns1_USCORENoteData(struct soap *soap, const char *tag, int id, const ArrayOf_USCOREtns1_USCORENoteData *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "ns4:NoteData", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ArrayOf_USCOREtns1_USCORENoteData);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons4__NoteData(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

void *ArrayOf_USCOREtns1_USCORENoteData::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ArrayOf_USCOREtns1_USCORENoteData(soap, this, tag, type);
}

SOAP_FMAC3 ArrayOf_USCOREtns1_USCORENoteData * SOAP_FMAC4 soap_get_ArrayOf_USCOREtns1_USCORENoteData(struct soap *soap, ArrayOf_USCOREtns1_USCORENoteData *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOf_USCOREtns1_USCORENoteData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ArrayOf_USCOREtns1_USCORENoteData::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ArrayOf_USCOREtns1_USCORENoteData(soap, tag, this, type);
}

SOAP_FMAC3 ArrayOf_USCOREtns1_USCORENoteData * SOAP_FMAC4 soap_in_ArrayOf_USCOREtns1_USCORENoteData(struct soap *soap, const char *tag, ArrayOf_USCOREtns1_USCORENoteData *a, const char *type)
{	int i, j;
	ns4__NoteData **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (ArrayOf_USCOREtns1_USCORENoteData *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOf_USCOREtns1_USCORENoteData, sizeof(ArrayOf_USCOREtns1_USCORENoteData), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (ns4__NoteData **)soap_malloc(soap, sizeof(ns4__NoteData *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons4__NoteData(soap, NULL, a->__ptr + i, "ns4:NoteData"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (ns4__NoteData **)soap_push_block(soap, sizeof(ns4__NoteData *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons4__NoteData(soap, NULL, p, "ns4:NoteData"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap);
			a->__ptr = (ns4__NoteData **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ArrayOf_USCOREtns1_USCORENoteData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ArrayOf_USCOREtns1_USCORENoteData, 0, sizeof(ArrayOf_USCOREtns1_USCORENoteData), 0, soap_copy_ArrayOf_USCOREtns1_USCORENoteData);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ArrayOf_USCOREtns1_USCORENoteData * SOAP_FMAC6 soap_new_ArrayOf_USCOREtns1_USCORENoteData(struct soap *soap, int n)
{	return soap_instantiate_ArrayOf_USCOREtns1_USCORENoteData(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ArrayOf_USCOREtns1_USCORENoteData(struct soap *soap, ArrayOf_USCOREtns1_USCORENoteData *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ArrayOf_USCOREtns1_USCORENoteData * SOAP_FMAC4 soap_instantiate_ArrayOf_USCOREtns1_USCORENoteData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ArrayOf_USCOREtns1_USCORENoteData(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ArrayOf_USCOREtns1_USCORENoteData, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ArrayOf_USCOREtns1_USCORENoteData;
		if (size)
			*size = sizeof(ArrayOf_USCOREtns1_USCORENoteData);
		((ArrayOf_USCOREtns1_USCORENoteData*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ArrayOf_USCOREtns1_USCORENoteData[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ArrayOf_USCOREtns1_USCORENoteData);
		for (int i = 0; i < n; i++)
			((ArrayOf_USCOREtns1_USCORENoteData*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ArrayOf_USCOREtns1_USCORENoteData*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ArrayOf_USCOREtns1_USCORENoteData(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ArrayOf_USCOREtns1_USCORENoteData %p -> %p\n", q, p));
	*(ArrayOf_USCOREtns1_USCORENoteData*)p = *(ArrayOf_USCOREtns1_USCORENoteData*)q;
}

void ArrayOf_USCOREtns1_USCOREProjectData::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptr = NULL;
}

void ArrayOf_USCOREtns1_USCOREProjectData::soap_serialize(struct soap *soap) const
{
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_ArrayOf_USCOREtns1_USCOREProjectData))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerTons4__ProjectData(soap, this->__ptr + i);
		}
}

int ArrayOf_USCOREtns1_USCOREProjectData::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_ArrayOf_USCOREtns1_USCOREProjectData);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ArrayOf_USCOREtns1_USCOREProjectData::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ArrayOf_USCOREtns1_USCOREProjectData(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOf_USCOREtns1_USCOREProjectData(struct soap *soap, const char *tag, int id, const ArrayOf_USCOREtns1_USCOREProjectData *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "ns4:ProjectData", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ArrayOf_USCOREtns1_USCOREProjectData);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons4__ProjectData(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

void *ArrayOf_USCOREtns1_USCOREProjectData::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ArrayOf_USCOREtns1_USCOREProjectData(soap, this, tag, type);
}

SOAP_FMAC3 ArrayOf_USCOREtns1_USCOREProjectData * SOAP_FMAC4 soap_get_ArrayOf_USCOREtns1_USCOREProjectData(struct soap *soap, ArrayOf_USCOREtns1_USCOREProjectData *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOf_USCOREtns1_USCOREProjectData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ArrayOf_USCOREtns1_USCOREProjectData::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ArrayOf_USCOREtns1_USCOREProjectData(soap, tag, this, type);
}

SOAP_FMAC3 ArrayOf_USCOREtns1_USCOREProjectData * SOAP_FMAC4 soap_in_ArrayOf_USCOREtns1_USCOREProjectData(struct soap *soap, const char *tag, ArrayOf_USCOREtns1_USCOREProjectData *a, const char *type)
{	int i, j;
	ns4__ProjectData **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (ArrayOf_USCOREtns1_USCOREProjectData *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOf_USCOREtns1_USCOREProjectData, sizeof(ArrayOf_USCOREtns1_USCOREProjectData), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (ns4__ProjectData **)soap_malloc(soap, sizeof(ns4__ProjectData *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons4__ProjectData(soap, NULL, a->__ptr + i, "ns4:ProjectData"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (ns4__ProjectData **)soap_push_block(soap, sizeof(ns4__ProjectData *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons4__ProjectData(soap, NULL, p, "ns4:ProjectData"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap);
			a->__ptr = (ns4__ProjectData **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ArrayOf_USCOREtns1_USCOREProjectData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ArrayOf_USCOREtns1_USCOREProjectData, 0, sizeof(ArrayOf_USCOREtns1_USCOREProjectData), 0, soap_copy_ArrayOf_USCOREtns1_USCOREProjectData);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ArrayOf_USCOREtns1_USCOREProjectData * SOAP_FMAC6 soap_new_ArrayOf_USCOREtns1_USCOREProjectData(struct soap *soap, int n)
{	return soap_instantiate_ArrayOf_USCOREtns1_USCOREProjectData(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ArrayOf_USCOREtns1_USCOREProjectData(struct soap *soap, ArrayOf_USCOREtns1_USCOREProjectData *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ArrayOf_USCOREtns1_USCOREProjectData * SOAP_FMAC4 soap_instantiate_ArrayOf_USCOREtns1_USCOREProjectData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ArrayOf_USCOREtns1_USCOREProjectData(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ArrayOf_USCOREtns1_USCOREProjectData, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ArrayOf_USCOREtns1_USCOREProjectData;
		if (size)
			*size = sizeof(ArrayOf_USCOREtns1_USCOREProjectData);
		((ArrayOf_USCOREtns1_USCOREProjectData*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ArrayOf_USCOREtns1_USCOREProjectData[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ArrayOf_USCOREtns1_USCOREProjectData);
		for (int i = 0; i < n; i++)
			((ArrayOf_USCOREtns1_USCOREProjectData*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ArrayOf_USCOREtns1_USCOREProjectData*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ArrayOf_USCOREtns1_USCOREProjectData(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ArrayOf_USCOREtns1_USCOREProjectData %p -> %p\n", q, p));
	*(ArrayOf_USCOREtns1_USCOREProjectData*)p = *(ArrayOf_USCOREtns1_USCOREProjectData*)q;
}

void ArrayOf_USCOREtns1_USCOREPersonData::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptr = NULL;
}

void ArrayOf_USCOREtns1_USCOREPersonData::soap_serialize(struct soap *soap) const
{
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_ArrayOf_USCOREtns1_USCOREPersonData))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerTons4__PersonData(soap, this->__ptr + i);
		}
}

int ArrayOf_USCOREtns1_USCOREPersonData::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_ArrayOf_USCOREtns1_USCOREPersonData);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ArrayOf_USCOREtns1_USCOREPersonData::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ArrayOf_USCOREtns1_USCOREPersonData(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOf_USCOREtns1_USCOREPersonData(struct soap *soap, const char *tag, int id, const ArrayOf_USCOREtns1_USCOREPersonData *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "ns4:PersonData", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ArrayOf_USCOREtns1_USCOREPersonData);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons4__PersonData(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

void *ArrayOf_USCOREtns1_USCOREPersonData::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ArrayOf_USCOREtns1_USCOREPersonData(soap, this, tag, type);
}

SOAP_FMAC3 ArrayOf_USCOREtns1_USCOREPersonData * SOAP_FMAC4 soap_get_ArrayOf_USCOREtns1_USCOREPersonData(struct soap *soap, ArrayOf_USCOREtns1_USCOREPersonData *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOf_USCOREtns1_USCOREPersonData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ArrayOf_USCOREtns1_USCOREPersonData::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ArrayOf_USCOREtns1_USCOREPersonData(soap, tag, this, type);
}

SOAP_FMAC3 ArrayOf_USCOREtns1_USCOREPersonData * SOAP_FMAC4 soap_in_ArrayOf_USCOREtns1_USCOREPersonData(struct soap *soap, const char *tag, ArrayOf_USCOREtns1_USCOREPersonData *a, const char *type)
{	int i, j;
	ns4__PersonData **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (ArrayOf_USCOREtns1_USCOREPersonData *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOf_USCOREtns1_USCOREPersonData, sizeof(ArrayOf_USCOREtns1_USCOREPersonData), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (ns4__PersonData **)soap_malloc(soap, sizeof(ns4__PersonData *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons4__PersonData(soap, NULL, a->__ptr + i, "ns4:PersonData"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (ns4__PersonData **)soap_push_block(soap, sizeof(ns4__PersonData *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons4__PersonData(soap, NULL, p, "ns4:PersonData"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap);
			a->__ptr = (ns4__PersonData **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ArrayOf_USCOREtns1_USCOREPersonData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ArrayOf_USCOREtns1_USCOREPersonData, 0, sizeof(ArrayOf_USCOREtns1_USCOREPersonData), 0, soap_copy_ArrayOf_USCOREtns1_USCOREPersonData);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ArrayOf_USCOREtns1_USCOREPersonData * SOAP_FMAC6 soap_new_ArrayOf_USCOREtns1_USCOREPersonData(struct soap *soap, int n)
{	return soap_instantiate_ArrayOf_USCOREtns1_USCOREPersonData(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ArrayOf_USCOREtns1_USCOREPersonData(struct soap *soap, ArrayOf_USCOREtns1_USCOREPersonData *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ArrayOf_USCOREtns1_USCOREPersonData * SOAP_FMAC4 soap_instantiate_ArrayOf_USCOREtns1_USCOREPersonData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ArrayOf_USCOREtns1_USCOREPersonData(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ArrayOf_USCOREtns1_USCOREPersonData, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ArrayOf_USCOREtns1_USCOREPersonData;
		if (size)
			*size = sizeof(ArrayOf_USCOREtns1_USCOREPersonData);
		((ArrayOf_USCOREtns1_USCOREPersonData*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ArrayOf_USCOREtns1_USCOREPersonData[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ArrayOf_USCOREtns1_USCOREPersonData);
		for (int i = 0; i < n; i++)
			((ArrayOf_USCOREtns1_USCOREPersonData*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ArrayOf_USCOREtns1_USCOREPersonData*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ArrayOf_USCOREtns1_USCOREPersonData(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ArrayOf_USCOREtns1_USCOREPersonData %p -> %p\n", q, p));
	*(ArrayOf_USCOREtns1_USCOREPersonData*)p = *(ArrayOf_USCOREtns1_USCOREPersonData*)q;
}

void ArrayOf_USCOREtns1_USCORETimeEntryData::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptr = NULL;
}

void ArrayOf_USCOREtns1_USCORETimeEntryData::soap_serialize(struct soap *soap) const
{
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_ArrayOf_USCOREtns1_USCORETimeEntryData))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerTons4__TimeEntryData(soap, this->__ptr + i);
		}
}

int ArrayOf_USCOREtns1_USCORETimeEntryData::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_ArrayOf_USCOREtns1_USCORETimeEntryData);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ArrayOf_USCOREtns1_USCORETimeEntryData::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ArrayOf_USCOREtns1_USCORETimeEntryData(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOf_USCOREtns1_USCORETimeEntryData(struct soap *soap, const char *tag, int id, const ArrayOf_USCOREtns1_USCORETimeEntryData *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "ns4:TimeEntryData", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ArrayOf_USCOREtns1_USCORETimeEntryData);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons4__TimeEntryData(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

void *ArrayOf_USCOREtns1_USCORETimeEntryData::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ArrayOf_USCOREtns1_USCORETimeEntryData(soap, this, tag, type);
}

SOAP_FMAC3 ArrayOf_USCOREtns1_USCORETimeEntryData * SOAP_FMAC4 soap_get_ArrayOf_USCOREtns1_USCORETimeEntryData(struct soap *soap, ArrayOf_USCOREtns1_USCORETimeEntryData *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOf_USCOREtns1_USCORETimeEntryData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ArrayOf_USCOREtns1_USCORETimeEntryData::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ArrayOf_USCOREtns1_USCORETimeEntryData(soap, tag, this, type);
}

SOAP_FMAC3 ArrayOf_USCOREtns1_USCORETimeEntryData * SOAP_FMAC4 soap_in_ArrayOf_USCOREtns1_USCORETimeEntryData(struct soap *soap, const char *tag, ArrayOf_USCOREtns1_USCORETimeEntryData *a, const char *type)
{	int i, j;
	ns4__TimeEntryData **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (ArrayOf_USCOREtns1_USCORETimeEntryData *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOf_USCOREtns1_USCORETimeEntryData, sizeof(ArrayOf_USCOREtns1_USCORETimeEntryData), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (ns4__TimeEntryData **)soap_malloc(soap, sizeof(ns4__TimeEntryData *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons4__TimeEntryData(soap, NULL, a->__ptr + i, "ns4:TimeEntryData"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (ns4__TimeEntryData **)soap_push_block(soap, sizeof(ns4__TimeEntryData *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons4__TimeEntryData(soap, NULL, p, "ns4:TimeEntryData"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap);
			a->__ptr = (ns4__TimeEntryData **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ArrayOf_USCOREtns1_USCORETimeEntryData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ArrayOf_USCOREtns1_USCORETimeEntryData, 0, sizeof(ArrayOf_USCOREtns1_USCORETimeEntryData), 0, soap_copy_ArrayOf_USCOREtns1_USCORETimeEntryData);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ArrayOf_USCOREtns1_USCORETimeEntryData * SOAP_FMAC6 soap_new_ArrayOf_USCOREtns1_USCORETimeEntryData(struct soap *soap, int n)
{	return soap_instantiate_ArrayOf_USCOREtns1_USCORETimeEntryData(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ArrayOf_USCOREtns1_USCORETimeEntryData(struct soap *soap, ArrayOf_USCOREtns1_USCORETimeEntryData *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ArrayOf_USCOREtns1_USCORETimeEntryData * SOAP_FMAC4 soap_instantiate_ArrayOf_USCOREtns1_USCORETimeEntryData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ArrayOf_USCOREtns1_USCORETimeEntryData(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ArrayOf_USCOREtns1_USCORETimeEntryData, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ArrayOf_USCOREtns1_USCORETimeEntryData;
		if (size)
			*size = sizeof(ArrayOf_USCOREtns1_USCORETimeEntryData);
		((ArrayOf_USCOREtns1_USCORETimeEntryData*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ArrayOf_USCOREtns1_USCORETimeEntryData[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ArrayOf_USCOREtns1_USCORETimeEntryData);
		for (int i = 0; i < n; i++)
			((ArrayOf_USCOREtns1_USCORETimeEntryData*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ArrayOf_USCOREtns1_USCORETimeEntryData*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ArrayOf_USCOREtns1_USCORETimeEntryData(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ArrayOf_USCOREtns1_USCORETimeEntryData %p -> %p\n", q, p));
	*(ArrayOf_USCOREtns1_USCORETimeEntryData*)p = *(ArrayOf_USCOREtns1_USCORETimeEntryData*)q;
}

void ArrayOf_USCOREtns1_USCORETaskData::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptr = NULL;
}

void ArrayOf_USCOREtns1_USCORETaskData::soap_serialize(struct soap *soap) const
{
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_ArrayOf_USCOREtns1_USCORETaskData))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerTons4__TaskData(soap, this->__ptr + i);
		}
}

int ArrayOf_USCOREtns1_USCORETaskData::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_ArrayOf_USCOREtns1_USCORETaskData);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ArrayOf_USCOREtns1_USCORETaskData::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ArrayOf_USCOREtns1_USCORETaskData(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOf_USCOREtns1_USCORETaskData(struct soap *soap, const char *tag, int id, const ArrayOf_USCOREtns1_USCORETaskData *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "ns4:TaskData", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ArrayOf_USCOREtns1_USCORETaskData);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons4__TaskData(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

void *ArrayOf_USCOREtns1_USCORETaskData::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ArrayOf_USCOREtns1_USCORETaskData(soap, this, tag, type);
}

SOAP_FMAC3 ArrayOf_USCOREtns1_USCORETaskData * SOAP_FMAC4 soap_get_ArrayOf_USCOREtns1_USCORETaskData(struct soap *soap, ArrayOf_USCOREtns1_USCORETaskData *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOf_USCOREtns1_USCORETaskData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ArrayOf_USCOREtns1_USCORETaskData::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ArrayOf_USCOREtns1_USCORETaskData(soap, tag, this, type);
}

SOAP_FMAC3 ArrayOf_USCOREtns1_USCORETaskData * SOAP_FMAC4 soap_in_ArrayOf_USCOREtns1_USCORETaskData(struct soap *soap, const char *tag, ArrayOf_USCOREtns1_USCORETaskData *a, const char *type)
{	int i, j;
	ns4__TaskData **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (ArrayOf_USCOREtns1_USCORETaskData *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOf_USCOREtns1_USCORETaskData, sizeof(ArrayOf_USCOREtns1_USCORETaskData), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (ns4__TaskData **)soap_malloc(soap, sizeof(ns4__TaskData *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons4__TaskData(soap, NULL, a->__ptr + i, "ns4:TaskData"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (ns4__TaskData **)soap_push_block(soap, sizeof(ns4__TaskData *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons4__TaskData(soap, NULL, p, "ns4:TaskData"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap);
			a->__ptr = (ns4__TaskData **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ArrayOf_USCOREtns1_USCORETaskData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ArrayOf_USCOREtns1_USCORETaskData, 0, sizeof(ArrayOf_USCOREtns1_USCORETaskData), 0, soap_copy_ArrayOf_USCOREtns1_USCORETaskData);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ArrayOf_USCOREtns1_USCORETaskData * SOAP_FMAC6 soap_new_ArrayOf_USCOREtns1_USCORETaskData(struct soap *soap, int n)
{	return soap_instantiate_ArrayOf_USCOREtns1_USCORETaskData(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ArrayOf_USCOREtns1_USCORETaskData(struct soap *soap, ArrayOf_USCOREtns1_USCORETaskData *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ArrayOf_USCOREtns1_USCORETaskData * SOAP_FMAC4 soap_instantiate_ArrayOf_USCOREtns1_USCORETaskData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ArrayOf_USCOREtns1_USCORETaskData(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ArrayOf_USCOREtns1_USCORETaskData, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ArrayOf_USCOREtns1_USCORETaskData;
		if (size)
			*size = sizeof(ArrayOf_USCOREtns1_USCORETaskData);
		((ArrayOf_USCOREtns1_USCORETaskData*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ArrayOf_USCOREtns1_USCORETaskData[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ArrayOf_USCOREtns1_USCORETaskData);
		for (int i = 0; i < n; i++)
			((ArrayOf_USCOREtns1_USCORETaskData*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ArrayOf_USCOREtns1_USCORETaskData*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ArrayOf_USCOREtns1_USCORETaskData(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ArrayOf_USCOREtns1_USCORETaskData %p -> %p\n", q, p));
	*(ArrayOf_USCOREtns1_USCORETaskData*)p = *(ArrayOf_USCOREtns1_USCORETaskData*)q;
}

void ArrayOf_USCOREtns1_USCOREUserStoryData::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptr = NULL;
}

void ArrayOf_USCOREtns1_USCOREUserStoryData::soap_serialize(struct soap *soap) const
{
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_ArrayOf_USCOREtns1_USCOREUserStoryData))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerTons4__UserStoryData(soap, this->__ptr + i);
		}
}

int ArrayOf_USCOREtns1_USCOREUserStoryData::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_ArrayOf_USCOREtns1_USCOREUserStoryData);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ArrayOf_USCOREtns1_USCOREUserStoryData::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ArrayOf_USCOREtns1_USCOREUserStoryData(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOf_USCOREtns1_USCOREUserStoryData(struct soap *soap, const char *tag, int id, const ArrayOf_USCOREtns1_USCOREUserStoryData *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "ns4:UserStoryData", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ArrayOf_USCOREtns1_USCOREUserStoryData);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons4__UserStoryData(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

void *ArrayOf_USCOREtns1_USCOREUserStoryData::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ArrayOf_USCOREtns1_USCOREUserStoryData(soap, this, tag, type);
}

SOAP_FMAC3 ArrayOf_USCOREtns1_USCOREUserStoryData * SOAP_FMAC4 soap_get_ArrayOf_USCOREtns1_USCOREUserStoryData(struct soap *soap, ArrayOf_USCOREtns1_USCOREUserStoryData *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOf_USCOREtns1_USCOREUserStoryData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ArrayOf_USCOREtns1_USCOREUserStoryData::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ArrayOf_USCOREtns1_USCOREUserStoryData(soap, tag, this, type);
}

SOAP_FMAC3 ArrayOf_USCOREtns1_USCOREUserStoryData * SOAP_FMAC4 soap_in_ArrayOf_USCOREtns1_USCOREUserStoryData(struct soap *soap, const char *tag, ArrayOf_USCOREtns1_USCOREUserStoryData *a, const char *type)
{	int i, j;
	ns4__UserStoryData **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (ArrayOf_USCOREtns1_USCOREUserStoryData *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOf_USCOREtns1_USCOREUserStoryData, sizeof(ArrayOf_USCOREtns1_USCOREUserStoryData), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (ns4__UserStoryData **)soap_malloc(soap, sizeof(ns4__UserStoryData *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons4__UserStoryData(soap, NULL, a->__ptr + i, "ns4:UserStoryData"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (ns4__UserStoryData **)soap_push_block(soap, sizeof(ns4__UserStoryData *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons4__UserStoryData(soap, NULL, p, "ns4:UserStoryData"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap);
			a->__ptr = (ns4__UserStoryData **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ArrayOf_USCOREtns1_USCOREUserStoryData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ArrayOf_USCOREtns1_USCOREUserStoryData, 0, sizeof(ArrayOf_USCOREtns1_USCOREUserStoryData), 0, soap_copy_ArrayOf_USCOREtns1_USCOREUserStoryData);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ArrayOf_USCOREtns1_USCOREUserStoryData * SOAP_FMAC6 soap_new_ArrayOf_USCOREtns1_USCOREUserStoryData(struct soap *soap, int n)
{	return soap_instantiate_ArrayOf_USCOREtns1_USCOREUserStoryData(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ArrayOf_USCOREtns1_USCOREUserStoryData(struct soap *soap, ArrayOf_USCOREtns1_USCOREUserStoryData *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ArrayOf_USCOREtns1_USCOREUserStoryData * SOAP_FMAC4 soap_instantiate_ArrayOf_USCOREtns1_USCOREUserStoryData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ArrayOf_USCOREtns1_USCOREUserStoryData(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ArrayOf_USCOREtns1_USCOREUserStoryData, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ArrayOf_USCOREtns1_USCOREUserStoryData;
		if (size)
			*size = sizeof(ArrayOf_USCOREtns1_USCOREUserStoryData);
		((ArrayOf_USCOREtns1_USCOREUserStoryData*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ArrayOf_USCOREtns1_USCOREUserStoryData[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ArrayOf_USCOREtns1_USCOREUserStoryData);
		for (int i = 0; i < n; i++)
			((ArrayOf_USCOREtns1_USCOREUserStoryData*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ArrayOf_USCOREtns1_USCOREUserStoryData*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ArrayOf_USCOREtns1_USCOREUserStoryData(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ArrayOf_USCOREtns1_USCOREUserStoryData %p -> %p\n", q, p));
	*(ArrayOf_USCOREtns1_USCOREUserStoryData*)p = *(ArrayOf_USCOREtns1_USCOREUserStoryData*)q;
}

void ArrayOf_USCOREtns1_USCOREIterationData::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptr = NULL;
}

void ArrayOf_USCOREtns1_USCOREIterationData::soap_serialize(struct soap *soap) const
{
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_ArrayOf_USCOREtns1_USCOREIterationData))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerTons4__IterationData(soap, this->__ptr + i);
		}
}

int ArrayOf_USCOREtns1_USCOREIterationData::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_ArrayOf_USCOREtns1_USCOREIterationData);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ArrayOf_USCOREtns1_USCOREIterationData::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ArrayOf_USCOREtns1_USCOREIterationData(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOf_USCOREtns1_USCOREIterationData(struct soap *soap, const char *tag, int id, const ArrayOf_USCOREtns1_USCOREIterationData *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "ns4:IterationData", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ArrayOf_USCOREtns1_USCOREIterationData);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons4__IterationData(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

void *ArrayOf_USCOREtns1_USCOREIterationData::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ArrayOf_USCOREtns1_USCOREIterationData(soap, this, tag, type);
}

SOAP_FMAC3 ArrayOf_USCOREtns1_USCOREIterationData * SOAP_FMAC4 soap_get_ArrayOf_USCOREtns1_USCOREIterationData(struct soap *soap, ArrayOf_USCOREtns1_USCOREIterationData *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOf_USCOREtns1_USCOREIterationData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ArrayOf_USCOREtns1_USCOREIterationData::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ArrayOf_USCOREtns1_USCOREIterationData(soap, tag, this, type);
}

SOAP_FMAC3 ArrayOf_USCOREtns1_USCOREIterationData * SOAP_FMAC4 soap_in_ArrayOf_USCOREtns1_USCOREIterationData(struct soap *soap, const char *tag, ArrayOf_USCOREtns1_USCOREIterationData *a, const char *type)
{	int i, j;
	ns4__IterationData **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (ArrayOf_USCOREtns1_USCOREIterationData *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOf_USCOREtns1_USCOREIterationData, sizeof(ArrayOf_USCOREtns1_USCOREIterationData), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (ns4__IterationData **)soap_malloc(soap, sizeof(ns4__IterationData *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons4__IterationData(soap, NULL, a->__ptr + i, "ns4:IterationData"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (ns4__IterationData **)soap_push_block(soap, sizeof(ns4__IterationData *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons4__IterationData(soap, NULL, p, "ns4:IterationData"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap);
			a->__ptr = (ns4__IterationData **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ArrayOf_USCOREtns1_USCOREIterationData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ArrayOf_USCOREtns1_USCOREIterationData, 0, sizeof(ArrayOf_USCOREtns1_USCOREIterationData), 0, soap_copy_ArrayOf_USCOREtns1_USCOREIterationData);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ArrayOf_USCOREtns1_USCOREIterationData * SOAP_FMAC6 soap_new_ArrayOf_USCOREtns1_USCOREIterationData(struct soap *soap, int n)
{	return soap_instantiate_ArrayOf_USCOREtns1_USCOREIterationData(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ArrayOf_USCOREtns1_USCOREIterationData(struct soap *soap, ArrayOf_USCOREtns1_USCOREIterationData *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ArrayOf_USCOREtns1_USCOREIterationData * SOAP_FMAC4 soap_instantiate_ArrayOf_USCOREtns1_USCOREIterationData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ArrayOf_USCOREtns1_USCOREIterationData(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ArrayOf_USCOREtns1_USCOREIterationData, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ArrayOf_USCOREtns1_USCOREIterationData;
		if (size)
			*size = sizeof(ArrayOf_USCOREtns1_USCOREIterationData);
		((ArrayOf_USCOREtns1_USCOREIterationData*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ArrayOf_USCOREtns1_USCOREIterationData[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ArrayOf_USCOREtns1_USCOREIterationData);
		for (int i = 0; i < n; i++)
			((ArrayOf_USCOREtns1_USCOREIterationData*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ArrayOf_USCOREtns1_USCOREIterationData*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ArrayOf_USCOREtns1_USCOREIterationData(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ArrayOf_USCOREtns1_USCOREIterationData %p -> %p\n", q, p));
	*(ArrayOf_USCOREtns1_USCOREIterationData*)p = *(ArrayOf_USCOREtns1_USCOREIterationData*)q;
}

void ns4__IterationData::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_int(soap, &this->ns4__IterationData::id);
	this->ns4__IterationData::lastUpdateTime = NULL;
	soap_default_double(soap, &this->ns4__IterationData::actualHours);
	soap_default_double(soap, &this->ns4__IterationData::addedHours);
	soap_default_double(soap, &this->ns4__IterationData::adjustedEstimatedHours);
	soap_default_double(soap, &this->ns4__IterationData::daysWorked);
	soap_default_string(soap, &this->ns4__IterationData::description);
	this->ns4__IterationData::endDate = NULL;
	soap_default_double(soap, &this->ns4__IterationData::estimatedHours);
	soap_default_string(soap, &this->ns4__IterationData::name);
	soap_default_double(soap, &this->ns4__IterationData::overestimatedHours);
	soap_default_double(soap, &this->ns4__IterationData::postponedHours);
	soap_default_int(soap, &this->ns4__IterationData::projectId);
	soap_default_double(soap, &this->ns4__IterationData::remainingHours);
	this->ns4__IterationData::startDate = NULL;
	soap_default_string(soap, &this->ns4__IterationData::statusKey);
	soap_default_double(soap, &this->ns4__IterationData::underestimatedHours);
}

void ns4__IterationData::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTotime(soap, &this->ns4__IterationData::lastUpdateTime);
	soap_serialize_string(soap, &this->ns4__IterationData::description);
	soap_serialize_PointerTotime(soap, &this->ns4__IterationData::endDate);
	soap_serialize_string(soap, &this->ns4__IterationData::name);
	soap_serialize_PointerTotime(soap, &this->ns4__IterationData::startDate);
	soap_serialize_string(soap, &this->ns4__IterationData::statusKey);
}

int ns4__IterationData::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns4__IterationData);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns4__IterationData::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__IterationData(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__IterationData(struct soap *soap, const char *tag, int id, const ns4__IterationData *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__IterationData), type))
		return soap->error;
	if (soap_out_int(soap, "id", -1, &(a->ns4__IterationData::id), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "lastUpdateTime", -1, &(a->ns4__IterationData::lastUpdateTime), ""))
		return soap->error;
	if (soap_out_double(soap, "actualHours", -1, &(a->ns4__IterationData::actualHours), ""))
		return soap->error;
	if (soap_out_double(soap, "addedHours", -1, &(a->ns4__IterationData::addedHours), ""))
		return soap->error;
	if (soap_out_double(soap, "adjustedEstimatedHours", -1, &(a->ns4__IterationData::adjustedEstimatedHours), ""))
		return soap->error;
	if (soap_out_double(soap, "daysWorked", -1, &(a->ns4__IterationData::daysWorked), ""))
		return soap->error;
	if (soap_out_string(soap, "description", -1, &(a->ns4__IterationData::description), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "endDate", -1, &(a->ns4__IterationData::endDate), ""))
		return soap->error;
	if (soap_out_double(soap, "estimatedHours", -1, &(a->ns4__IterationData::estimatedHours), ""))
		return soap->error;
	if (soap_out_string(soap, "name", -1, &(a->ns4__IterationData::name), ""))
		return soap->error;
	if (soap_out_double(soap, "overestimatedHours", -1, &(a->ns4__IterationData::overestimatedHours), ""))
		return soap->error;
	if (soap_out_double(soap, "postponedHours", -1, &(a->ns4__IterationData::postponedHours), ""))
		return soap->error;
	if (soap_out_int(soap, "projectId", -1, &(a->ns4__IterationData::projectId), ""))
		return soap->error;
	if (soap_out_double(soap, "remainingHours", -1, &(a->ns4__IterationData::remainingHours), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "startDate", -1, &(a->ns4__IterationData::startDate), ""))
		return soap->error;
	if (soap_out_string(soap, "statusKey", -1, &(a->ns4__IterationData::statusKey), ""))
		return soap->error;
	if (soap_out_double(soap, "underestimatedHours", -1, &(a->ns4__IterationData::underestimatedHours), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns4__IterationData::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__IterationData(soap, this, tag, type);
}

SOAP_FMAC3 ns4__IterationData * SOAP_FMAC4 soap_get_ns4__IterationData(struct soap *soap, ns4__IterationData *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__IterationData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns4__IterationData::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns4__IterationData(soap, tag, this, type);
}

SOAP_FMAC3 ns4__IterationData * SOAP_FMAC4 soap_in_ns4__IterationData(struct soap *soap, const char *tag, ns4__IterationData *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns4__IterationData *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__IterationData, sizeof(ns4__IterationData), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns4__IterationData)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns4__IterationData *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_id1 = 1, soap_flag_lastUpdateTime1 = 1, soap_flag_actualHours1 = 1, soap_flag_addedHours1 = 1, soap_flag_adjustedEstimatedHours1 = 1, soap_flag_daysWorked1 = 1, soap_flag_description1 = 1, soap_flag_endDate1 = 1, soap_flag_estimatedHours1 = 1, soap_flag_name1 = 1, soap_flag_overestimatedHours1 = 1, soap_flag_postponedHours1 = 1, soap_flag_projectId1 = 1, soap_flag_remainingHours1 = 1, soap_flag_startDate1 = 1, soap_flag_statusKey1 = 1, soap_flag_underestimatedHours1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "id", &(a->ns4__IterationData::id), "xsd:int"))
				{	soap_flag_id1--;
					continue;
				}
			if (soap_flag_lastUpdateTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "lastUpdateTime", &(a->ns4__IterationData::lastUpdateTime), "xsd:dateTime"))
				{	soap_flag_lastUpdateTime1--;
					continue;
				}
			if (soap_flag_actualHours1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "actualHours", &(a->ns4__IterationData::actualHours), "xsd:double"))
				{	soap_flag_actualHours1--;
					continue;
				}
			if (soap_flag_addedHours1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "addedHours", &(a->ns4__IterationData::addedHours), "xsd:double"))
				{	soap_flag_addedHours1--;
					continue;
				}
			if (soap_flag_adjustedEstimatedHours1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "adjustedEstimatedHours", &(a->ns4__IterationData::adjustedEstimatedHours), "xsd:double"))
				{	soap_flag_adjustedEstimatedHours1--;
					continue;
				}
			if (soap_flag_daysWorked1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "daysWorked", &(a->ns4__IterationData::daysWorked), "xsd:double"))
				{	soap_flag_daysWorked1--;
					continue;
				}
			if (soap_flag_description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "description", &(a->ns4__IterationData::description), "xsd:string"))
				{	soap_flag_description1--;
					continue;
				}
			if (soap_flag_endDate1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "endDate", &(a->ns4__IterationData::endDate), "xsd:dateTime"))
				{	soap_flag_endDate1--;
					continue;
				}
			if (soap_flag_estimatedHours1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "estimatedHours", &(a->ns4__IterationData::estimatedHours), "xsd:double"))
				{	soap_flag_estimatedHours1--;
					continue;
				}
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "name", &(a->ns4__IterationData::name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap_flag_overestimatedHours1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "overestimatedHours", &(a->ns4__IterationData::overestimatedHours), "xsd:double"))
				{	soap_flag_overestimatedHours1--;
					continue;
				}
			if (soap_flag_postponedHours1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "postponedHours", &(a->ns4__IterationData::postponedHours), "xsd:double"))
				{	soap_flag_postponedHours1--;
					continue;
				}
			if (soap_flag_projectId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "projectId", &(a->ns4__IterationData::projectId), "xsd:int"))
				{	soap_flag_projectId1--;
					continue;
				}
			if (soap_flag_remainingHours1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "remainingHours", &(a->ns4__IterationData::remainingHours), "xsd:double"))
				{	soap_flag_remainingHours1--;
					continue;
				}
			if (soap_flag_startDate1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "startDate", &(a->ns4__IterationData::startDate), "xsd:dateTime"))
				{	soap_flag_startDate1--;
					continue;
				}
			if (soap_flag_statusKey1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "statusKey", &(a->ns4__IterationData::statusKey), "xsd:string"))
				{	soap_flag_statusKey1--;
					continue;
				}
			if (soap_flag_underestimatedHours1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "underestimatedHours", &(a->ns4__IterationData::underestimatedHours), "xsd:double"))
				{	soap_flag_underestimatedHours1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns4__IterationData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__IterationData, 0, sizeof(ns4__IterationData), 0, soap_copy_ns4__IterationData);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id1 > 0 || soap_flag_actualHours1 > 0 || soap_flag_addedHours1 > 0 || soap_flag_adjustedEstimatedHours1 > 0 || soap_flag_daysWorked1 > 0 || soap_flag_estimatedHours1 > 0 || soap_flag_overestimatedHours1 > 0 || soap_flag_postponedHours1 > 0 || soap_flag_projectId1 > 0 || soap_flag_remainingHours1 > 0 || soap_flag_underestimatedHours1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 ns4__IterationData * SOAP_FMAC6 soap_new_ns4__IterationData(struct soap *soap, int n)
{	return soap_instantiate_ns4__IterationData(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns4__IterationData(struct soap *soap, ns4__IterationData *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns4__IterationData * SOAP_FMAC4 soap_instantiate_ns4__IterationData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__IterationData(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns4__IterationData, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns4__IterationData;
		if (size)
			*size = sizeof(ns4__IterationData);
	}
	else
	{	cp->ptr = (void*)new ns4__IterationData[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns4__IterationData);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns4__IterationData*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns4__IterationData(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns4__IterationData %p -> %p\n", q, p));
	*(ns4__IterationData*)p = *(ns4__IterationData*)q;
}

void ns4__TaskData::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_int(soap, &this->ns4__TaskData::id);
	this->ns4__TaskData::lastUpdateTime = NULL;
	soap_default_int(soap, &this->ns4__TaskData::acceptorId);
	soap_default_double(soap, &this->ns4__TaskData::actualHours);
	soap_default_double(soap, &this->ns4__TaskData::adjustedEstimatedHours);
	soap_default_bool(soap, &this->ns4__TaskData::completed);
	this->ns4__TaskData::createdDate = NULL;
	soap_default_string(soap, &this->ns4__TaskData::description);
	soap_default_string(soap, &this->ns4__TaskData::dispositionName);
	soap_default_double(soap, &this->ns4__TaskData::estimatedHours);
	soap_default_double(soap, &this->ns4__TaskData::estimatedOriginalHours);
	soap_default_string(soap, &this->ns4__TaskData::name);
	soap_default_double(soap, &this->ns4__TaskData::remainingHours);
	soap_default_int(soap, &this->ns4__TaskData::storyId);
	soap_default_string(soap, &this->ns4__TaskData::type);
}

void ns4__TaskData::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTotime(soap, &this->ns4__TaskData::lastUpdateTime);
	soap_serialize_PointerTotime(soap, &this->ns4__TaskData::createdDate);
	soap_serialize_string(soap, &this->ns4__TaskData::description);
	soap_serialize_string(soap, &this->ns4__TaskData::dispositionName);
	soap_serialize_string(soap, &this->ns4__TaskData::name);
	soap_serialize_string(soap, &this->ns4__TaskData::type);
}

int ns4__TaskData::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns4__TaskData);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns4__TaskData::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__TaskData(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__TaskData(struct soap *soap, const char *tag, int id, const ns4__TaskData *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__TaskData), type))
		return soap->error;
	if (soap_out_int(soap, "id", -1, &(a->ns4__TaskData::id), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "lastUpdateTime", -1, &(a->ns4__TaskData::lastUpdateTime), ""))
		return soap->error;
	if (soap_out_int(soap, "acceptorId", -1, &(a->ns4__TaskData::acceptorId), ""))
		return soap->error;
	if (soap_out_double(soap, "actualHours", -1, &(a->ns4__TaskData::actualHours), ""))
		return soap->error;
	if (soap_out_double(soap, "adjustedEstimatedHours", -1, &(a->ns4__TaskData::adjustedEstimatedHours), ""))
		return soap->error;
	if (soap_out_bool(soap, "completed", -1, &(a->ns4__TaskData::completed), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "createdDate", -1, &(a->ns4__TaskData::createdDate), ""))
		return soap->error;
	if (soap_out_string(soap, "description", -1, &(a->ns4__TaskData::description), ""))
		return soap->error;
	if (soap_out_string(soap, "dispositionName", -1, &(a->ns4__TaskData::dispositionName), ""))
		return soap->error;
	if (soap_out_double(soap, "estimatedHours", -1, &(a->ns4__TaskData::estimatedHours), ""))
		return soap->error;
	if (soap_out_double(soap, "estimatedOriginalHours", -1, &(a->ns4__TaskData::estimatedOriginalHours), ""))
		return soap->error;
	if (soap_out_string(soap, "name", -1, &(a->ns4__TaskData::name), ""))
		return soap->error;
	if (soap_out_double(soap, "remainingHours", -1, &(a->ns4__TaskData::remainingHours), ""))
		return soap->error;
	if (soap_out_int(soap, "storyId", -1, &(a->ns4__TaskData::storyId), ""))
		return soap->error;
	if (soap_out_string(soap, "type", -1, &(a->ns4__TaskData::type), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns4__TaskData::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__TaskData(soap, this, tag, type);
}

SOAP_FMAC3 ns4__TaskData * SOAP_FMAC4 soap_get_ns4__TaskData(struct soap *soap, ns4__TaskData *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__TaskData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns4__TaskData::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns4__TaskData(soap, tag, this, type);
}

SOAP_FMAC3 ns4__TaskData * SOAP_FMAC4 soap_in_ns4__TaskData(struct soap *soap, const char *tag, ns4__TaskData *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns4__TaskData *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__TaskData, sizeof(ns4__TaskData), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns4__TaskData)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns4__TaskData *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_id1 = 1, soap_flag_lastUpdateTime1 = 1, soap_flag_acceptorId1 = 1, soap_flag_actualHours1 = 1, soap_flag_adjustedEstimatedHours1 = 1, soap_flag_completed1 = 1, soap_flag_createdDate1 = 1, soap_flag_description1 = 1, soap_flag_dispositionName1 = 1, soap_flag_estimatedHours1 = 1, soap_flag_estimatedOriginalHours1 = 1, soap_flag_name1 = 1, soap_flag_remainingHours1 = 1, soap_flag_storyId1 = 1, soap_flag_type1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "id", &(a->ns4__TaskData::id), "xsd:int"))
				{	soap_flag_id1--;
					continue;
				}
			if (soap_flag_lastUpdateTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "lastUpdateTime", &(a->ns4__TaskData::lastUpdateTime), "xsd:dateTime"))
				{	soap_flag_lastUpdateTime1--;
					continue;
				}
			if (soap_flag_acceptorId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "acceptorId", &(a->ns4__TaskData::acceptorId), "xsd:int"))
				{	soap_flag_acceptorId1--;
					continue;
				}
			if (soap_flag_actualHours1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "actualHours", &(a->ns4__TaskData::actualHours), "xsd:double"))
				{	soap_flag_actualHours1--;
					continue;
				}
			if (soap_flag_adjustedEstimatedHours1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "adjustedEstimatedHours", &(a->ns4__TaskData::adjustedEstimatedHours), "xsd:double"))
				{	soap_flag_adjustedEstimatedHours1--;
					continue;
				}
			if (soap_flag_completed1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "completed", &(a->ns4__TaskData::completed), "xsd:boolean"))
				{	soap_flag_completed1--;
					continue;
				}
			if (soap_flag_createdDate1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "createdDate", &(a->ns4__TaskData::createdDate), "xsd:dateTime"))
				{	soap_flag_createdDate1--;
					continue;
				}
			if (soap_flag_description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "description", &(a->ns4__TaskData::description), "xsd:string"))
				{	soap_flag_description1--;
					continue;
				}
			if (soap_flag_dispositionName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "dispositionName", &(a->ns4__TaskData::dispositionName), "xsd:string"))
				{	soap_flag_dispositionName1--;
					continue;
				}
			if (soap_flag_estimatedHours1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "estimatedHours", &(a->ns4__TaskData::estimatedHours), "xsd:double"))
				{	soap_flag_estimatedHours1--;
					continue;
				}
			if (soap_flag_estimatedOriginalHours1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "estimatedOriginalHours", &(a->ns4__TaskData::estimatedOriginalHours), "xsd:double"))
				{	soap_flag_estimatedOriginalHours1--;
					continue;
				}
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "name", &(a->ns4__TaskData::name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap_flag_remainingHours1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "remainingHours", &(a->ns4__TaskData::remainingHours), "xsd:double"))
				{	soap_flag_remainingHours1--;
					continue;
				}
			if (soap_flag_storyId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "storyId", &(a->ns4__TaskData::storyId), "xsd:int"))
				{	soap_flag_storyId1--;
					continue;
				}
			if (soap_flag_type1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "type", &(a->ns4__TaskData::type), "xsd:string"))
				{	soap_flag_type1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns4__TaskData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__TaskData, 0, sizeof(ns4__TaskData), 0, soap_copy_ns4__TaskData);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id1 > 0 || soap_flag_acceptorId1 > 0 || soap_flag_actualHours1 > 0 || soap_flag_adjustedEstimatedHours1 > 0 || soap_flag_completed1 > 0 || soap_flag_estimatedHours1 > 0 || soap_flag_estimatedOriginalHours1 > 0 || soap_flag_remainingHours1 > 0 || soap_flag_storyId1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 ns4__TaskData * SOAP_FMAC6 soap_new_ns4__TaskData(struct soap *soap, int n)
{	return soap_instantiate_ns4__TaskData(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns4__TaskData(struct soap *soap, ns4__TaskData *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns4__TaskData * SOAP_FMAC4 soap_instantiate_ns4__TaskData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__TaskData(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns4__TaskData, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns4__TaskData;
		if (size)
			*size = sizeof(ns4__TaskData);
	}
	else
	{	cp->ptr = (void*)new ns4__TaskData[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns4__TaskData);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns4__TaskData*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns4__TaskData(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns4__TaskData %p -> %p\n", q, p));
	*(ns4__TaskData*)p = *(ns4__TaskData*)q;
}

void ns4__TimeEntryData::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_int(soap, &this->ns4__TimeEntryData::id);
	this->ns4__TimeEntryData::lastUpdateTime = NULL;
	soap_default_string(soap, &this->ns4__TimeEntryData::description);
	soap_default_double(soap, &this->ns4__TimeEntryData::duration);
	this->ns4__TimeEntryData::endTime = NULL;
	soap_default_int(soap, &this->ns4__TimeEntryData::person1Id);
	soap_default_int(soap, &this->ns4__TimeEntryData::person2Id);
	this->ns4__TimeEntryData::reportDate = NULL;
	this->ns4__TimeEntryData::startTime = NULL;
	soap_default_int(soap, &this->ns4__TimeEntryData::taskId);
}

void ns4__TimeEntryData::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTotime(soap, &this->ns4__TimeEntryData::lastUpdateTime);
	soap_serialize_string(soap, &this->ns4__TimeEntryData::description);
	soap_serialize_PointerTotime(soap, &this->ns4__TimeEntryData::endTime);
	soap_serialize_PointerTotime(soap, &this->ns4__TimeEntryData::reportDate);
	soap_serialize_PointerTotime(soap, &this->ns4__TimeEntryData::startTime);
}

int ns4__TimeEntryData::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns4__TimeEntryData);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns4__TimeEntryData::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__TimeEntryData(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__TimeEntryData(struct soap *soap, const char *tag, int id, const ns4__TimeEntryData *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__TimeEntryData), type))
		return soap->error;
	if (soap_out_int(soap, "id", -1, &(a->ns4__TimeEntryData::id), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "lastUpdateTime", -1, &(a->ns4__TimeEntryData::lastUpdateTime), ""))
		return soap->error;
	if (soap_out_string(soap, "description", -1, &(a->ns4__TimeEntryData::description), ""))
		return soap->error;
	if (soap_out_double(soap, "duration", -1, &(a->ns4__TimeEntryData::duration), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "endTime", -1, &(a->ns4__TimeEntryData::endTime), ""))
		return soap->error;
	if (soap_out_int(soap, "person1Id", -1, &(a->ns4__TimeEntryData::person1Id), ""))
		return soap->error;
	if (soap_out_int(soap, "person2Id", -1, &(a->ns4__TimeEntryData::person2Id), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "reportDate", -1, &(a->ns4__TimeEntryData::reportDate), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "startTime", -1, &(a->ns4__TimeEntryData::startTime), ""))
		return soap->error;
	if (soap_out_int(soap, "taskId", -1, &(a->ns4__TimeEntryData::taskId), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns4__TimeEntryData::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__TimeEntryData(soap, this, tag, type);
}

SOAP_FMAC3 ns4__TimeEntryData * SOAP_FMAC4 soap_get_ns4__TimeEntryData(struct soap *soap, ns4__TimeEntryData *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__TimeEntryData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns4__TimeEntryData::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns4__TimeEntryData(soap, tag, this, type);
}

SOAP_FMAC3 ns4__TimeEntryData * SOAP_FMAC4 soap_in_ns4__TimeEntryData(struct soap *soap, const char *tag, ns4__TimeEntryData *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns4__TimeEntryData *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__TimeEntryData, sizeof(ns4__TimeEntryData), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns4__TimeEntryData)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns4__TimeEntryData *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_id1 = 1, soap_flag_lastUpdateTime1 = 1, soap_flag_description1 = 1, soap_flag_duration1 = 1, soap_flag_endTime1 = 1, soap_flag_person1Id1 = 1, soap_flag_person2Id1 = 1, soap_flag_reportDate1 = 1, soap_flag_startTime1 = 1, soap_flag_taskId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "id", &(a->ns4__TimeEntryData::id), "xsd:int"))
				{	soap_flag_id1--;
					continue;
				}
			if (soap_flag_lastUpdateTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "lastUpdateTime", &(a->ns4__TimeEntryData::lastUpdateTime), "xsd:dateTime"))
				{	soap_flag_lastUpdateTime1--;
					continue;
				}
			if (soap_flag_description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "description", &(a->ns4__TimeEntryData::description), "xsd:string"))
				{	soap_flag_description1--;
					continue;
				}
			if (soap_flag_duration1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "duration", &(a->ns4__TimeEntryData::duration), "xsd:double"))
				{	soap_flag_duration1--;
					continue;
				}
			if (soap_flag_endTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "endTime", &(a->ns4__TimeEntryData::endTime), "xsd:dateTime"))
				{	soap_flag_endTime1--;
					continue;
				}
			if (soap_flag_person1Id1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "person1Id", &(a->ns4__TimeEntryData::person1Id), "xsd:int"))
				{	soap_flag_person1Id1--;
					continue;
				}
			if (soap_flag_person2Id1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "person2Id", &(a->ns4__TimeEntryData::person2Id), "xsd:int"))
				{	soap_flag_person2Id1--;
					continue;
				}
			if (soap_flag_reportDate1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "reportDate", &(a->ns4__TimeEntryData::reportDate), "xsd:dateTime"))
				{	soap_flag_reportDate1--;
					continue;
				}
			if (soap_flag_startTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "startTime", &(a->ns4__TimeEntryData::startTime), "xsd:dateTime"))
				{	soap_flag_startTime1--;
					continue;
				}
			if (soap_flag_taskId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "taskId", &(a->ns4__TimeEntryData::taskId), "xsd:int"))
				{	soap_flag_taskId1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns4__TimeEntryData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__TimeEntryData, 0, sizeof(ns4__TimeEntryData), 0, soap_copy_ns4__TimeEntryData);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id1 > 0 || soap_flag_duration1 > 0 || soap_flag_person1Id1 > 0 || soap_flag_person2Id1 > 0 || soap_flag_taskId1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 ns4__TimeEntryData * SOAP_FMAC6 soap_new_ns4__TimeEntryData(struct soap *soap, int n)
{	return soap_instantiate_ns4__TimeEntryData(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns4__TimeEntryData(struct soap *soap, ns4__TimeEntryData *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns4__TimeEntryData * SOAP_FMAC4 soap_instantiate_ns4__TimeEntryData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__TimeEntryData(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns4__TimeEntryData, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns4__TimeEntryData;
		if (size)
			*size = sizeof(ns4__TimeEntryData);
	}
	else
	{	cp->ptr = (void*)new ns4__TimeEntryData[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns4__TimeEntryData);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns4__TimeEntryData*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns4__TimeEntryData(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns4__TimeEntryData %p -> %p\n", q, p));
	*(ns4__TimeEntryData*)p = *(ns4__TimeEntryData*)q;
}

void ns4__PersonData::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_int(soap, &this->ns4__PersonData::id);
	this->ns4__PersonData::lastUpdateTime = NULL;
	soap_default_string(soap, &this->ns4__PersonData::email);
	soap_default_string(soap, &this->ns4__PersonData::initials);
	soap_default_string(soap, &this->ns4__PersonData::name);
	soap_default_string(soap, &this->ns4__PersonData::phone);
	soap_default_string(soap, &this->ns4__PersonData::userId);
}

void ns4__PersonData::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTotime(soap, &this->ns4__PersonData::lastUpdateTime);
	soap_serialize_string(soap, &this->ns4__PersonData::email);
	soap_serialize_string(soap, &this->ns4__PersonData::initials);
	soap_serialize_string(soap, &this->ns4__PersonData::name);
	soap_serialize_string(soap, &this->ns4__PersonData::phone);
	soap_serialize_string(soap, &this->ns4__PersonData::userId);
}

int ns4__PersonData::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns4__PersonData);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns4__PersonData::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__PersonData(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__PersonData(struct soap *soap, const char *tag, int id, const ns4__PersonData *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__PersonData), type))
		return soap->error;
	if (soap_out_int(soap, "id", -1, &(a->ns4__PersonData::id), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "lastUpdateTime", -1, &(a->ns4__PersonData::lastUpdateTime), ""))
		return soap->error;
	if (soap_out_string(soap, "email", -1, &(a->ns4__PersonData::email), ""))
		return soap->error;
	if (soap_out_string(soap, "initials", -1, &(a->ns4__PersonData::initials), ""))
		return soap->error;
	if (soap_out_string(soap, "name", -1, &(a->ns4__PersonData::name), ""))
		return soap->error;
	if (soap_out_string(soap, "phone", -1, &(a->ns4__PersonData::phone), ""))
		return soap->error;
	if (soap_out_string(soap, "userId", -1, &(a->ns4__PersonData::userId), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns4__PersonData::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__PersonData(soap, this, tag, type);
}

SOAP_FMAC3 ns4__PersonData * SOAP_FMAC4 soap_get_ns4__PersonData(struct soap *soap, ns4__PersonData *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__PersonData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns4__PersonData::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns4__PersonData(soap, tag, this, type);
}

SOAP_FMAC3 ns4__PersonData * SOAP_FMAC4 soap_in_ns4__PersonData(struct soap *soap, const char *tag, ns4__PersonData *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns4__PersonData *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__PersonData, sizeof(ns4__PersonData), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns4__PersonData)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns4__PersonData *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_id1 = 1, soap_flag_lastUpdateTime1 = 1, soap_flag_email1 = 1, soap_flag_initials1 = 1, soap_flag_name1 = 1, soap_flag_phone1 = 1, soap_flag_userId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "id", &(a->ns4__PersonData::id), "xsd:int"))
				{	soap_flag_id1--;
					continue;
				}
			if (soap_flag_lastUpdateTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "lastUpdateTime", &(a->ns4__PersonData::lastUpdateTime), "xsd:dateTime"))
				{	soap_flag_lastUpdateTime1--;
					continue;
				}
			if (soap_flag_email1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "email", &(a->ns4__PersonData::email), "xsd:string"))
				{	soap_flag_email1--;
					continue;
				}
			if (soap_flag_initials1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "initials", &(a->ns4__PersonData::initials), "xsd:string"))
				{	soap_flag_initials1--;
					continue;
				}
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "name", &(a->ns4__PersonData::name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap_flag_phone1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "phone", &(a->ns4__PersonData::phone), "xsd:string"))
				{	soap_flag_phone1--;
					continue;
				}
			if (soap_flag_userId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "userId", &(a->ns4__PersonData::userId), "xsd:string"))
				{	soap_flag_userId1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns4__PersonData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__PersonData, 0, sizeof(ns4__PersonData), 0, soap_copy_ns4__PersonData);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 ns4__PersonData * SOAP_FMAC6 soap_new_ns4__PersonData(struct soap *soap, int n)
{	return soap_instantiate_ns4__PersonData(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns4__PersonData(struct soap *soap, ns4__PersonData *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns4__PersonData * SOAP_FMAC4 soap_instantiate_ns4__PersonData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__PersonData(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns4__PersonData, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns4__PersonData;
		if (size)
			*size = sizeof(ns4__PersonData);
	}
	else
	{	cp->ptr = (void*)new ns4__PersonData[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns4__PersonData);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns4__PersonData*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns4__PersonData(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns4__PersonData %p -> %p\n", q, p));
	*(ns4__PersonData*)p = *(ns4__PersonData*)q;
}

void ns4__UserStoryData::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_int(soap, &this->ns4__UserStoryData::id);
	this->ns4__UserStoryData::lastUpdateTime = NULL;
	soap_default_double(soap, &this->ns4__UserStoryData::actualHours);
	soap_default_double(soap, &this->ns4__UserStoryData::adjustedEstimatedHours);
	soap_default_bool(soap, &this->ns4__UserStoryData::completed);
	soap_default_int(soap, &this->ns4__UserStoryData::customerId);
	soap_default_string(soap, &this->ns4__UserStoryData::description);
	soap_default_string(soap, &this->ns4__UserStoryData::dispositionName);
	soap_default_double(soap, &this->ns4__UserStoryData::estimatedHours);
	soap_default_double(soap, &this->ns4__UserStoryData::estimatedOriginalHours);
	soap_default_int(soap, &this->ns4__UserStoryData::iterationId);
	soap_default_string(soap, &this->ns4__UserStoryData::name);
	soap_default_double(soap, &this->ns4__UserStoryData::postponedHours);
	soap_default_int(soap, &this->ns4__UserStoryData::priority);
	soap_default_double(soap, &this->ns4__UserStoryData::remainingHours);
	soap_default_int(soap, &this->ns4__UserStoryData::trackerId);
}

void ns4__UserStoryData::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTotime(soap, &this->ns4__UserStoryData::lastUpdateTime);
	soap_serialize_string(soap, &this->ns4__UserStoryData::description);
	soap_serialize_string(soap, &this->ns4__UserStoryData::dispositionName);
	soap_serialize_string(soap, &this->ns4__UserStoryData::name);
}

int ns4__UserStoryData::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns4__UserStoryData);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns4__UserStoryData::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__UserStoryData(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__UserStoryData(struct soap *soap, const char *tag, int id, const ns4__UserStoryData *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__UserStoryData), type))
		return soap->error;
	if (soap_out_int(soap, "id", -1, &(a->ns4__UserStoryData::id), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "lastUpdateTime", -1, &(a->ns4__UserStoryData::lastUpdateTime), ""))
		return soap->error;
	if (soap_out_double(soap, "actualHours", -1, &(a->ns4__UserStoryData::actualHours), ""))
		return soap->error;
	if (soap_out_double(soap, "adjustedEstimatedHours", -1, &(a->ns4__UserStoryData::adjustedEstimatedHours), ""))
		return soap->error;
	if (soap_out_bool(soap, "completed", -1, &(a->ns4__UserStoryData::completed), ""))
		return soap->error;
	if (soap_out_int(soap, "customerId", -1, &(a->ns4__UserStoryData::customerId), ""))
		return soap->error;
	if (soap_out_string(soap, "description", -1, &(a->ns4__UserStoryData::description), ""))
		return soap->error;
	if (soap_out_string(soap, "dispositionName", -1, &(a->ns4__UserStoryData::dispositionName), ""))
		return soap->error;
	if (soap_out_double(soap, "estimatedHours", -1, &(a->ns4__UserStoryData::estimatedHours), ""))
		return soap->error;
	if (soap_out_double(soap, "estimatedOriginalHours", -1, &(a->ns4__UserStoryData::estimatedOriginalHours), ""))
		return soap->error;
	if (soap_out_int(soap, "iterationId", -1, &(a->ns4__UserStoryData::iterationId), ""))
		return soap->error;
	if (soap_out_string(soap, "name", -1, &(a->ns4__UserStoryData::name), ""))
		return soap->error;
	if (soap_out_double(soap, "postponedHours", -1, &(a->ns4__UserStoryData::postponedHours), ""))
		return soap->error;
	if (soap_out_int(soap, "priority", -1, &(a->ns4__UserStoryData::priority), ""))
		return soap->error;
	if (soap_out_double(soap, "remainingHours", -1, &(a->ns4__UserStoryData::remainingHours), ""))
		return soap->error;
	if (soap_out_int(soap, "trackerId", -1, &(a->ns4__UserStoryData::trackerId), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns4__UserStoryData::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__UserStoryData(soap, this, tag, type);
}

SOAP_FMAC3 ns4__UserStoryData * SOAP_FMAC4 soap_get_ns4__UserStoryData(struct soap *soap, ns4__UserStoryData *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__UserStoryData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns4__UserStoryData::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns4__UserStoryData(soap, tag, this, type);
}

SOAP_FMAC3 ns4__UserStoryData * SOAP_FMAC4 soap_in_ns4__UserStoryData(struct soap *soap, const char *tag, ns4__UserStoryData *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns4__UserStoryData *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__UserStoryData, sizeof(ns4__UserStoryData), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns4__UserStoryData)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns4__UserStoryData *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_id1 = 1, soap_flag_lastUpdateTime1 = 1, soap_flag_actualHours1 = 1, soap_flag_adjustedEstimatedHours1 = 1, soap_flag_completed1 = 1, soap_flag_customerId1 = 1, soap_flag_description1 = 1, soap_flag_dispositionName1 = 1, soap_flag_estimatedHours1 = 1, soap_flag_estimatedOriginalHours1 = 1, soap_flag_iterationId1 = 1, soap_flag_name1 = 1, soap_flag_postponedHours1 = 1, soap_flag_priority1 = 1, soap_flag_remainingHours1 = 1, soap_flag_trackerId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "id", &(a->ns4__UserStoryData::id), "xsd:int"))
				{	soap_flag_id1--;
					continue;
				}
			if (soap_flag_lastUpdateTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "lastUpdateTime", &(a->ns4__UserStoryData::lastUpdateTime), "xsd:dateTime"))
				{	soap_flag_lastUpdateTime1--;
					continue;
				}
			if (soap_flag_actualHours1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "actualHours", &(a->ns4__UserStoryData::actualHours), "xsd:double"))
				{	soap_flag_actualHours1--;
					continue;
				}
			if (soap_flag_adjustedEstimatedHours1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "adjustedEstimatedHours", &(a->ns4__UserStoryData::adjustedEstimatedHours), "xsd:double"))
				{	soap_flag_adjustedEstimatedHours1--;
					continue;
				}
			if (soap_flag_completed1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "completed", &(a->ns4__UserStoryData::completed), "xsd:boolean"))
				{	soap_flag_completed1--;
					continue;
				}
			if (soap_flag_customerId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "customerId", &(a->ns4__UserStoryData::customerId), "xsd:int"))
				{	soap_flag_customerId1--;
					continue;
				}
			if (soap_flag_description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "description", &(a->ns4__UserStoryData::description), "xsd:string"))
				{	soap_flag_description1--;
					continue;
				}
			if (soap_flag_dispositionName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "dispositionName", &(a->ns4__UserStoryData::dispositionName), "xsd:string"))
				{	soap_flag_dispositionName1--;
					continue;
				}
			if (soap_flag_estimatedHours1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "estimatedHours", &(a->ns4__UserStoryData::estimatedHours), "xsd:double"))
				{	soap_flag_estimatedHours1--;
					continue;
				}
			if (soap_flag_estimatedOriginalHours1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "estimatedOriginalHours", &(a->ns4__UserStoryData::estimatedOriginalHours), "xsd:double"))
				{	soap_flag_estimatedOriginalHours1--;
					continue;
				}
			if (soap_flag_iterationId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "iterationId", &(a->ns4__UserStoryData::iterationId), "xsd:int"))
				{	soap_flag_iterationId1--;
					continue;
				}
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "name", &(a->ns4__UserStoryData::name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap_flag_postponedHours1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "postponedHours", &(a->ns4__UserStoryData::postponedHours), "xsd:double"))
				{	soap_flag_postponedHours1--;
					continue;
				}
			if (soap_flag_priority1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "priority", &(a->ns4__UserStoryData::priority), "xsd:int"))
				{	soap_flag_priority1--;
					continue;
				}
			if (soap_flag_remainingHours1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "remainingHours", &(a->ns4__UserStoryData::remainingHours), "xsd:double"))
				{	soap_flag_remainingHours1--;
					continue;
				}
			if (soap_flag_trackerId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "trackerId", &(a->ns4__UserStoryData::trackerId), "xsd:int"))
				{	soap_flag_trackerId1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns4__UserStoryData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__UserStoryData, 0, sizeof(ns4__UserStoryData), 0, soap_copy_ns4__UserStoryData);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id1 > 0 || soap_flag_actualHours1 > 0 || soap_flag_adjustedEstimatedHours1 > 0 || soap_flag_completed1 > 0 || soap_flag_customerId1 > 0 || soap_flag_estimatedHours1 > 0 || soap_flag_estimatedOriginalHours1 > 0 || soap_flag_iterationId1 > 0 || soap_flag_postponedHours1 > 0 || soap_flag_priority1 > 0 || soap_flag_remainingHours1 > 0 || soap_flag_trackerId1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 ns4__UserStoryData * SOAP_FMAC6 soap_new_ns4__UserStoryData(struct soap *soap, int n)
{	return soap_instantiate_ns4__UserStoryData(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns4__UserStoryData(struct soap *soap, ns4__UserStoryData *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns4__UserStoryData * SOAP_FMAC4 soap_instantiate_ns4__UserStoryData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__UserStoryData(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns4__UserStoryData, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns4__UserStoryData;
		if (size)
			*size = sizeof(ns4__UserStoryData);
	}
	else
	{	cp->ptr = (void*)new ns4__UserStoryData[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns4__UserStoryData);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns4__UserStoryData*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns4__UserStoryData(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns4__UserStoryData %p -> %p\n", q, p));
	*(ns4__UserStoryData*)p = *(ns4__UserStoryData*)q;
}

void ns4__ProjectData::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_int(soap, &this->ns4__ProjectData::id);
	this->ns4__ProjectData::lastUpdateTime = NULL;
	soap_default_string(soap, &this->ns4__ProjectData::description);
	soap_default_string(soap, &this->ns4__ProjectData::name);
}

void ns4__ProjectData::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTotime(soap, &this->ns4__ProjectData::lastUpdateTime);
	soap_serialize_string(soap, &this->ns4__ProjectData::description);
	soap_serialize_string(soap, &this->ns4__ProjectData::name);
}

int ns4__ProjectData::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns4__ProjectData);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns4__ProjectData::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__ProjectData(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__ProjectData(struct soap *soap, const char *tag, int id, const ns4__ProjectData *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__ProjectData), type))
		return soap->error;
	if (soap_out_int(soap, "id", -1, &(a->ns4__ProjectData::id), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "lastUpdateTime", -1, &(a->ns4__ProjectData::lastUpdateTime), ""))
		return soap->error;
	if (soap_out_string(soap, "description", -1, &(a->ns4__ProjectData::description), ""))
		return soap->error;
	if (soap_out_string(soap, "name", -1, &(a->ns4__ProjectData::name), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns4__ProjectData::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__ProjectData(soap, this, tag, type);
}

SOAP_FMAC3 ns4__ProjectData * SOAP_FMAC4 soap_get_ns4__ProjectData(struct soap *soap, ns4__ProjectData *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__ProjectData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns4__ProjectData::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns4__ProjectData(soap, tag, this, type);
}

SOAP_FMAC3 ns4__ProjectData * SOAP_FMAC4 soap_in_ns4__ProjectData(struct soap *soap, const char *tag, ns4__ProjectData *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns4__ProjectData *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__ProjectData, sizeof(ns4__ProjectData), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns4__ProjectData)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns4__ProjectData *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_id1 = 1, soap_flag_lastUpdateTime1 = 1, soap_flag_description1 = 1, soap_flag_name1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "id", &(a->ns4__ProjectData::id), "xsd:int"))
				{	soap_flag_id1--;
					continue;
				}
			if (soap_flag_lastUpdateTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "lastUpdateTime", &(a->ns4__ProjectData::lastUpdateTime), "xsd:dateTime"))
				{	soap_flag_lastUpdateTime1--;
					continue;
				}
			if (soap_flag_description1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "description", &(a->ns4__ProjectData::description), "xsd:string"))
				{	soap_flag_description1--;
					continue;
				}
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "name", &(a->ns4__ProjectData::name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns4__ProjectData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__ProjectData, 0, sizeof(ns4__ProjectData), 0, soap_copy_ns4__ProjectData);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 ns4__ProjectData * SOAP_FMAC6 soap_new_ns4__ProjectData(struct soap *soap, int n)
{	return soap_instantiate_ns4__ProjectData(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns4__ProjectData(struct soap *soap, ns4__ProjectData *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns4__ProjectData * SOAP_FMAC4 soap_instantiate_ns4__ProjectData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__ProjectData(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns4__ProjectData, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns4__ProjectData;
		if (size)
			*size = sizeof(ns4__ProjectData);
	}
	else
	{	cp->ptr = (void*)new ns4__ProjectData[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns4__ProjectData);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns4__ProjectData*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns4__ProjectData(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns4__ProjectData %p -> %p\n", q, p));
	*(ns4__ProjectData*)p = *(ns4__ProjectData*)q;
}

void ns4__NoteData::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	soap_default_int(soap, &this->ns4__NoteData::id);
	this->ns4__NoteData::lastUpdateTime = NULL;
	soap_default_int(soap, &this->ns4__NoteData::attachedToId);
	soap_default_int(soap, &this->ns4__NoteData::attachmentId);
	soap_default_int(soap, &this->ns4__NoteData::authorId);
	soap_default_string(soap, &this->ns4__NoteData::body);
	soap_default_string(soap, &this->ns4__NoteData::subject);
	this->ns4__NoteData::submissionTime = NULL;
}

void ns4__NoteData::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTotime(soap, &this->ns4__NoteData::lastUpdateTime);
	soap_serialize_string(soap, &this->ns4__NoteData::body);
	soap_serialize_string(soap, &this->ns4__NoteData::subject);
	soap_serialize_PointerTotime(soap, &this->ns4__NoteData::submissionTime);
}

int ns4__NoteData::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns4__NoteData);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns4__NoteData::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns4__NoteData(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns4__NoteData(struct soap *soap, const char *tag, int id, const ns4__NoteData *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns4__NoteData), type))
		return soap->error;
	if (soap_out_int(soap, "id", -1, &(a->ns4__NoteData::id), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "lastUpdateTime", -1, &(a->ns4__NoteData::lastUpdateTime), ""))
		return soap->error;
	if (soap_out_int(soap, "attachedToId", -1, &(a->ns4__NoteData::attachedToId), ""))
		return soap->error;
	if (soap_out_int(soap, "attachmentId", -1, &(a->ns4__NoteData::attachmentId), ""))
		return soap->error;
	if (soap_out_int(soap, "authorId", -1, &(a->ns4__NoteData::authorId), ""))
		return soap->error;
	if (soap_out_string(soap, "body", -1, &(a->ns4__NoteData::body), ""))
		return soap->error;
	if (soap_out_string(soap, "subject", -1, &(a->ns4__NoteData::subject), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "submissionTime", -1, &(a->ns4__NoteData::submissionTime), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns4__NoteData::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns4__NoteData(soap, this, tag, type);
}

SOAP_FMAC3 ns4__NoteData * SOAP_FMAC4 soap_get_ns4__NoteData(struct soap *soap, ns4__NoteData *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns4__NoteData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns4__NoteData::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns4__NoteData(soap, tag, this, type);
}

SOAP_FMAC3 ns4__NoteData * SOAP_FMAC4 soap_in_ns4__NoteData(struct soap *soap, const char *tag, ns4__NoteData *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns4__NoteData *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns4__NoteData, sizeof(ns4__NoteData), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns4__NoteData)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns4__NoteData *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_id1 = 1, soap_flag_lastUpdateTime1 = 1, soap_flag_attachedToId1 = 1, soap_flag_attachmentId1 = 1, soap_flag_authorId1 = 1, soap_flag_body1 = 1, soap_flag_subject1 = 1, soap_flag_submissionTime1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "id", &(a->ns4__NoteData::id), "xsd:int"))
				{	soap_flag_id1--;
					continue;
				}
			if (soap_flag_lastUpdateTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "lastUpdateTime", &(a->ns4__NoteData::lastUpdateTime), "xsd:dateTime"))
				{	soap_flag_lastUpdateTime1--;
					continue;
				}
			if (soap_flag_attachedToId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "attachedToId", &(a->ns4__NoteData::attachedToId), "xsd:int"))
				{	soap_flag_attachedToId1--;
					continue;
				}
			if (soap_flag_attachmentId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "attachmentId", &(a->ns4__NoteData::attachmentId), "xsd:int"))
				{	soap_flag_attachmentId1--;
					continue;
				}
			if (soap_flag_authorId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "authorId", &(a->ns4__NoteData::authorId), "xsd:int"))
				{	soap_flag_authorId1--;
					continue;
				}
			if (soap_flag_body1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "body", &(a->ns4__NoteData::body), "xsd:string"))
				{	soap_flag_body1--;
					continue;
				}
			if (soap_flag_subject1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "subject", &(a->ns4__NoteData::subject), "xsd:string"))
				{	soap_flag_subject1--;
					continue;
				}
			if (soap_flag_submissionTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "submissionTime", &(a->ns4__NoteData::submissionTime), "xsd:dateTime"))
				{	soap_flag_submissionTime1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns4__NoteData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns4__NoteData, 0, sizeof(ns4__NoteData), 0, soap_copy_ns4__NoteData);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id1 > 0 || soap_flag_attachedToId1 > 0 || soap_flag_attachmentId1 > 0 || soap_flag_authorId1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 ns4__NoteData * SOAP_FMAC6 soap_new_ns4__NoteData(struct soap *soap, int n)
{	return soap_instantiate_ns4__NoteData(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns4__NoteData(struct soap *soap, ns4__NoteData *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns4__NoteData * SOAP_FMAC4 soap_instantiate_ns4__NoteData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns4__NoteData(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns4__NoteData, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns4__NoteData;
		if (size)
			*size = sizeof(ns4__NoteData);
	}
	else
	{	cp->ptr = (void*)new ns4__NoteData[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns4__NoteData);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns4__NoteData*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns4__NoteData(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns4__NoteData %p -> %p\n", q, p));
	*(ns4__NoteData*)p = *(ns4__NoteData*)q;
}

void ns3__DomainData::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns3__DomainData::id);
	this->ns3__DomainData::lastUpdateTime = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns3__DomainData::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTotime(soap, &this->ns3__DomainData::lastUpdateTime);
	/* transient soap skipped */
}

int ns3__DomainData::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns3__DomainData);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns3__DomainData::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns3__DomainData(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns3__DomainData(struct soap *soap, const char *tag, int id, const ns3__DomainData *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns3__DomainData), "ns3:DomainData"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_int(soap, "id", -1, &(a->ns3__DomainData::id), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "lastUpdateTime", -1, &(a->ns3__DomainData::lastUpdateTime), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns3__DomainData::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns3__DomainData(soap, this, tag, type);
}

SOAP_FMAC3 ns3__DomainData * SOAP_FMAC4 soap_get_ns3__DomainData(struct soap *soap, ns3__DomainData *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns3__DomainData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns3__DomainData::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns3__DomainData(soap, tag, this, type);
}

SOAP_FMAC3 ns3__DomainData * SOAP_FMAC4 soap_in_ns3__DomainData(struct soap *soap, const char *tag, ns3__DomainData *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns3__DomainData *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns3__DomainData, sizeof(ns3__DomainData), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns3__DomainData)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns3__DomainData *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag___item2 = 1, soap_flag_id1 = 1, soap_flag_lastUpdateTime1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_id1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "id", &(a->ns3__DomainData::id), "xsd:int"))
				{	soap_flag_id1--;
					continue;
				}
			if (soap_flag_lastUpdateTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "lastUpdateTime", &(a->ns3__DomainData::lastUpdateTime), "xsd:dateTime"))
				{	soap_flag_lastUpdateTime1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns3__DomainData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns3__DomainData, 0, sizeof(ns3__DomainData), 0, soap_copy_ns3__DomainData);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 ns3__DomainData * SOAP_FMAC6 soap_new_ns3__DomainData(struct soap *soap, int n)
{	return soap_instantiate_ns3__DomainData(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns3__DomainData(struct soap *soap, ns3__DomainData *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns3__DomainData * SOAP_FMAC4 soap_instantiate_ns3__DomainData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns3__DomainData(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns3__DomainData, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns3__DomainData;
		if (size)
			*size = sizeof(ns3__DomainData);
		((ns3__DomainData*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns3__DomainData[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns3__DomainData);
		for (int i = 0; i < n; i++)
			((ns3__DomainData*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns3__DomainData*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns3__DomainData(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns3__DomainData %p -> %p\n", q, p));
	*(ns3__DomainData*)p = *(ns3__DomainData*)q;
}

void ns2__Map::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__Map::__sizeitem = 0;
	this->ns2__Map::item = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns2__Map::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	if (this->ns2__Map::item)
	{	int i;
		for (i = 0; i < this->ns2__Map::__sizeitem; i++)
		{
			soap_serialize_PointerTons2__mapItem(soap, this->ns2__Map::item + i);
		}
	}
	/* transient soap skipped */
}

int ns2__Map::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__Map);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns2__Map::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__Map(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__Map(struct soap *soap, const char *tag, int id, const ns2__Map *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__Map), "ns2:Map"))
		return soap->error;
	/* transient soap skipped */
	if (a->ns2__Map::item)
	{	int i;
		for (i = 0; i < a->ns2__Map::__sizeitem; i++)
			if (soap_out_PointerTons2__mapItem(soap, "item", -1, a->ns2__Map::item + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *ns2__Map::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__Map(soap, this, tag, type);
}

SOAP_FMAC3 ns2__Map * SOAP_FMAC4 soap_get_ns2__Map(struct soap *soap, ns2__Map *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__Map(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns2__Map::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__Map(soap, tag, this, type);
}

SOAP_FMAC3 ns2__Map * SOAP_FMAC4 soap_in_ns2__Map(struct soap *soap, const char *tag, ns2__Map *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__Map *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__Map, sizeof(ns2__Map), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__Map)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__Map *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag___item2 = 1, soap_flag_item1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_item1 && soap->error == SOAP_TAG_MISMATCH)
			{	ns2__mapItem **p;
				soap_new_block(soap);
				for (a->ns2__Map::__sizeitem = 0; !soap_element_begin_in(soap, "item", 1, NULL); a->ns2__Map::__sizeitem++)
				{	p = (ns2__mapItem **)soap_push_block(soap, sizeof(ns2__mapItem *));
					if (!p)
						return NULL;
					*p = NULL;
					soap_revert(soap);
					if (!soap_in_PointerTons2__mapItem(soap, "item", p, "ns2:mapItem"))
						break;
					soap_flag_item1 = 0;
				}
				a->ns2__Map::item = (ns2__mapItem **)soap_save_block(soap, NULL, 1);
				if (!soap_flag_item1 && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__Map *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__Map, 0, sizeof(ns2__Map), 0, soap_copy_ns2__Map);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns2__Map * SOAP_FMAC6 soap_new_ns2__Map(struct soap *soap, int n)
{	return soap_instantiate_ns2__Map(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns2__Map(struct soap *soap, ns2__Map *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns2__Map * SOAP_FMAC4 soap_instantiate_ns2__Map(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__Map(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__Map, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns2__Map;
		if (size)
			*size = sizeof(ns2__Map);
		((ns2__Map*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns2__Map[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__Map);
		for (int i = 0; i < n; i++)
			((ns2__Map*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__Map*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__Map(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__Map %p -> %p\n", q, p));
	*(ns2__Map*)p = *(ns2__Map*)q;
}

void ns2__mapItem::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__mapItem::key = NULL;
	this->ns2__mapItem::value = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns2__mapItem::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToxsd__anyType(soap, &this->ns2__mapItem::key);
	soap_serialize_PointerToxsd__anyType(soap, &this->ns2__mapItem::value);
	/* transient soap skipped */
}

int ns2__mapItem::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__mapItem);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns2__mapItem::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__mapItem(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__mapItem(struct soap *soap, const char *tag, int id, const ns2__mapItem *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__mapItem), "ns2:mapItem"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerToxsd__anyType(soap, "key", -1, &(a->ns2__mapItem::key), ""))
		return soap->error;
	if (soap_out_PointerToxsd__anyType(soap, "value", -1, &(a->ns2__mapItem::value), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns2__mapItem::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__mapItem(soap, this, tag, type);
}

SOAP_FMAC3 ns2__mapItem * SOAP_FMAC4 soap_get_ns2__mapItem(struct soap *soap, ns2__mapItem *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__mapItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns2__mapItem::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__mapItem(soap, tag, this, type);
}

SOAP_FMAC3 ns2__mapItem * SOAP_FMAC4 soap_in_ns2__mapItem(struct soap *soap, const char *tag, ns2__mapItem *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__mapItem *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__mapItem, sizeof(ns2__mapItem), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__mapItem)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__mapItem *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag___item2 = 1, soap_flag_key1 = 1, soap_flag_value1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_key1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__anyType(soap, "key", &(a->ns2__mapItem::key), "xsd:anyType"))
				{	soap_flag_key1--;
					continue;
				}
			if (soap_flag_value1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__anyType(soap, "value", &(a->ns2__mapItem::value), "xsd:anyType"))
				{	soap_flag_value1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__mapItem *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__mapItem, 0, sizeof(ns2__mapItem), 0, soap_copy_ns2__mapItem);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns2__mapItem * SOAP_FMAC6 soap_new_ns2__mapItem(struct soap *soap, int n)
{	return soap_instantiate_ns2__mapItem(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns2__mapItem(struct soap *soap, ns2__mapItem *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns2__mapItem * SOAP_FMAC4 soap_instantiate_ns2__mapItem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__mapItem(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__mapItem, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns2__mapItem;
		if (size)
			*size = sizeof(ns2__mapItem);
		((ns2__mapItem*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns2__mapItem[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns2__mapItem);
		for (int i = 0; i < n; i++)
			((ns2__mapItem*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns2__mapItem*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__mapItem(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__mapItem %p -> %p\n", q, p));
	*(ns2__mapItem*)p = *(ns2__mapItem*)q;
}

void xsd__int::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->xsd__int::__item);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void xsd__int::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int xsd__int::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__int);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int xsd__int::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__int(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__int(struct soap *soap, const char *tag, int id, const xsd__int *a, const char *type)
{
	return soap_out_int(soap, tag, id, &(a->xsd__int::__item), "xsd:int");
}

void *xsd__int::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__int(soap, this, tag, type);
}

SOAP_FMAC3 xsd__int * SOAP_FMAC4 soap_get_xsd__int(struct soap *soap, xsd__int *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *xsd__int::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__int(soap, tag, this, type);
}

SOAP_FMAC3 xsd__int * SOAP_FMAC4 soap_in_xsd__int(struct soap *soap, const char *tag, xsd__int *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__int *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__int, sizeof(xsd__int), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__int)
			return (xsd__int *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_int(soap, tag, &(a->xsd__int::__item), "xsd:int"))
		return NULL;
	return a;
}

SOAP_FMAC5 xsd__int * SOAP_FMAC6 soap_new_xsd__int(struct soap *soap, int n)
{	return soap_instantiate_xsd__int(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__int(struct soap *soap, xsd__int *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 xsd__int * SOAP_FMAC4 soap_instantiate_xsd__int(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__int(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__int, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new xsd__int;
		if (size)
			*size = sizeof(xsd__int);
		((xsd__int*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new xsd__int[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(xsd__int);
		for (int i = 0; i < n; i++)
			((xsd__int*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__int*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__int(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__int %p -> %p\n", q, p));
	*(xsd__int*)p = *(xsd__int*)q;
}

void xsd__double::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_double(soap, &this->xsd__double::__item);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void xsd__double::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int xsd__double::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__double);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int xsd__double::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__double(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__double(struct soap *soap, const char *tag, int id, const xsd__double *a, const char *type)
{
	return soap_out_double(soap, tag, id, &(a->xsd__double::__item), "xsd:double");
}

void *xsd__double::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__double(soap, this, tag, type);
}

SOAP_FMAC3 xsd__double * SOAP_FMAC4 soap_get_xsd__double(struct soap *soap, xsd__double *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__double(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *xsd__double::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__double(soap, tag, this, type);
}

SOAP_FMAC3 xsd__double * SOAP_FMAC4 soap_in_xsd__double(struct soap *soap, const char *tag, xsd__double *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__double *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__double, sizeof(xsd__double), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__double)
			return (xsd__double *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_double(soap, tag, &(a->xsd__double::__item), "xsd:double"))
		return NULL;
	return a;
}

SOAP_FMAC5 xsd__double * SOAP_FMAC6 soap_new_xsd__double(struct soap *soap, int n)
{	return soap_instantiate_xsd__double(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__double(struct soap *soap, xsd__double *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 xsd__double * SOAP_FMAC4 soap_instantiate_xsd__double(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__double(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__double, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new xsd__double;
		if (size)
			*size = sizeof(xsd__double);
		((xsd__double*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new xsd__double[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(xsd__double);
		for (int i = 0; i < n; i++)
			((xsd__double*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__double*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__double(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__double %p -> %p\n", q, p));
	*(xsd__double*)p = *(xsd__double*)q;
}

void xsd__dateTime::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_time(soap, &this->xsd__dateTime::__item);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void xsd__dateTime::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->xsd__dateTime::__item, SOAP_TYPE_time);
	/* transient soap skipped */
}

int xsd__dateTime::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__dateTime);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int xsd__dateTime::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__dateTime(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__dateTime(struct soap *soap, const char *tag, int id, const xsd__dateTime *a, const char *type)
{
	return soap_out_time(soap, tag, id, &(a->xsd__dateTime::__item), "xsd:dateTime");
}

void *xsd__dateTime::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__dateTime(soap, this, tag, type);
}

SOAP_FMAC3 xsd__dateTime * SOAP_FMAC4 soap_get_xsd__dateTime(struct soap *soap, xsd__dateTime *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__dateTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *xsd__dateTime::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__dateTime(soap, tag, this, type);
}

SOAP_FMAC3 xsd__dateTime * SOAP_FMAC4 soap_in_xsd__dateTime(struct soap *soap, const char *tag, xsd__dateTime *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__dateTime *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__dateTime, sizeof(xsd__dateTime), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__dateTime)
			return (xsd__dateTime *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_time(soap, tag, &(a->xsd__dateTime::__item), "xsd:dateTime"))
		return NULL;
	return a;
}

SOAP_FMAC5 xsd__dateTime * SOAP_FMAC6 soap_new_xsd__dateTime(struct soap *soap, int n)
{	return soap_instantiate_xsd__dateTime(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__dateTime(struct soap *soap, xsd__dateTime *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 xsd__dateTime * SOAP_FMAC4 soap_instantiate_xsd__dateTime(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__dateTime(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__dateTime, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new xsd__dateTime;
		if (size)
			*size = sizeof(xsd__dateTime);
		((xsd__dateTime*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new xsd__dateTime[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(xsd__dateTime);
		for (int i = 0; i < n; i++)
			((xsd__dateTime*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__dateTime*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__dateTime(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__dateTime %p -> %p\n", q, p));
	*(xsd__dateTime*)p = *(xsd__dateTime*)q;
}

void xsd__boolean::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->xsd__boolean::__item);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void xsd__boolean::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int xsd__boolean::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__boolean);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int xsd__boolean::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__boolean(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__boolean(struct soap *soap, const char *tag, int id, const xsd__boolean *a, const char *type)
{
	return soap_out_bool(soap, tag, id, &(a->xsd__boolean::__item), "xsd:boolean");
}

void *xsd__boolean::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__boolean(soap, this, tag, type);
}

SOAP_FMAC3 xsd__boolean * SOAP_FMAC4 soap_get_xsd__boolean(struct soap *soap, xsd__boolean *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__boolean(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *xsd__boolean::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__boolean(soap, tag, this, type);
}

SOAP_FMAC3 xsd__boolean * SOAP_FMAC4 soap_in_xsd__boolean(struct soap *soap, const char *tag, xsd__boolean *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__boolean *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__boolean, sizeof(xsd__boolean), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__boolean)
			return (xsd__boolean *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_bool(soap, tag, &(a->xsd__boolean::__item), "xsd:boolean"))
		return NULL;
	return a;
}

SOAP_FMAC5 xsd__boolean * SOAP_FMAC6 soap_new_xsd__boolean(struct soap *soap, int n)
{	return soap_instantiate_xsd__boolean(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__boolean(struct soap *soap, xsd__boolean *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 xsd__boolean * SOAP_FMAC4 soap_instantiate_xsd__boolean(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__boolean(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__boolean, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new xsd__boolean;
		if (size)
			*size = sizeof(xsd__boolean);
		((xsd__boolean*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new xsd__boolean[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(xsd__boolean);
		for (int i = 0; i < n; i++)
			((xsd__boolean*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__boolean*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__boolean(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__boolean %p -> %p\n", q, p));
	*(xsd__boolean*)p = *(xsd__boolean*)q;
}

void xsd__anyType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void xsd__anyType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int xsd__anyType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__anyType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int xsd__anyType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__anyType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__anyType(struct soap *soap, const char *tag, int id, const xsd__anyType *a, const char *type)
{
	return soap_outliteral(soap, tag, &(a->xsd__anyType::__item), NULL);
}

void *xsd__anyType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__anyType(soap, this, tag, type);
}

SOAP_FMAC3 xsd__anyType * SOAP_FMAC4 soap_get_xsd__anyType(struct soap *soap, xsd__anyType *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__anyType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *xsd__anyType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__anyType(soap, tag, this, type);
}

SOAP_FMAC3 xsd__anyType * SOAP_FMAC4 soap_in_xsd__anyType(struct soap *soap, const char *tag, xsd__anyType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__anyType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__anyType, sizeof(xsd__anyType), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__anyType)
			return (xsd__anyType *)a->soap_in(soap, tag, type);
	}
	if (!soap_inliteral(soap, tag, &(a->xsd__anyType::__item)))
		return NULL;
	return a;
}

SOAP_FMAC5 xsd__anyType * SOAP_FMAC6 soap_new_xsd__anyType(struct soap *soap, int n)
{	return soap_instantiate_xsd__anyType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__anyType(struct soap *soap, xsd__anyType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 xsd__anyType * SOAP_FMAC4 soap_instantiate_xsd__anyType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__anyType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__anyType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "xsd:boolean"))
	{	cp->type = SOAP_TYPE_xsd__boolean;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__boolean;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(xsd__boolean);
			((xsd__boolean*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new xsd__boolean[n];
			if (size)
				*size = n * sizeof(xsd__boolean);
			for (int i = 0; i < n; i++)
				((xsd__boolean*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__boolean*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:dateTime"))
	{	cp->type = SOAP_TYPE_xsd__dateTime;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__dateTime;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(xsd__dateTime);
			((xsd__dateTime*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new xsd__dateTime[n];
			if (size)
				*size = n * sizeof(xsd__dateTime);
			for (int i = 0; i < n; i++)
				((xsd__dateTime*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__dateTime*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:double"))
	{	cp->type = SOAP_TYPE_xsd__double;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__double;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(xsd__double);
			((xsd__double*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new xsd__double[n];
			if (size)
				*size = n * sizeof(xsd__double);
			for (int i = 0; i < n; i++)
				((xsd__double*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__double*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:int"))
	{	cp->type = SOAP_TYPE_xsd__int;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__int;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(xsd__int);
			((xsd__int*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new xsd__int[n];
			if (size)
				*size = n * sizeof(xsd__int);
			for (int i = 0; i < n; i++)
				((xsd__int*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__int*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns2:mapItem"))
	{	cp->type = SOAP_TYPE_ns2__mapItem;
		if (n < 0)
		{	cp->ptr = (void*)new ns2__mapItem;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns2__mapItem);
			((ns2__mapItem*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns2__mapItem[n];
			if (size)
				*size = n * sizeof(ns2__mapItem);
			for (int i = 0; i < n; i++)
				((ns2__mapItem*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns2__mapItem*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns2:Map"))
	{	cp->type = SOAP_TYPE_ns2__Map;
		if (n < 0)
		{	cp->ptr = (void*)new ns2__Map;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns2__Map);
			((ns2__Map*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns2__Map[n];
			if (size)
				*size = n * sizeof(ns2__Map);
			for (int i = 0; i < n; i++)
				((ns2__Map*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns2__Map*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns3:DomainData"))
	{	cp->type = SOAP_TYPE_ns3__DomainData;
		if (n < 0)
		{	cp->ptr = (void*)new ns3__DomainData;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns3__DomainData);
			((ns3__DomainData*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns3__DomainData[n];
			if (size)
				*size = n * sizeof(ns3__DomainData);
			for (int i = 0; i < n; i++)
				((ns3__DomainData*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns3__DomainData*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns5:QueryException"))
	{	cp->type = SOAP_TYPE_ns5__QueryException;
		if (n < 0)
		{	cp->ptr = (void*)new ns5__QueryException;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns5__QueryException);
			((ns5__QueryException*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns5__QueryException[n];
			if (size)
				*size = n * sizeof(ns5__QueryException);
			for (int i = 0; i < n; i++)
				((ns5__QueryException*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns5__QueryException*)cp->ptr;
	}
	if (arrayType && !soap_match_tag(soap, arrayType, "ns4:IterationData"))
	{	cp->type = SOAP_TYPE_ArrayOf_USCOREtns1_USCOREIterationData;
		if (n < 0)
		{	cp->ptr = (void*)new ArrayOf_USCOREtns1_USCOREIterationData;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ArrayOf_USCOREtns1_USCOREIterationData);
			((ArrayOf_USCOREtns1_USCOREIterationData*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ArrayOf_USCOREtns1_USCOREIterationData[n];
			if (size)
				*size = n * sizeof(ArrayOf_USCOREtns1_USCOREIterationData);
			for (int i = 0; i < n; i++)
				((ArrayOf_USCOREtns1_USCOREIterationData*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ArrayOf_USCOREtns1_USCOREIterationData*)cp->ptr;
	}
	if (arrayType && !soap_match_tag(soap, arrayType, "ns4:UserStoryData"))
	{	cp->type = SOAP_TYPE_ArrayOf_USCOREtns1_USCOREUserStoryData;
		if (n < 0)
		{	cp->ptr = (void*)new ArrayOf_USCOREtns1_USCOREUserStoryData;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ArrayOf_USCOREtns1_USCOREUserStoryData);
			((ArrayOf_USCOREtns1_USCOREUserStoryData*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ArrayOf_USCOREtns1_USCOREUserStoryData[n];
			if (size)
				*size = n * sizeof(ArrayOf_USCOREtns1_USCOREUserStoryData);
			for (int i = 0; i < n; i++)
				((ArrayOf_USCOREtns1_USCOREUserStoryData*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ArrayOf_USCOREtns1_USCOREUserStoryData*)cp->ptr;
	}
	if (arrayType && !soap_match_tag(soap, arrayType, "ns4:TaskData"))
	{	cp->type = SOAP_TYPE_ArrayOf_USCOREtns1_USCORETaskData;
		if (n < 0)
		{	cp->ptr = (void*)new ArrayOf_USCOREtns1_USCORETaskData;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ArrayOf_USCOREtns1_USCORETaskData);
			((ArrayOf_USCOREtns1_USCORETaskData*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ArrayOf_USCOREtns1_USCORETaskData[n];
			if (size)
				*size = n * sizeof(ArrayOf_USCOREtns1_USCORETaskData);
			for (int i = 0; i < n; i++)
				((ArrayOf_USCOREtns1_USCORETaskData*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ArrayOf_USCOREtns1_USCORETaskData*)cp->ptr;
	}
	if (arrayType && !soap_match_tag(soap, arrayType, "ns4:TimeEntryData"))
	{	cp->type = SOAP_TYPE_ArrayOf_USCOREtns1_USCORETimeEntryData;
		if (n < 0)
		{	cp->ptr = (void*)new ArrayOf_USCOREtns1_USCORETimeEntryData;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ArrayOf_USCOREtns1_USCORETimeEntryData);
			((ArrayOf_USCOREtns1_USCORETimeEntryData*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ArrayOf_USCOREtns1_USCORETimeEntryData[n];
			if (size)
				*size = n * sizeof(ArrayOf_USCOREtns1_USCORETimeEntryData);
			for (int i = 0; i < n; i++)
				((ArrayOf_USCOREtns1_USCORETimeEntryData*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ArrayOf_USCOREtns1_USCORETimeEntryData*)cp->ptr;
	}
	if (arrayType && !soap_match_tag(soap, arrayType, "ns4:PersonData"))
	{	cp->type = SOAP_TYPE_ArrayOf_USCOREtns1_USCOREPersonData;
		if (n < 0)
		{	cp->ptr = (void*)new ArrayOf_USCOREtns1_USCOREPersonData;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ArrayOf_USCOREtns1_USCOREPersonData);
			((ArrayOf_USCOREtns1_USCOREPersonData*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ArrayOf_USCOREtns1_USCOREPersonData[n];
			if (size)
				*size = n * sizeof(ArrayOf_USCOREtns1_USCOREPersonData);
			for (int i = 0; i < n; i++)
				((ArrayOf_USCOREtns1_USCOREPersonData*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ArrayOf_USCOREtns1_USCOREPersonData*)cp->ptr;
	}
	if (arrayType && !soap_match_tag(soap, arrayType, "ns4:ProjectData"))
	{	cp->type = SOAP_TYPE_ArrayOf_USCOREtns1_USCOREProjectData;
		if (n < 0)
		{	cp->ptr = (void*)new ArrayOf_USCOREtns1_USCOREProjectData;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ArrayOf_USCOREtns1_USCOREProjectData);
			((ArrayOf_USCOREtns1_USCOREProjectData*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ArrayOf_USCOREtns1_USCOREProjectData[n];
			if (size)
				*size = n * sizeof(ArrayOf_USCOREtns1_USCOREProjectData);
			for (int i = 0; i < n; i++)
				((ArrayOf_USCOREtns1_USCOREProjectData*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ArrayOf_USCOREtns1_USCOREProjectData*)cp->ptr;
	}
	if (arrayType && !soap_match_tag(soap, arrayType, "ns4:NoteData"))
	{	cp->type = SOAP_TYPE_ArrayOf_USCOREtns1_USCORENoteData;
		if (n < 0)
		{	cp->ptr = (void*)new ArrayOf_USCOREtns1_USCORENoteData;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ArrayOf_USCOREtns1_USCORENoteData);
			((ArrayOf_USCOREtns1_USCORENoteData*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ArrayOf_USCOREtns1_USCORENoteData[n];
			if (size)
				*size = n * sizeof(ArrayOf_USCOREtns1_USCORENoteData);
			for (int i = 0; i < n; i++)
				((ArrayOf_USCOREtns1_USCORENoteData*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ArrayOf_USCOREtns1_USCORENoteData*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)new xsd__anyType;
		if (size)
			*size = sizeof(xsd__anyType);
		((xsd__anyType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new xsd__anyType[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(xsd__anyType);
		for (int i = 0; i < n; i++)
			((xsd__anyType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__anyType*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__anyType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__anyType %p -> %p\n", q, p));
	*(xsd__anyType*)p = *(xsd__anyType*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->faultcode);
	soap_serialize_string(soap, &a->faultstring);
	soap_serialize_string(soap, &a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, &a->SOAP_ENV__Node);
	soap_serialize_string(soap, &a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Fault);
	if (soap_out_SOAP_ENV__Fault(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, &a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, &a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, &a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, &a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	short soap_flag_faultcode = 1, soap_flag_faultstring = 1, soap_flag_faultactor = 1, soap_flag_detail = 1, soap_flag_SOAP_ENV__Code = 1, soap_flag_SOAP_ENV__Reason = 1, soap_flag_SOAP_ENV__Node = 1, soap_flag_SOAP_ENV__Role = 1, soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "faultcode", &a->faultcode, ""))
				{	soap_flag_faultcode--;
					continue;
				}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultstring", &a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultactor", &a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Node", &a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Role", &a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, 0, sizeof(struct SOAP_ENV__Fault), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct SOAP_ENV__Fault * SOAP_FMAC6 soap_new_SOAP_ENV__Fault(struct soap *soap, int n)
{	return soap_instantiate_SOAP_ENV__Fault(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Fault(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Fault, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Fault;
		if (size)
			*size = sizeof(struct SOAP_ENV__Fault);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Fault[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Fault);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Fault*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Fault(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Fault %p -> %p\n", q, p));
	*(struct SOAP_ENV__Fault*)p = *(struct SOAP_ENV__Fault*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Reason);
	if (soap_out_SOAP_ENV__Reason(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, &a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	short soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Text", &a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, 0, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct SOAP_ENV__Reason * SOAP_FMAC6 soap_new_SOAP_ENV__Reason(struct soap *soap, int n)
{	return soap_instantiate_SOAP_ENV__Reason(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Reason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Reason(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Reason, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Reason;
		if (size)
			*size = sizeof(struct SOAP_ENV__Reason);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Reason[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Reason);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Reason*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Reason(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Reason %p -> %p\n", q, p));
	*(struct SOAP_ENV__Reason*)p = *(struct SOAP_ENV__Reason*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Code);
	if (soap_out_SOAP_ENV__Code(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	short soap_flag_SOAP_ENV__Value = 1, soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "SOAP-ENV:Value", &a->SOAP_ENV__Value, ""))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, 0, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct SOAP_ENV__Code * SOAP_FMAC6 soap_new_SOAP_ENV__Code(struct soap *soap, int n)
{	return soap_instantiate_SOAP_ENV__Code(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Code(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Code(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Code, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Code;
		if (size)
			*size = sizeof(struct SOAP_ENV__Code);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Code[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Code);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Code*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Code(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Code %p -> %p\n", q, p));
	*(struct SOAP_ENV__Code*)p = *(struct SOAP_ENV__Code*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Header);
	if (soap_out_SOAP_ENV__Header(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, 0, sizeof(struct SOAP_ENV__Header), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct SOAP_ENV__Header * SOAP_FMAC6 soap_new_SOAP_ENV__Header(struct soap *soap, int n)
{	return soap_instantiate_SOAP_ENV__Header(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Header(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Header, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Header;
		if (size)
			*size = sizeof(struct SOAP_ENV__Header);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Header[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Header);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Header*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Header(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Header %p -> %p\n", q, p));
	*(struct SOAP_ENV__Header*)p = *(struct SOAP_ENV__Header*)q;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns6__getAttributesWithPrefix(struct soap *soap, struct ns6__getAttributesWithPrefix *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_objectId);
	soap_default_string(soap, &a->_prefix);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns6__getAttributesWithPrefix(struct soap *soap, const struct ns6__getAttributesWithPrefix *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_prefix);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__getAttributesWithPrefix(struct soap *soap, const struct ns6__getAttributesWithPrefix *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns6__getAttributesWithPrefix);
	if (soap_out_ns6__getAttributesWithPrefix(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__getAttributesWithPrefix(struct soap *soap, const char *tag, int id, const struct ns6__getAttributesWithPrefix *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__getAttributesWithPrefix), type))
		return soap->error;
	if (soap_out_int(soap, "objectId", -1, &a->_objectId, ""))
		return soap->error;
	if (soap_out_string(soap, "prefix", -1, &a->_prefix, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns6__getAttributesWithPrefix * SOAP_FMAC4 soap_get_ns6__getAttributesWithPrefix(struct soap *soap, struct ns6__getAttributesWithPrefix *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__getAttributesWithPrefix(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns6__getAttributesWithPrefix * SOAP_FMAC4 soap_in_ns6__getAttributesWithPrefix(struct soap *soap, const char *tag, struct ns6__getAttributesWithPrefix *a, const char *type)
{
	short soap_flag__objectId = 1, soap_flag__prefix = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns6__getAttributesWithPrefix *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__getAttributesWithPrefix, sizeof(struct ns6__getAttributesWithPrefix), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns6__getAttributesWithPrefix(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__objectId && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_objectId, "xsd:int"))
				{	soap_flag__objectId--;
					continue;
				}
			if (soap_flag__prefix && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_prefix, "xsd:string"))
				{	soap_flag__prefix--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns6__getAttributesWithPrefix *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__getAttributesWithPrefix, 0, sizeof(struct ns6__getAttributesWithPrefix), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__objectId > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns6__getAttributesWithPrefix * SOAP_FMAC6 soap_new_ns6__getAttributesWithPrefix(struct soap *soap, int n)
{	return soap_instantiate_ns6__getAttributesWithPrefix(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns6__getAttributesWithPrefix(struct soap *soap, struct ns6__getAttributesWithPrefix *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns6__getAttributesWithPrefix * SOAP_FMAC4 soap_instantiate_ns6__getAttributesWithPrefix(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__getAttributesWithPrefix(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__getAttributesWithPrefix, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns6__getAttributesWithPrefix;
		if (size)
			*size = sizeof(struct ns6__getAttributesWithPrefix);
	}
	else
	{	cp->ptr = (void*)new struct ns6__getAttributesWithPrefix[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns6__getAttributesWithPrefix);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns6__getAttributesWithPrefix*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__getAttributesWithPrefix(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns6__getAttributesWithPrefix %p -> %p\n", q, p));
	*(struct ns6__getAttributesWithPrefix*)p = *(struct ns6__getAttributesWithPrefix*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns6__getAttributesWithPrefixResponse(struct soap *soap, struct ns6__getAttributesWithPrefixResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_getAttributesWithPrefixReturn = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns6__getAttributesWithPrefixResponse(struct soap *soap, const struct ns6__getAttributesWithPrefixResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__Map(soap, &a->_getAttributesWithPrefixReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__getAttributesWithPrefixResponse(struct soap *soap, const struct ns6__getAttributesWithPrefixResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns6__getAttributesWithPrefixResponse);
	if (soap_out_ns6__getAttributesWithPrefixResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__getAttributesWithPrefixResponse(struct soap *soap, const char *tag, int id, const struct ns6__getAttributesWithPrefixResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__getAttributesWithPrefixResponse), type))
		return soap->error;
	if (soap_out_PointerTons2__Map(soap, "getAttributesWithPrefixReturn", -1, &a->_getAttributesWithPrefixReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns6__getAttributesWithPrefixResponse * SOAP_FMAC4 soap_get_ns6__getAttributesWithPrefixResponse(struct soap *soap, struct ns6__getAttributesWithPrefixResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__getAttributesWithPrefixResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns6__getAttributesWithPrefixResponse * SOAP_FMAC4 soap_in_ns6__getAttributesWithPrefixResponse(struct soap *soap, const char *tag, struct ns6__getAttributesWithPrefixResponse *a, const char *type)
{
	short soap_flag__getAttributesWithPrefixReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns6__getAttributesWithPrefixResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__getAttributesWithPrefixResponse, sizeof(struct ns6__getAttributesWithPrefixResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns6__getAttributesWithPrefixResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__getAttributesWithPrefixReturn && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__Map(soap, NULL, &a->_getAttributesWithPrefixReturn, "ns2:Map"))
				{	soap_flag__getAttributesWithPrefixReturn--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns6__getAttributesWithPrefixResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__getAttributesWithPrefixResponse, 0, sizeof(struct ns6__getAttributesWithPrefixResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns6__getAttributesWithPrefixResponse * SOAP_FMAC6 soap_new_ns6__getAttributesWithPrefixResponse(struct soap *soap, int n)
{	return soap_instantiate_ns6__getAttributesWithPrefixResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns6__getAttributesWithPrefixResponse(struct soap *soap, struct ns6__getAttributesWithPrefixResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns6__getAttributesWithPrefixResponse * SOAP_FMAC4 soap_instantiate_ns6__getAttributesWithPrefixResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__getAttributesWithPrefixResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__getAttributesWithPrefixResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns6__getAttributesWithPrefixResponse;
		if (size)
			*size = sizeof(struct ns6__getAttributesWithPrefixResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns6__getAttributesWithPrefixResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns6__getAttributesWithPrefixResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns6__getAttributesWithPrefixResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__getAttributesWithPrefixResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns6__getAttributesWithPrefixResponse %p -> %p\n", q, p));
	*(struct ns6__getAttributesWithPrefixResponse*)p = *(struct ns6__getAttributesWithPrefixResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns6__deleteAttribute(struct soap *soap, struct ns6__deleteAttribute *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_objectId);
	soap_default_string(soap, &a->_key);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns6__deleteAttribute(struct soap *soap, const struct ns6__deleteAttribute *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_key);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__deleteAttribute(struct soap *soap, const struct ns6__deleteAttribute *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns6__deleteAttribute);
	if (soap_out_ns6__deleteAttribute(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__deleteAttribute(struct soap *soap, const char *tag, int id, const struct ns6__deleteAttribute *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__deleteAttribute), type))
		return soap->error;
	if (soap_out_int(soap, "objectId", -1, &a->_objectId, ""))
		return soap->error;
	if (soap_out_string(soap, "key", -1, &a->_key, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns6__deleteAttribute * SOAP_FMAC4 soap_get_ns6__deleteAttribute(struct soap *soap, struct ns6__deleteAttribute *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__deleteAttribute(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns6__deleteAttribute * SOAP_FMAC4 soap_in_ns6__deleteAttribute(struct soap *soap, const char *tag, struct ns6__deleteAttribute *a, const char *type)
{
	short soap_flag__objectId = 1, soap_flag__key = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns6__deleteAttribute *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__deleteAttribute, sizeof(struct ns6__deleteAttribute), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns6__deleteAttribute(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__objectId && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_objectId, "xsd:int"))
				{	soap_flag__objectId--;
					continue;
				}
			if (soap_flag__key && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_key, "xsd:string"))
				{	soap_flag__key--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns6__deleteAttribute *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__deleteAttribute, 0, sizeof(struct ns6__deleteAttribute), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__objectId > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns6__deleteAttribute * SOAP_FMAC6 soap_new_ns6__deleteAttribute(struct soap *soap, int n)
{	return soap_instantiate_ns6__deleteAttribute(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns6__deleteAttribute(struct soap *soap, struct ns6__deleteAttribute *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns6__deleteAttribute * SOAP_FMAC4 soap_instantiate_ns6__deleteAttribute(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__deleteAttribute(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__deleteAttribute, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns6__deleteAttribute;
		if (size)
			*size = sizeof(struct ns6__deleteAttribute);
	}
	else
	{	cp->ptr = (void*)new struct ns6__deleteAttribute[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns6__deleteAttribute);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns6__deleteAttribute*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__deleteAttribute(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns6__deleteAttribute %p -> %p\n", q, p));
	*(struct ns6__deleteAttribute*)p = *(struct ns6__deleteAttribute*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns6__deleteAttributeResponse(struct soap *soap, struct ns6__deleteAttributeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns6__deleteAttributeResponse(struct soap *soap, const struct ns6__deleteAttributeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__deleteAttributeResponse(struct soap *soap, const struct ns6__deleteAttributeResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns6__deleteAttributeResponse);
	if (soap_out_ns6__deleteAttributeResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__deleteAttributeResponse(struct soap *soap, const char *tag, int id, const struct ns6__deleteAttributeResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__deleteAttributeResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns6__deleteAttributeResponse * SOAP_FMAC4 soap_get_ns6__deleteAttributeResponse(struct soap *soap, struct ns6__deleteAttributeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__deleteAttributeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns6__deleteAttributeResponse * SOAP_FMAC4 soap_in_ns6__deleteAttributeResponse(struct soap *soap, const char *tag, struct ns6__deleteAttributeResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns6__deleteAttributeResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__deleteAttributeResponse, sizeof(struct ns6__deleteAttributeResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns6__deleteAttributeResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns6__deleteAttributeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__deleteAttributeResponse, 0, sizeof(struct ns6__deleteAttributeResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns6__deleteAttributeResponse * SOAP_FMAC6 soap_new_ns6__deleteAttributeResponse(struct soap *soap, int n)
{	return soap_instantiate_ns6__deleteAttributeResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns6__deleteAttributeResponse(struct soap *soap, struct ns6__deleteAttributeResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns6__deleteAttributeResponse * SOAP_FMAC4 soap_instantiate_ns6__deleteAttributeResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__deleteAttributeResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__deleteAttributeResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns6__deleteAttributeResponse;
		if (size)
			*size = sizeof(struct ns6__deleteAttributeResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns6__deleteAttributeResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns6__deleteAttributeResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns6__deleteAttributeResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__deleteAttributeResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns6__deleteAttributeResponse %p -> %p\n", q, p));
	*(struct ns6__deleteAttributeResponse*)p = *(struct ns6__deleteAttributeResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns6__removePerson(struct soap *soap, struct ns6__removePerson *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns6__removePerson(struct soap *soap, const struct ns6__removePerson *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__removePerson(struct soap *soap, const struct ns6__removePerson *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns6__removePerson);
	if (soap_out_ns6__removePerson(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__removePerson(struct soap *soap, const char *tag, int id, const struct ns6__removePerson *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__removePerson), type))
		return soap->error;
	if (soap_out_int(soap, "id", -1, &a->_id, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns6__removePerson * SOAP_FMAC4 soap_get_ns6__removePerson(struct soap *soap, struct ns6__removePerson *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__removePerson(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns6__removePerson * SOAP_FMAC4 soap_in_ns6__removePerson(struct soap *soap, const char *tag, struct ns6__removePerson *a, const char *type)
{
	short soap_flag__id = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns6__removePerson *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__removePerson, sizeof(struct ns6__removePerson), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns6__removePerson(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__id && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_id, "xsd:int"))
				{	soap_flag__id--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns6__removePerson *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__removePerson, 0, sizeof(struct ns6__removePerson), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__id > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns6__removePerson * SOAP_FMAC6 soap_new_ns6__removePerson(struct soap *soap, int n)
{	return soap_instantiate_ns6__removePerson(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns6__removePerson(struct soap *soap, struct ns6__removePerson *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns6__removePerson * SOAP_FMAC4 soap_instantiate_ns6__removePerson(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__removePerson(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__removePerson, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns6__removePerson;
		if (size)
			*size = sizeof(struct ns6__removePerson);
	}
	else
	{	cp->ptr = (void*)new struct ns6__removePerson[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns6__removePerson);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns6__removePerson*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__removePerson(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns6__removePerson %p -> %p\n", q, p));
	*(struct ns6__removePerson*)p = *(struct ns6__removePerson*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns6__removePersonResponse(struct soap *soap, struct ns6__removePersonResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns6__removePersonResponse(struct soap *soap, const struct ns6__removePersonResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__removePersonResponse(struct soap *soap, const struct ns6__removePersonResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns6__removePersonResponse);
	if (soap_out_ns6__removePersonResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__removePersonResponse(struct soap *soap, const char *tag, int id, const struct ns6__removePersonResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__removePersonResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns6__removePersonResponse * SOAP_FMAC4 soap_get_ns6__removePersonResponse(struct soap *soap, struct ns6__removePersonResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__removePersonResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns6__removePersonResponse * SOAP_FMAC4 soap_in_ns6__removePersonResponse(struct soap *soap, const char *tag, struct ns6__removePersonResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns6__removePersonResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__removePersonResponse, sizeof(struct ns6__removePersonResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns6__removePersonResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns6__removePersonResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__removePersonResponse, 0, sizeof(struct ns6__removePersonResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns6__removePersonResponse * SOAP_FMAC6 soap_new_ns6__removePersonResponse(struct soap *soap, int n)
{	return soap_instantiate_ns6__removePersonResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns6__removePersonResponse(struct soap *soap, struct ns6__removePersonResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns6__removePersonResponse * SOAP_FMAC4 soap_instantiate_ns6__removePersonResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__removePersonResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__removePersonResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns6__removePersonResponse;
		if (size)
			*size = sizeof(struct ns6__removePersonResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns6__removePersonResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns6__removePersonResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns6__removePersonResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__removePersonResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns6__removePersonResponse %p -> %p\n", q, p));
	*(struct ns6__removePersonResponse*)p = *(struct ns6__removePersonResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns6__addPerson(struct soap *soap, struct ns6__addPerson *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_object = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns6__addPerson(struct soap *soap, const struct ns6__addPerson *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__PersonData(soap, &a->_object);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__addPerson(struct soap *soap, const struct ns6__addPerson *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns6__addPerson);
	if (soap_out_ns6__addPerson(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__addPerson(struct soap *soap, const char *tag, int id, const struct ns6__addPerson *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__addPerson), type))
		return soap->error;
	if (soap_out_PointerTons4__PersonData(soap, "object", -1, &a->_object, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns6__addPerson * SOAP_FMAC4 soap_get_ns6__addPerson(struct soap *soap, struct ns6__addPerson *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__addPerson(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns6__addPerson * SOAP_FMAC4 soap_in_ns6__addPerson(struct soap *soap, const char *tag, struct ns6__addPerson *a, const char *type)
{
	short soap_flag__object = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns6__addPerson *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__addPerson, sizeof(struct ns6__addPerson), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns6__addPerson(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__object && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__PersonData(soap, NULL, &a->_object, "ns4:PersonData"))
				{	soap_flag__object--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns6__addPerson *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__addPerson, 0, sizeof(struct ns6__addPerson), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns6__addPerson * SOAP_FMAC6 soap_new_ns6__addPerson(struct soap *soap, int n)
{	return soap_instantiate_ns6__addPerson(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns6__addPerson(struct soap *soap, struct ns6__addPerson *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns6__addPerson * SOAP_FMAC4 soap_instantiate_ns6__addPerson(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__addPerson(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__addPerson, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns6__addPerson;
		if (size)
			*size = sizeof(struct ns6__addPerson);
	}
	else
	{	cp->ptr = (void*)new struct ns6__addPerson[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns6__addPerson);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns6__addPerson*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__addPerson(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns6__addPerson %p -> %p\n", q, p));
	*(struct ns6__addPerson*)p = *(struct ns6__addPerson*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns6__addPersonResponse(struct soap *soap, struct ns6__addPersonResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_addPersonReturn = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns6__addPersonResponse(struct soap *soap, const struct ns6__addPersonResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__PersonData(soap, &a->_addPersonReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__addPersonResponse(struct soap *soap, const struct ns6__addPersonResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns6__addPersonResponse);
	if (soap_out_ns6__addPersonResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__addPersonResponse(struct soap *soap, const char *tag, int id, const struct ns6__addPersonResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__addPersonResponse), type))
		return soap->error;
	if (soap_out_PointerTons4__PersonData(soap, "addPersonReturn", -1, &a->_addPersonReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns6__addPersonResponse * SOAP_FMAC4 soap_get_ns6__addPersonResponse(struct soap *soap, struct ns6__addPersonResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__addPersonResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns6__addPersonResponse * SOAP_FMAC4 soap_in_ns6__addPersonResponse(struct soap *soap, const char *tag, struct ns6__addPersonResponse *a, const char *type)
{
	short soap_flag__addPersonReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns6__addPersonResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__addPersonResponse, sizeof(struct ns6__addPersonResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns6__addPersonResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__addPersonReturn && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__PersonData(soap, NULL, &a->_addPersonReturn, "ns4:PersonData"))
				{	soap_flag__addPersonReturn--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns6__addPersonResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__addPersonResponse, 0, sizeof(struct ns6__addPersonResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns6__addPersonResponse * SOAP_FMAC6 soap_new_ns6__addPersonResponse(struct soap *soap, int n)
{	return soap_instantiate_ns6__addPersonResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns6__addPersonResponse(struct soap *soap, struct ns6__addPersonResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns6__addPersonResponse * SOAP_FMAC4 soap_instantiate_ns6__addPersonResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__addPersonResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__addPersonResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns6__addPersonResponse;
		if (size)
			*size = sizeof(struct ns6__addPersonResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns6__addPersonResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns6__addPersonResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns6__addPersonResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__addPersonResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns6__addPersonResponse %p -> %p\n", q, p));
	*(struct ns6__addPersonResponse*)p = *(struct ns6__addPersonResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns6__getNotesForObject(struct soap *soap, struct ns6__getNotesForObject *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_attachedToId);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns6__getNotesForObject(struct soap *soap, const struct ns6__getNotesForObject *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__getNotesForObject(struct soap *soap, const struct ns6__getNotesForObject *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns6__getNotesForObject);
	if (soap_out_ns6__getNotesForObject(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__getNotesForObject(struct soap *soap, const char *tag, int id, const struct ns6__getNotesForObject *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__getNotesForObject), type))
		return soap->error;
	if (soap_out_int(soap, "attachedToId", -1, &a->_attachedToId, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns6__getNotesForObject * SOAP_FMAC4 soap_get_ns6__getNotesForObject(struct soap *soap, struct ns6__getNotesForObject *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__getNotesForObject(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns6__getNotesForObject * SOAP_FMAC4 soap_in_ns6__getNotesForObject(struct soap *soap, const char *tag, struct ns6__getNotesForObject *a, const char *type)
{
	short soap_flag__attachedToId = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns6__getNotesForObject *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__getNotesForObject, sizeof(struct ns6__getNotesForObject), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns6__getNotesForObject(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__attachedToId && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_attachedToId, "xsd:int"))
				{	soap_flag__attachedToId--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns6__getNotesForObject *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__getNotesForObject, 0, sizeof(struct ns6__getNotesForObject), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__attachedToId > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns6__getNotesForObject * SOAP_FMAC6 soap_new_ns6__getNotesForObject(struct soap *soap, int n)
{	return soap_instantiate_ns6__getNotesForObject(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns6__getNotesForObject(struct soap *soap, struct ns6__getNotesForObject *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns6__getNotesForObject * SOAP_FMAC4 soap_instantiate_ns6__getNotesForObject(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__getNotesForObject(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__getNotesForObject, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns6__getNotesForObject;
		if (size)
			*size = sizeof(struct ns6__getNotesForObject);
	}
	else
	{	cp->ptr = (void*)new struct ns6__getNotesForObject[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns6__getNotesForObject);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns6__getNotesForObject*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__getNotesForObject(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns6__getNotesForObject %p -> %p\n", q, p));
	*(struct ns6__getNotesForObject*)p = *(struct ns6__getNotesForObject*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns6__getNotesForObjectResponse(struct soap *soap, struct ns6__getNotesForObjectResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_getNotesForObjectReturn = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns6__getNotesForObjectResponse(struct soap *soap, const struct ns6__getNotesForObjectResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToArrayOf_USCOREtns1_USCORENoteData(soap, &a->_getNotesForObjectReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__getNotesForObjectResponse(struct soap *soap, const struct ns6__getNotesForObjectResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns6__getNotesForObjectResponse);
	if (soap_out_ns6__getNotesForObjectResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__getNotesForObjectResponse(struct soap *soap, const char *tag, int id, const struct ns6__getNotesForObjectResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__getNotesForObjectResponse), type))
		return soap->error;
	if (soap_out_PointerToArrayOf_USCOREtns1_USCORENoteData(soap, "getNotesForObjectReturn", -1, &a->_getNotesForObjectReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns6__getNotesForObjectResponse * SOAP_FMAC4 soap_get_ns6__getNotesForObjectResponse(struct soap *soap, struct ns6__getNotesForObjectResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__getNotesForObjectResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns6__getNotesForObjectResponse * SOAP_FMAC4 soap_in_ns6__getNotesForObjectResponse(struct soap *soap, const char *tag, struct ns6__getNotesForObjectResponse *a, const char *type)
{
	short soap_flag__getNotesForObjectReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns6__getNotesForObjectResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__getNotesForObjectResponse, sizeof(struct ns6__getNotesForObjectResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns6__getNotesForObjectResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__getNotesForObjectReturn && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOf_USCOREtns1_USCORENoteData(soap, NULL, &a->_getNotesForObjectReturn, "ns4:NoteData"))
				{	soap_flag__getNotesForObjectReturn--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns6__getNotesForObjectResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__getNotesForObjectResponse, 0, sizeof(struct ns6__getNotesForObjectResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns6__getNotesForObjectResponse * SOAP_FMAC6 soap_new_ns6__getNotesForObjectResponse(struct soap *soap, int n)
{	return soap_instantiate_ns6__getNotesForObjectResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns6__getNotesForObjectResponse(struct soap *soap, struct ns6__getNotesForObjectResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns6__getNotesForObjectResponse * SOAP_FMAC4 soap_instantiate_ns6__getNotesForObjectResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__getNotesForObjectResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__getNotesForObjectResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns6__getNotesForObjectResponse;
		if (size)
			*size = sizeof(struct ns6__getNotesForObjectResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns6__getNotesForObjectResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns6__getNotesForObjectResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns6__getNotesForObjectResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__getNotesForObjectResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns6__getNotesForObjectResponse %p -> %p\n", q, p));
	*(struct ns6__getNotesForObjectResponse*)p = *(struct ns6__getNotesForObjectResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns6__addNote(struct soap *soap, struct ns6__addNote *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_note = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns6__addNote(struct soap *soap, const struct ns6__addNote *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__NoteData(soap, &a->_note);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__addNote(struct soap *soap, const struct ns6__addNote *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns6__addNote);
	if (soap_out_ns6__addNote(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__addNote(struct soap *soap, const char *tag, int id, const struct ns6__addNote *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__addNote), type))
		return soap->error;
	if (soap_out_PointerTons4__NoteData(soap, "note", -1, &a->_note, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns6__addNote * SOAP_FMAC4 soap_get_ns6__addNote(struct soap *soap, struct ns6__addNote *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__addNote(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns6__addNote * SOAP_FMAC4 soap_in_ns6__addNote(struct soap *soap, const char *tag, struct ns6__addNote *a, const char *type)
{
	short soap_flag__note = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns6__addNote *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__addNote, sizeof(struct ns6__addNote), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns6__addNote(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__note && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__NoteData(soap, NULL, &a->_note, "ns4:NoteData"))
				{	soap_flag__note--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns6__addNote *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__addNote, 0, sizeof(struct ns6__addNote), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns6__addNote * SOAP_FMAC6 soap_new_ns6__addNote(struct soap *soap, int n)
{	return soap_instantiate_ns6__addNote(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns6__addNote(struct soap *soap, struct ns6__addNote *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns6__addNote * SOAP_FMAC4 soap_instantiate_ns6__addNote(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__addNote(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__addNote, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns6__addNote;
		if (size)
			*size = sizeof(struct ns6__addNote);
	}
	else
	{	cp->ptr = (void*)new struct ns6__addNote[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns6__addNote);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns6__addNote*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__addNote(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns6__addNote %p -> %p\n", q, p));
	*(struct ns6__addNote*)p = *(struct ns6__addNote*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns6__addNoteResponse(struct soap *soap, struct ns6__addNoteResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_addNoteReturn = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns6__addNoteResponse(struct soap *soap, const struct ns6__addNoteResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__NoteData(soap, &a->_addNoteReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__addNoteResponse(struct soap *soap, const struct ns6__addNoteResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns6__addNoteResponse);
	if (soap_out_ns6__addNoteResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__addNoteResponse(struct soap *soap, const char *tag, int id, const struct ns6__addNoteResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__addNoteResponse), type))
		return soap->error;
	if (soap_out_PointerTons4__NoteData(soap, "addNoteReturn", -1, &a->_addNoteReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns6__addNoteResponse * SOAP_FMAC4 soap_get_ns6__addNoteResponse(struct soap *soap, struct ns6__addNoteResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__addNoteResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns6__addNoteResponse * SOAP_FMAC4 soap_in_ns6__addNoteResponse(struct soap *soap, const char *tag, struct ns6__addNoteResponse *a, const char *type)
{
	short soap_flag__addNoteReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns6__addNoteResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__addNoteResponse, sizeof(struct ns6__addNoteResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns6__addNoteResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__addNoteReturn && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__NoteData(soap, NULL, &a->_addNoteReturn, "ns4:NoteData"))
				{	soap_flag__addNoteReturn--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns6__addNoteResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__addNoteResponse, 0, sizeof(struct ns6__addNoteResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns6__addNoteResponse * SOAP_FMAC6 soap_new_ns6__addNoteResponse(struct soap *soap, int n)
{	return soap_instantiate_ns6__addNoteResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns6__addNoteResponse(struct soap *soap, struct ns6__addNoteResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns6__addNoteResponse * SOAP_FMAC4 soap_instantiate_ns6__addNoteResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__addNoteResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__addNoteResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns6__addNoteResponse;
		if (size)
			*size = sizeof(struct ns6__addNoteResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns6__addNoteResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns6__addNoteResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns6__addNoteResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__addNoteResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns6__addNoteResponse %p -> %p\n", q, p));
	*(struct ns6__addNoteResponse*)p = *(struct ns6__addNoteResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns6__removeTimeEntry(struct soap *soap, struct ns6__removeTimeEntry *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns6__removeTimeEntry(struct soap *soap, const struct ns6__removeTimeEntry *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__removeTimeEntry(struct soap *soap, const struct ns6__removeTimeEntry *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns6__removeTimeEntry);
	if (soap_out_ns6__removeTimeEntry(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__removeTimeEntry(struct soap *soap, const char *tag, int id, const struct ns6__removeTimeEntry *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__removeTimeEntry), type))
		return soap->error;
	if (soap_out_int(soap, "id", -1, &a->_id, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns6__removeTimeEntry * SOAP_FMAC4 soap_get_ns6__removeTimeEntry(struct soap *soap, struct ns6__removeTimeEntry *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__removeTimeEntry(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns6__removeTimeEntry * SOAP_FMAC4 soap_in_ns6__removeTimeEntry(struct soap *soap, const char *tag, struct ns6__removeTimeEntry *a, const char *type)
{
	short soap_flag__id = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns6__removeTimeEntry *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__removeTimeEntry, sizeof(struct ns6__removeTimeEntry), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns6__removeTimeEntry(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__id && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_id, "xsd:int"))
				{	soap_flag__id--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns6__removeTimeEntry *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__removeTimeEntry, 0, sizeof(struct ns6__removeTimeEntry), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__id > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns6__removeTimeEntry * SOAP_FMAC6 soap_new_ns6__removeTimeEntry(struct soap *soap, int n)
{	return soap_instantiate_ns6__removeTimeEntry(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns6__removeTimeEntry(struct soap *soap, struct ns6__removeTimeEntry *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns6__removeTimeEntry * SOAP_FMAC4 soap_instantiate_ns6__removeTimeEntry(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__removeTimeEntry(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__removeTimeEntry, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns6__removeTimeEntry;
		if (size)
			*size = sizeof(struct ns6__removeTimeEntry);
	}
	else
	{	cp->ptr = (void*)new struct ns6__removeTimeEntry[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns6__removeTimeEntry);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns6__removeTimeEntry*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__removeTimeEntry(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns6__removeTimeEntry %p -> %p\n", q, p));
	*(struct ns6__removeTimeEntry*)p = *(struct ns6__removeTimeEntry*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns6__removeTimeEntryResponse(struct soap *soap, struct ns6__removeTimeEntryResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns6__removeTimeEntryResponse(struct soap *soap, const struct ns6__removeTimeEntryResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__removeTimeEntryResponse(struct soap *soap, const struct ns6__removeTimeEntryResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns6__removeTimeEntryResponse);
	if (soap_out_ns6__removeTimeEntryResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__removeTimeEntryResponse(struct soap *soap, const char *tag, int id, const struct ns6__removeTimeEntryResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__removeTimeEntryResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns6__removeTimeEntryResponse * SOAP_FMAC4 soap_get_ns6__removeTimeEntryResponse(struct soap *soap, struct ns6__removeTimeEntryResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__removeTimeEntryResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns6__removeTimeEntryResponse * SOAP_FMAC4 soap_in_ns6__removeTimeEntryResponse(struct soap *soap, const char *tag, struct ns6__removeTimeEntryResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns6__removeTimeEntryResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__removeTimeEntryResponse, sizeof(struct ns6__removeTimeEntryResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns6__removeTimeEntryResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns6__removeTimeEntryResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__removeTimeEntryResponse, 0, sizeof(struct ns6__removeTimeEntryResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns6__removeTimeEntryResponse * SOAP_FMAC6 soap_new_ns6__removeTimeEntryResponse(struct soap *soap, int n)
{	return soap_instantiate_ns6__removeTimeEntryResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns6__removeTimeEntryResponse(struct soap *soap, struct ns6__removeTimeEntryResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns6__removeTimeEntryResponse * SOAP_FMAC4 soap_instantiate_ns6__removeTimeEntryResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__removeTimeEntryResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__removeTimeEntryResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns6__removeTimeEntryResponse;
		if (size)
			*size = sizeof(struct ns6__removeTimeEntryResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns6__removeTimeEntryResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns6__removeTimeEntryResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns6__removeTimeEntryResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__removeTimeEntryResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns6__removeTimeEntryResponse %p -> %p\n", q, p));
	*(struct ns6__removeTimeEntryResponse*)p = *(struct ns6__removeTimeEntryResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns6__addTimeEntry(struct soap *soap, struct ns6__addTimeEntry *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_timeEntry = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns6__addTimeEntry(struct soap *soap, const struct ns6__addTimeEntry *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__TimeEntryData(soap, &a->_timeEntry);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__addTimeEntry(struct soap *soap, const struct ns6__addTimeEntry *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns6__addTimeEntry);
	if (soap_out_ns6__addTimeEntry(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__addTimeEntry(struct soap *soap, const char *tag, int id, const struct ns6__addTimeEntry *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__addTimeEntry), type))
		return soap->error;
	if (soap_out_PointerTons4__TimeEntryData(soap, "timeEntry", -1, &a->_timeEntry, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns6__addTimeEntry * SOAP_FMAC4 soap_get_ns6__addTimeEntry(struct soap *soap, struct ns6__addTimeEntry *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__addTimeEntry(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns6__addTimeEntry * SOAP_FMAC4 soap_in_ns6__addTimeEntry(struct soap *soap, const char *tag, struct ns6__addTimeEntry *a, const char *type)
{
	short soap_flag__timeEntry = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns6__addTimeEntry *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__addTimeEntry, sizeof(struct ns6__addTimeEntry), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns6__addTimeEntry(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__timeEntry && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__TimeEntryData(soap, NULL, &a->_timeEntry, "ns4:TimeEntryData"))
				{	soap_flag__timeEntry--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns6__addTimeEntry *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__addTimeEntry, 0, sizeof(struct ns6__addTimeEntry), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns6__addTimeEntry * SOAP_FMAC6 soap_new_ns6__addTimeEntry(struct soap *soap, int n)
{	return soap_instantiate_ns6__addTimeEntry(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns6__addTimeEntry(struct soap *soap, struct ns6__addTimeEntry *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns6__addTimeEntry * SOAP_FMAC4 soap_instantiate_ns6__addTimeEntry(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__addTimeEntry(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__addTimeEntry, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns6__addTimeEntry;
		if (size)
			*size = sizeof(struct ns6__addTimeEntry);
	}
	else
	{	cp->ptr = (void*)new struct ns6__addTimeEntry[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns6__addTimeEntry);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns6__addTimeEntry*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__addTimeEntry(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns6__addTimeEntry %p -> %p\n", q, p));
	*(struct ns6__addTimeEntry*)p = *(struct ns6__addTimeEntry*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns6__addTimeEntryResponse(struct soap *soap, struct ns6__addTimeEntryResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_addTimeEntryReturn = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns6__addTimeEntryResponse(struct soap *soap, const struct ns6__addTimeEntryResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__TimeEntryData(soap, &a->_addTimeEntryReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__addTimeEntryResponse(struct soap *soap, const struct ns6__addTimeEntryResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns6__addTimeEntryResponse);
	if (soap_out_ns6__addTimeEntryResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__addTimeEntryResponse(struct soap *soap, const char *tag, int id, const struct ns6__addTimeEntryResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__addTimeEntryResponse), type))
		return soap->error;
	if (soap_out_PointerTons4__TimeEntryData(soap, "addTimeEntryReturn", -1, &a->_addTimeEntryReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns6__addTimeEntryResponse * SOAP_FMAC4 soap_get_ns6__addTimeEntryResponse(struct soap *soap, struct ns6__addTimeEntryResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__addTimeEntryResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns6__addTimeEntryResponse * SOAP_FMAC4 soap_in_ns6__addTimeEntryResponse(struct soap *soap, const char *tag, struct ns6__addTimeEntryResponse *a, const char *type)
{
	short soap_flag__addTimeEntryReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns6__addTimeEntryResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__addTimeEntryResponse, sizeof(struct ns6__addTimeEntryResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns6__addTimeEntryResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__addTimeEntryReturn && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__TimeEntryData(soap, NULL, &a->_addTimeEntryReturn, "ns4:TimeEntryData"))
				{	soap_flag__addTimeEntryReturn--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns6__addTimeEntryResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__addTimeEntryResponse, 0, sizeof(struct ns6__addTimeEntryResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns6__addTimeEntryResponse * SOAP_FMAC6 soap_new_ns6__addTimeEntryResponse(struct soap *soap, int n)
{	return soap_instantiate_ns6__addTimeEntryResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns6__addTimeEntryResponse(struct soap *soap, struct ns6__addTimeEntryResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns6__addTimeEntryResponse * SOAP_FMAC4 soap_instantiate_ns6__addTimeEntryResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__addTimeEntryResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__addTimeEntryResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns6__addTimeEntryResponse;
		if (size)
			*size = sizeof(struct ns6__addTimeEntryResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns6__addTimeEntryResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns6__addTimeEntryResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns6__addTimeEntryResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__addTimeEntryResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns6__addTimeEntryResponse %p -> %p\n", q, p));
	*(struct ns6__addTimeEntryResponse*)p = *(struct ns6__addTimeEntryResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns6__getTimeEntry(struct soap *soap, struct ns6__getTimeEntry *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns6__getTimeEntry(struct soap *soap, const struct ns6__getTimeEntry *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__getTimeEntry(struct soap *soap, const struct ns6__getTimeEntry *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns6__getTimeEntry);
	if (soap_out_ns6__getTimeEntry(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__getTimeEntry(struct soap *soap, const char *tag, int id, const struct ns6__getTimeEntry *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__getTimeEntry), type))
		return soap->error;
	if (soap_out_int(soap, "id", -1, &a->_id, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns6__getTimeEntry * SOAP_FMAC4 soap_get_ns6__getTimeEntry(struct soap *soap, struct ns6__getTimeEntry *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__getTimeEntry(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns6__getTimeEntry * SOAP_FMAC4 soap_in_ns6__getTimeEntry(struct soap *soap, const char *tag, struct ns6__getTimeEntry *a, const char *type)
{
	short soap_flag__id = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns6__getTimeEntry *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__getTimeEntry, sizeof(struct ns6__getTimeEntry), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns6__getTimeEntry(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__id && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_id, "xsd:int"))
				{	soap_flag__id--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns6__getTimeEntry *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__getTimeEntry, 0, sizeof(struct ns6__getTimeEntry), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__id > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns6__getTimeEntry * SOAP_FMAC6 soap_new_ns6__getTimeEntry(struct soap *soap, int n)
{	return soap_instantiate_ns6__getTimeEntry(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns6__getTimeEntry(struct soap *soap, struct ns6__getTimeEntry *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns6__getTimeEntry * SOAP_FMAC4 soap_instantiate_ns6__getTimeEntry(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__getTimeEntry(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__getTimeEntry, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns6__getTimeEntry;
		if (size)
			*size = sizeof(struct ns6__getTimeEntry);
	}
	else
	{	cp->ptr = (void*)new struct ns6__getTimeEntry[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns6__getTimeEntry);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns6__getTimeEntry*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__getTimeEntry(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns6__getTimeEntry %p -> %p\n", q, p));
	*(struct ns6__getTimeEntry*)p = *(struct ns6__getTimeEntry*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns6__getTimeEntryResponse(struct soap *soap, struct ns6__getTimeEntryResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_getTimeEntryReturn = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns6__getTimeEntryResponse(struct soap *soap, const struct ns6__getTimeEntryResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__TimeEntryData(soap, &a->_getTimeEntryReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__getTimeEntryResponse(struct soap *soap, const struct ns6__getTimeEntryResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns6__getTimeEntryResponse);
	if (soap_out_ns6__getTimeEntryResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__getTimeEntryResponse(struct soap *soap, const char *tag, int id, const struct ns6__getTimeEntryResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__getTimeEntryResponse), type))
		return soap->error;
	if (soap_out_PointerTons4__TimeEntryData(soap, "getTimeEntryReturn", -1, &a->_getTimeEntryReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns6__getTimeEntryResponse * SOAP_FMAC4 soap_get_ns6__getTimeEntryResponse(struct soap *soap, struct ns6__getTimeEntryResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__getTimeEntryResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns6__getTimeEntryResponse * SOAP_FMAC4 soap_in_ns6__getTimeEntryResponse(struct soap *soap, const char *tag, struct ns6__getTimeEntryResponse *a, const char *type)
{
	short soap_flag__getTimeEntryReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns6__getTimeEntryResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__getTimeEntryResponse, sizeof(struct ns6__getTimeEntryResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns6__getTimeEntryResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__getTimeEntryReturn && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__TimeEntryData(soap, NULL, &a->_getTimeEntryReturn, "ns4:TimeEntryData"))
				{	soap_flag__getTimeEntryReturn--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns6__getTimeEntryResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__getTimeEntryResponse, 0, sizeof(struct ns6__getTimeEntryResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns6__getTimeEntryResponse * SOAP_FMAC6 soap_new_ns6__getTimeEntryResponse(struct soap *soap, int n)
{	return soap_instantiate_ns6__getTimeEntryResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns6__getTimeEntryResponse(struct soap *soap, struct ns6__getTimeEntryResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns6__getTimeEntryResponse * SOAP_FMAC4 soap_instantiate_ns6__getTimeEntryResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__getTimeEntryResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__getTimeEntryResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns6__getTimeEntryResponse;
		if (size)
			*size = sizeof(struct ns6__getTimeEntryResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns6__getTimeEntryResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns6__getTimeEntryResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns6__getTimeEntryResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__getTimeEntryResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns6__getTimeEntryResponse %p -> %p\n", q, p));
	*(struct ns6__getTimeEntryResponse*)p = *(struct ns6__getTimeEntryResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns6__removeTask(struct soap *soap, struct ns6__removeTask *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns6__removeTask(struct soap *soap, const struct ns6__removeTask *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__removeTask(struct soap *soap, const struct ns6__removeTask *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns6__removeTask);
	if (soap_out_ns6__removeTask(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__removeTask(struct soap *soap, const char *tag, int id, const struct ns6__removeTask *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__removeTask), type))
		return soap->error;
	if (soap_out_int(soap, "id", -1, &a->_id, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns6__removeTask * SOAP_FMAC4 soap_get_ns6__removeTask(struct soap *soap, struct ns6__removeTask *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__removeTask(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns6__removeTask * SOAP_FMAC4 soap_in_ns6__removeTask(struct soap *soap, const char *tag, struct ns6__removeTask *a, const char *type)
{
	short soap_flag__id = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns6__removeTask *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__removeTask, sizeof(struct ns6__removeTask), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns6__removeTask(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__id && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_id, "xsd:int"))
				{	soap_flag__id--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns6__removeTask *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__removeTask, 0, sizeof(struct ns6__removeTask), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__id > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns6__removeTask * SOAP_FMAC6 soap_new_ns6__removeTask(struct soap *soap, int n)
{	return soap_instantiate_ns6__removeTask(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns6__removeTask(struct soap *soap, struct ns6__removeTask *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns6__removeTask * SOAP_FMAC4 soap_instantiate_ns6__removeTask(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__removeTask(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__removeTask, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns6__removeTask;
		if (size)
			*size = sizeof(struct ns6__removeTask);
	}
	else
	{	cp->ptr = (void*)new struct ns6__removeTask[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns6__removeTask);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns6__removeTask*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__removeTask(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns6__removeTask %p -> %p\n", q, p));
	*(struct ns6__removeTask*)p = *(struct ns6__removeTask*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns6__removeTaskResponse(struct soap *soap, struct ns6__removeTaskResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns6__removeTaskResponse(struct soap *soap, const struct ns6__removeTaskResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__removeTaskResponse(struct soap *soap, const struct ns6__removeTaskResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns6__removeTaskResponse);
	if (soap_out_ns6__removeTaskResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__removeTaskResponse(struct soap *soap, const char *tag, int id, const struct ns6__removeTaskResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__removeTaskResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns6__removeTaskResponse * SOAP_FMAC4 soap_get_ns6__removeTaskResponse(struct soap *soap, struct ns6__removeTaskResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__removeTaskResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns6__removeTaskResponse * SOAP_FMAC4 soap_in_ns6__removeTaskResponse(struct soap *soap, const char *tag, struct ns6__removeTaskResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns6__removeTaskResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__removeTaskResponse, sizeof(struct ns6__removeTaskResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns6__removeTaskResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns6__removeTaskResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__removeTaskResponse, 0, sizeof(struct ns6__removeTaskResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns6__removeTaskResponse * SOAP_FMAC6 soap_new_ns6__removeTaskResponse(struct soap *soap, int n)
{	return soap_instantiate_ns6__removeTaskResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns6__removeTaskResponse(struct soap *soap, struct ns6__removeTaskResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns6__removeTaskResponse * SOAP_FMAC4 soap_instantiate_ns6__removeTaskResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__removeTaskResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__removeTaskResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns6__removeTaskResponse;
		if (size)
			*size = sizeof(struct ns6__removeTaskResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns6__removeTaskResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns6__removeTaskResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns6__removeTaskResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__removeTaskResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns6__removeTaskResponse %p -> %p\n", q, p));
	*(struct ns6__removeTaskResponse*)p = *(struct ns6__removeTaskResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns6__getPlannedTasksForPerson(struct soap *soap, struct ns6__getPlannedTasksForPerson *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_personId);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns6__getPlannedTasksForPerson(struct soap *soap, const struct ns6__getPlannedTasksForPerson *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__getPlannedTasksForPerson(struct soap *soap, const struct ns6__getPlannedTasksForPerson *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns6__getPlannedTasksForPerson);
	if (soap_out_ns6__getPlannedTasksForPerson(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__getPlannedTasksForPerson(struct soap *soap, const char *tag, int id, const struct ns6__getPlannedTasksForPerson *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__getPlannedTasksForPerson), type))
		return soap->error;
	if (soap_out_int(soap, "personId", -1, &a->_personId, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns6__getPlannedTasksForPerson * SOAP_FMAC4 soap_get_ns6__getPlannedTasksForPerson(struct soap *soap, struct ns6__getPlannedTasksForPerson *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__getPlannedTasksForPerson(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns6__getPlannedTasksForPerson * SOAP_FMAC4 soap_in_ns6__getPlannedTasksForPerson(struct soap *soap, const char *tag, struct ns6__getPlannedTasksForPerson *a, const char *type)
{
	short soap_flag__personId = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns6__getPlannedTasksForPerson *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__getPlannedTasksForPerson, sizeof(struct ns6__getPlannedTasksForPerson), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns6__getPlannedTasksForPerson(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__personId && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_personId, "xsd:int"))
				{	soap_flag__personId--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns6__getPlannedTasksForPerson *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__getPlannedTasksForPerson, 0, sizeof(struct ns6__getPlannedTasksForPerson), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__personId > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns6__getPlannedTasksForPerson * SOAP_FMAC6 soap_new_ns6__getPlannedTasksForPerson(struct soap *soap, int n)
{	return soap_instantiate_ns6__getPlannedTasksForPerson(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns6__getPlannedTasksForPerson(struct soap *soap, struct ns6__getPlannedTasksForPerson *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns6__getPlannedTasksForPerson * SOAP_FMAC4 soap_instantiate_ns6__getPlannedTasksForPerson(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__getPlannedTasksForPerson(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__getPlannedTasksForPerson, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns6__getPlannedTasksForPerson;
		if (size)
			*size = sizeof(struct ns6__getPlannedTasksForPerson);
	}
	else
	{	cp->ptr = (void*)new struct ns6__getPlannedTasksForPerson[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns6__getPlannedTasksForPerson);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns6__getPlannedTasksForPerson*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__getPlannedTasksForPerson(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns6__getPlannedTasksForPerson %p -> %p\n", q, p));
	*(struct ns6__getPlannedTasksForPerson*)p = *(struct ns6__getPlannedTasksForPerson*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns6__getPlannedTasksForPersonResponse(struct soap *soap, struct ns6__getPlannedTasksForPersonResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_getPlannedTasksForPersonReturn = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns6__getPlannedTasksForPersonResponse(struct soap *soap, const struct ns6__getPlannedTasksForPersonResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToArrayOf_USCOREtns1_USCORETaskData(soap, &a->_getPlannedTasksForPersonReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__getPlannedTasksForPersonResponse(struct soap *soap, const struct ns6__getPlannedTasksForPersonResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns6__getPlannedTasksForPersonResponse);
	if (soap_out_ns6__getPlannedTasksForPersonResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__getPlannedTasksForPersonResponse(struct soap *soap, const char *tag, int id, const struct ns6__getPlannedTasksForPersonResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__getPlannedTasksForPersonResponse), type))
		return soap->error;
	if (soap_out_PointerToArrayOf_USCOREtns1_USCORETaskData(soap, "getPlannedTasksForPersonReturn", -1, &a->_getPlannedTasksForPersonReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns6__getPlannedTasksForPersonResponse * SOAP_FMAC4 soap_get_ns6__getPlannedTasksForPersonResponse(struct soap *soap, struct ns6__getPlannedTasksForPersonResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__getPlannedTasksForPersonResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns6__getPlannedTasksForPersonResponse * SOAP_FMAC4 soap_in_ns6__getPlannedTasksForPersonResponse(struct soap *soap, const char *tag, struct ns6__getPlannedTasksForPersonResponse *a, const char *type)
{
	short soap_flag__getPlannedTasksForPersonReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns6__getPlannedTasksForPersonResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__getPlannedTasksForPersonResponse, sizeof(struct ns6__getPlannedTasksForPersonResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns6__getPlannedTasksForPersonResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__getPlannedTasksForPersonReturn && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOf_USCOREtns1_USCORETaskData(soap, NULL, &a->_getPlannedTasksForPersonReturn, "ns4:TaskData"))
				{	soap_flag__getPlannedTasksForPersonReturn--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns6__getPlannedTasksForPersonResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__getPlannedTasksForPersonResponse, 0, sizeof(struct ns6__getPlannedTasksForPersonResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns6__getPlannedTasksForPersonResponse * SOAP_FMAC6 soap_new_ns6__getPlannedTasksForPersonResponse(struct soap *soap, int n)
{	return soap_instantiate_ns6__getPlannedTasksForPersonResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns6__getPlannedTasksForPersonResponse(struct soap *soap, struct ns6__getPlannedTasksForPersonResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns6__getPlannedTasksForPersonResponse * SOAP_FMAC4 soap_instantiate_ns6__getPlannedTasksForPersonResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__getPlannedTasksForPersonResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__getPlannedTasksForPersonResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns6__getPlannedTasksForPersonResponse;
		if (size)
			*size = sizeof(struct ns6__getPlannedTasksForPersonResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns6__getPlannedTasksForPersonResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns6__getPlannedTasksForPersonResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns6__getPlannedTasksForPersonResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__getPlannedTasksForPersonResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns6__getPlannedTasksForPersonResponse %p -> %p\n", q, p));
	*(struct ns6__getPlannedTasksForPersonResponse*)p = *(struct ns6__getPlannedTasksForPersonResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns6__removeUserStory(struct soap *soap, struct ns6__removeUserStory *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns6__removeUserStory(struct soap *soap, const struct ns6__removeUserStory *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__removeUserStory(struct soap *soap, const struct ns6__removeUserStory *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns6__removeUserStory);
	if (soap_out_ns6__removeUserStory(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__removeUserStory(struct soap *soap, const char *tag, int id, const struct ns6__removeUserStory *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__removeUserStory), type))
		return soap->error;
	if (soap_out_int(soap, "id", -1, &a->_id, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns6__removeUserStory * SOAP_FMAC4 soap_get_ns6__removeUserStory(struct soap *soap, struct ns6__removeUserStory *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__removeUserStory(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns6__removeUserStory * SOAP_FMAC4 soap_in_ns6__removeUserStory(struct soap *soap, const char *tag, struct ns6__removeUserStory *a, const char *type)
{
	short soap_flag__id = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns6__removeUserStory *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__removeUserStory, sizeof(struct ns6__removeUserStory), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns6__removeUserStory(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__id && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_id, "xsd:int"))
				{	soap_flag__id--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns6__removeUserStory *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__removeUserStory, 0, sizeof(struct ns6__removeUserStory), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__id > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns6__removeUserStory * SOAP_FMAC6 soap_new_ns6__removeUserStory(struct soap *soap, int n)
{	return soap_instantiate_ns6__removeUserStory(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns6__removeUserStory(struct soap *soap, struct ns6__removeUserStory *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns6__removeUserStory * SOAP_FMAC4 soap_instantiate_ns6__removeUserStory(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__removeUserStory(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__removeUserStory, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns6__removeUserStory;
		if (size)
			*size = sizeof(struct ns6__removeUserStory);
	}
	else
	{	cp->ptr = (void*)new struct ns6__removeUserStory[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns6__removeUserStory);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns6__removeUserStory*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__removeUserStory(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns6__removeUserStory %p -> %p\n", q, p));
	*(struct ns6__removeUserStory*)p = *(struct ns6__removeUserStory*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns6__removeUserStoryResponse(struct soap *soap, struct ns6__removeUserStoryResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns6__removeUserStoryResponse(struct soap *soap, const struct ns6__removeUserStoryResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__removeUserStoryResponse(struct soap *soap, const struct ns6__removeUserStoryResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns6__removeUserStoryResponse);
	if (soap_out_ns6__removeUserStoryResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__removeUserStoryResponse(struct soap *soap, const char *tag, int id, const struct ns6__removeUserStoryResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__removeUserStoryResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns6__removeUserStoryResponse * SOAP_FMAC4 soap_get_ns6__removeUserStoryResponse(struct soap *soap, struct ns6__removeUserStoryResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__removeUserStoryResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns6__removeUserStoryResponse * SOAP_FMAC4 soap_in_ns6__removeUserStoryResponse(struct soap *soap, const char *tag, struct ns6__removeUserStoryResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns6__removeUserStoryResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__removeUserStoryResponse, sizeof(struct ns6__removeUserStoryResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns6__removeUserStoryResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns6__removeUserStoryResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__removeUserStoryResponse, 0, sizeof(struct ns6__removeUserStoryResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns6__removeUserStoryResponse * SOAP_FMAC6 soap_new_ns6__removeUserStoryResponse(struct soap *soap, int n)
{	return soap_instantiate_ns6__removeUserStoryResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns6__removeUserStoryResponse(struct soap *soap, struct ns6__removeUserStoryResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns6__removeUserStoryResponse * SOAP_FMAC4 soap_instantiate_ns6__removeUserStoryResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__removeUserStoryResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__removeUserStoryResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns6__removeUserStoryResponse;
		if (size)
			*size = sizeof(struct ns6__removeUserStoryResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns6__removeUserStoryResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns6__removeUserStoryResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns6__removeUserStoryResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__removeUserStoryResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns6__removeUserStoryResponse %p -> %p\n", q, p));
	*(struct ns6__removeUserStoryResponse*)p = *(struct ns6__removeUserStoryResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns6__addUserStory(struct soap *soap, struct ns6__addUserStory *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_story = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns6__addUserStory(struct soap *soap, const struct ns6__addUserStory *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__UserStoryData(soap, &a->_story);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__addUserStory(struct soap *soap, const struct ns6__addUserStory *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns6__addUserStory);
	if (soap_out_ns6__addUserStory(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__addUserStory(struct soap *soap, const char *tag, int id, const struct ns6__addUserStory *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__addUserStory), type))
		return soap->error;
	if (soap_out_PointerTons4__UserStoryData(soap, "story", -1, &a->_story, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns6__addUserStory * SOAP_FMAC4 soap_get_ns6__addUserStory(struct soap *soap, struct ns6__addUserStory *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__addUserStory(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns6__addUserStory * SOAP_FMAC4 soap_in_ns6__addUserStory(struct soap *soap, const char *tag, struct ns6__addUserStory *a, const char *type)
{
	short soap_flag__story = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns6__addUserStory *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__addUserStory, sizeof(struct ns6__addUserStory), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns6__addUserStory(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__story && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__UserStoryData(soap, NULL, &a->_story, "ns4:UserStoryData"))
				{	soap_flag__story--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns6__addUserStory *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__addUserStory, 0, sizeof(struct ns6__addUserStory), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns6__addUserStory * SOAP_FMAC6 soap_new_ns6__addUserStory(struct soap *soap, int n)
{	return soap_instantiate_ns6__addUserStory(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns6__addUserStory(struct soap *soap, struct ns6__addUserStory *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns6__addUserStory * SOAP_FMAC4 soap_instantiate_ns6__addUserStory(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__addUserStory(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__addUserStory, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns6__addUserStory;
		if (size)
			*size = sizeof(struct ns6__addUserStory);
	}
	else
	{	cp->ptr = (void*)new struct ns6__addUserStory[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns6__addUserStory);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns6__addUserStory*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__addUserStory(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns6__addUserStory %p -> %p\n", q, p));
	*(struct ns6__addUserStory*)p = *(struct ns6__addUserStory*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns6__addUserStoryResponse(struct soap *soap, struct ns6__addUserStoryResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_addUserStoryReturn = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns6__addUserStoryResponse(struct soap *soap, const struct ns6__addUserStoryResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__UserStoryData(soap, &a->_addUserStoryReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__addUserStoryResponse(struct soap *soap, const struct ns6__addUserStoryResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns6__addUserStoryResponse);
	if (soap_out_ns6__addUserStoryResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__addUserStoryResponse(struct soap *soap, const char *tag, int id, const struct ns6__addUserStoryResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__addUserStoryResponse), type))
		return soap->error;
	if (soap_out_PointerTons4__UserStoryData(soap, "addUserStoryReturn", -1, &a->_addUserStoryReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns6__addUserStoryResponse * SOAP_FMAC4 soap_get_ns6__addUserStoryResponse(struct soap *soap, struct ns6__addUserStoryResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__addUserStoryResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns6__addUserStoryResponse * SOAP_FMAC4 soap_in_ns6__addUserStoryResponse(struct soap *soap, const char *tag, struct ns6__addUserStoryResponse *a, const char *type)
{
	short soap_flag__addUserStoryReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns6__addUserStoryResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__addUserStoryResponse, sizeof(struct ns6__addUserStoryResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns6__addUserStoryResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__addUserStoryReturn && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__UserStoryData(soap, NULL, &a->_addUserStoryReturn, "ns4:UserStoryData"))
				{	soap_flag__addUserStoryReturn--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns6__addUserStoryResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__addUserStoryResponse, 0, sizeof(struct ns6__addUserStoryResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns6__addUserStoryResponse * SOAP_FMAC6 soap_new_ns6__addUserStoryResponse(struct soap *soap, int n)
{	return soap_instantiate_ns6__addUserStoryResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns6__addUserStoryResponse(struct soap *soap, struct ns6__addUserStoryResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns6__addUserStoryResponse * SOAP_FMAC4 soap_instantiate_ns6__addUserStoryResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__addUserStoryResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__addUserStoryResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns6__addUserStoryResponse;
		if (size)
			*size = sizeof(struct ns6__addUserStoryResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns6__addUserStoryResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns6__addUserStoryResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns6__addUserStoryResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__addUserStoryResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns6__addUserStoryResponse %p -> %p\n", q, p));
	*(struct ns6__addUserStoryResponse*)p = *(struct ns6__addUserStoryResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns6__removeIteration(struct soap *soap, struct ns6__removeIteration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns6__removeIteration(struct soap *soap, const struct ns6__removeIteration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__removeIteration(struct soap *soap, const struct ns6__removeIteration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns6__removeIteration);
	if (soap_out_ns6__removeIteration(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__removeIteration(struct soap *soap, const char *tag, int id, const struct ns6__removeIteration *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__removeIteration), type))
		return soap->error;
	if (soap_out_int(soap, "id", -1, &a->_id, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns6__removeIteration * SOAP_FMAC4 soap_get_ns6__removeIteration(struct soap *soap, struct ns6__removeIteration *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__removeIteration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns6__removeIteration * SOAP_FMAC4 soap_in_ns6__removeIteration(struct soap *soap, const char *tag, struct ns6__removeIteration *a, const char *type)
{
	short soap_flag__id = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns6__removeIteration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__removeIteration, sizeof(struct ns6__removeIteration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns6__removeIteration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__id && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_id, "xsd:int"))
				{	soap_flag__id--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns6__removeIteration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__removeIteration, 0, sizeof(struct ns6__removeIteration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__id > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns6__removeIteration * SOAP_FMAC6 soap_new_ns6__removeIteration(struct soap *soap, int n)
{	return soap_instantiate_ns6__removeIteration(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns6__removeIteration(struct soap *soap, struct ns6__removeIteration *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns6__removeIteration * SOAP_FMAC4 soap_instantiate_ns6__removeIteration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__removeIteration(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__removeIteration, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns6__removeIteration;
		if (size)
			*size = sizeof(struct ns6__removeIteration);
	}
	else
	{	cp->ptr = (void*)new struct ns6__removeIteration[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns6__removeIteration);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns6__removeIteration*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__removeIteration(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns6__removeIteration %p -> %p\n", q, p));
	*(struct ns6__removeIteration*)p = *(struct ns6__removeIteration*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns6__removeIterationResponse(struct soap *soap, struct ns6__removeIterationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns6__removeIterationResponse(struct soap *soap, const struct ns6__removeIterationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__removeIterationResponse(struct soap *soap, const struct ns6__removeIterationResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns6__removeIterationResponse);
	if (soap_out_ns6__removeIterationResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__removeIterationResponse(struct soap *soap, const char *tag, int id, const struct ns6__removeIterationResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__removeIterationResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns6__removeIterationResponse * SOAP_FMAC4 soap_get_ns6__removeIterationResponse(struct soap *soap, struct ns6__removeIterationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__removeIterationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns6__removeIterationResponse * SOAP_FMAC4 soap_in_ns6__removeIterationResponse(struct soap *soap, const char *tag, struct ns6__removeIterationResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns6__removeIterationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__removeIterationResponse, sizeof(struct ns6__removeIterationResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns6__removeIterationResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns6__removeIterationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__removeIterationResponse, 0, sizeof(struct ns6__removeIterationResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns6__removeIterationResponse * SOAP_FMAC6 soap_new_ns6__removeIterationResponse(struct soap *soap, int n)
{	return soap_instantiate_ns6__removeIterationResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns6__removeIterationResponse(struct soap *soap, struct ns6__removeIterationResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns6__removeIterationResponse * SOAP_FMAC4 soap_instantiate_ns6__removeIterationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__removeIterationResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__removeIterationResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns6__removeIterationResponse;
		if (size)
			*size = sizeof(struct ns6__removeIterationResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns6__removeIterationResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns6__removeIterationResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns6__removeIterationResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__removeIterationResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns6__removeIterationResponse %p -> %p\n", q, p));
	*(struct ns6__removeIterationResponse*)p = *(struct ns6__removeIterationResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns6__addIteration(struct soap *soap, struct ns6__addIteration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_iteration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns6__addIteration(struct soap *soap, const struct ns6__addIteration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__IterationData(soap, &a->_iteration);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__addIteration(struct soap *soap, const struct ns6__addIteration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns6__addIteration);
	if (soap_out_ns6__addIteration(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__addIteration(struct soap *soap, const char *tag, int id, const struct ns6__addIteration *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__addIteration), type))
		return soap->error;
	if (soap_out_PointerTons4__IterationData(soap, "iteration", -1, &a->_iteration, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns6__addIteration * SOAP_FMAC4 soap_get_ns6__addIteration(struct soap *soap, struct ns6__addIteration *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__addIteration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns6__addIteration * SOAP_FMAC4 soap_in_ns6__addIteration(struct soap *soap, const char *tag, struct ns6__addIteration *a, const char *type)
{
	short soap_flag__iteration = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns6__addIteration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__addIteration, sizeof(struct ns6__addIteration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns6__addIteration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__iteration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__IterationData(soap, NULL, &a->_iteration, "ns4:IterationData"))
				{	soap_flag__iteration--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns6__addIteration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__addIteration, 0, sizeof(struct ns6__addIteration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns6__addIteration * SOAP_FMAC6 soap_new_ns6__addIteration(struct soap *soap, int n)
{	return soap_instantiate_ns6__addIteration(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns6__addIteration(struct soap *soap, struct ns6__addIteration *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns6__addIteration * SOAP_FMAC4 soap_instantiate_ns6__addIteration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__addIteration(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__addIteration, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns6__addIteration;
		if (size)
			*size = sizeof(struct ns6__addIteration);
	}
	else
	{	cp->ptr = (void*)new struct ns6__addIteration[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns6__addIteration);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns6__addIteration*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__addIteration(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns6__addIteration %p -> %p\n", q, p));
	*(struct ns6__addIteration*)p = *(struct ns6__addIteration*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns6__addIterationResponse(struct soap *soap, struct ns6__addIterationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_addIterationReturn = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns6__addIterationResponse(struct soap *soap, const struct ns6__addIterationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__IterationData(soap, &a->_addIterationReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__addIterationResponse(struct soap *soap, const struct ns6__addIterationResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns6__addIterationResponse);
	if (soap_out_ns6__addIterationResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__addIterationResponse(struct soap *soap, const char *tag, int id, const struct ns6__addIterationResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__addIterationResponse), type))
		return soap->error;
	if (soap_out_PointerTons4__IterationData(soap, "addIterationReturn", -1, &a->_addIterationReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns6__addIterationResponse * SOAP_FMAC4 soap_get_ns6__addIterationResponse(struct soap *soap, struct ns6__addIterationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__addIterationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns6__addIterationResponse * SOAP_FMAC4 soap_in_ns6__addIterationResponse(struct soap *soap, const char *tag, struct ns6__addIterationResponse *a, const char *type)
{
	short soap_flag__addIterationReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns6__addIterationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__addIterationResponse, sizeof(struct ns6__addIterationResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns6__addIterationResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__addIterationReturn && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__IterationData(soap, NULL, &a->_addIterationReturn, "ns4:IterationData"))
				{	soap_flag__addIterationReturn--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns6__addIterationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__addIterationResponse, 0, sizeof(struct ns6__addIterationResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns6__addIterationResponse * SOAP_FMAC6 soap_new_ns6__addIterationResponse(struct soap *soap, int n)
{	return soap_instantiate_ns6__addIterationResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns6__addIterationResponse(struct soap *soap, struct ns6__addIterationResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns6__addIterationResponse * SOAP_FMAC4 soap_instantiate_ns6__addIterationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__addIterationResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__addIterationResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns6__addIterationResponse;
		if (size)
			*size = sizeof(struct ns6__addIterationResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns6__addIterationResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns6__addIterationResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns6__addIterationResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__addIterationResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns6__addIterationResponse %p -> %p\n", q, p));
	*(struct ns6__addIterationResponse*)p = *(struct ns6__addIterationResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns6__removeProject(struct soap *soap, struct ns6__removeProject *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns6__removeProject(struct soap *soap, const struct ns6__removeProject *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__removeProject(struct soap *soap, const struct ns6__removeProject *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns6__removeProject);
	if (soap_out_ns6__removeProject(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__removeProject(struct soap *soap, const char *tag, int id, const struct ns6__removeProject *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__removeProject), type))
		return soap->error;
	if (soap_out_int(soap, "id", -1, &a->_id, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns6__removeProject * SOAP_FMAC4 soap_get_ns6__removeProject(struct soap *soap, struct ns6__removeProject *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__removeProject(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns6__removeProject * SOAP_FMAC4 soap_in_ns6__removeProject(struct soap *soap, const char *tag, struct ns6__removeProject *a, const char *type)
{
	short soap_flag__id = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns6__removeProject *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__removeProject, sizeof(struct ns6__removeProject), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns6__removeProject(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__id && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_id, "xsd:int"))
				{	soap_flag__id--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns6__removeProject *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__removeProject, 0, sizeof(struct ns6__removeProject), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__id > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns6__removeProject * SOAP_FMAC6 soap_new_ns6__removeProject(struct soap *soap, int n)
{	return soap_instantiate_ns6__removeProject(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns6__removeProject(struct soap *soap, struct ns6__removeProject *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns6__removeProject * SOAP_FMAC4 soap_instantiate_ns6__removeProject(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__removeProject(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__removeProject, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns6__removeProject;
		if (size)
			*size = sizeof(struct ns6__removeProject);
	}
	else
	{	cp->ptr = (void*)new struct ns6__removeProject[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns6__removeProject);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns6__removeProject*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__removeProject(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns6__removeProject %p -> %p\n", q, p));
	*(struct ns6__removeProject*)p = *(struct ns6__removeProject*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns6__removeProjectResponse(struct soap *soap, struct ns6__removeProjectResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns6__removeProjectResponse(struct soap *soap, const struct ns6__removeProjectResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__removeProjectResponse(struct soap *soap, const struct ns6__removeProjectResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns6__removeProjectResponse);
	if (soap_out_ns6__removeProjectResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__removeProjectResponse(struct soap *soap, const char *tag, int id, const struct ns6__removeProjectResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__removeProjectResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns6__removeProjectResponse * SOAP_FMAC4 soap_get_ns6__removeProjectResponse(struct soap *soap, struct ns6__removeProjectResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__removeProjectResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns6__removeProjectResponse * SOAP_FMAC4 soap_in_ns6__removeProjectResponse(struct soap *soap, const char *tag, struct ns6__removeProjectResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns6__removeProjectResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__removeProjectResponse, sizeof(struct ns6__removeProjectResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns6__removeProjectResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns6__removeProjectResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__removeProjectResponse, 0, sizeof(struct ns6__removeProjectResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns6__removeProjectResponse * SOAP_FMAC6 soap_new_ns6__removeProjectResponse(struct soap *soap, int n)
{	return soap_instantiate_ns6__removeProjectResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns6__removeProjectResponse(struct soap *soap, struct ns6__removeProjectResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns6__removeProjectResponse * SOAP_FMAC4 soap_instantiate_ns6__removeProjectResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__removeProjectResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__removeProjectResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns6__removeProjectResponse;
		if (size)
			*size = sizeof(struct ns6__removeProjectResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns6__removeProjectResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns6__removeProjectResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns6__removeProjectResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__removeProjectResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns6__removeProjectResponse %p -> %p\n", q, p));
	*(struct ns6__removeProjectResponse*)p = *(struct ns6__removeProjectResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns6__addProject(struct soap *soap, struct ns6__addProject *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_project = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns6__addProject(struct soap *soap, const struct ns6__addProject *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__ProjectData(soap, &a->_project);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__addProject(struct soap *soap, const struct ns6__addProject *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns6__addProject);
	if (soap_out_ns6__addProject(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__addProject(struct soap *soap, const char *tag, int id, const struct ns6__addProject *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__addProject), type))
		return soap->error;
	if (soap_out_PointerTons4__ProjectData(soap, "project", -1, &a->_project, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns6__addProject * SOAP_FMAC4 soap_get_ns6__addProject(struct soap *soap, struct ns6__addProject *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__addProject(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns6__addProject * SOAP_FMAC4 soap_in_ns6__addProject(struct soap *soap, const char *tag, struct ns6__addProject *a, const char *type)
{
	short soap_flag__project = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns6__addProject *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__addProject, sizeof(struct ns6__addProject), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns6__addProject(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__project && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__ProjectData(soap, NULL, &a->_project, "ns4:ProjectData"))
				{	soap_flag__project--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns6__addProject *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__addProject, 0, sizeof(struct ns6__addProject), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns6__addProject * SOAP_FMAC6 soap_new_ns6__addProject(struct soap *soap, int n)
{	return soap_instantiate_ns6__addProject(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns6__addProject(struct soap *soap, struct ns6__addProject *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns6__addProject * SOAP_FMAC4 soap_instantiate_ns6__addProject(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__addProject(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__addProject, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns6__addProject;
		if (size)
			*size = sizeof(struct ns6__addProject);
	}
	else
	{	cp->ptr = (void*)new struct ns6__addProject[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns6__addProject);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns6__addProject*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__addProject(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns6__addProject %p -> %p\n", q, p));
	*(struct ns6__addProject*)p = *(struct ns6__addProject*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns6__addProjectResponse(struct soap *soap, struct ns6__addProjectResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_addProjectReturn = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns6__addProjectResponse(struct soap *soap, const struct ns6__addProjectResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__ProjectData(soap, &a->_addProjectReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__addProjectResponse(struct soap *soap, const struct ns6__addProjectResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns6__addProjectResponse);
	if (soap_out_ns6__addProjectResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__addProjectResponse(struct soap *soap, const char *tag, int id, const struct ns6__addProjectResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__addProjectResponse), type))
		return soap->error;
	if (soap_out_PointerTons4__ProjectData(soap, "addProjectReturn", -1, &a->_addProjectReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns6__addProjectResponse * SOAP_FMAC4 soap_get_ns6__addProjectResponse(struct soap *soap, struct ns6__addProjectResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__addProjectResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns6__addProjectResponse * SOAP_FMAC4 soap_in_ns6__addProjectResponse(struct soap *soap, const char *tag, struct ns6__addProjectResponse *a, const char *type)
{
	short soap_flag__addProjectReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns6__addProjectResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__addProjectResponse, sizeof(struct ns6__addProjectResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns6__addProjectResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__addProjectReturn && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__ProjectData(soap, NULL, &a->_addProjectReturn, "ns4:ProjectData"))
				{	soap_flag__addProjectReturn--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns6__addProjectResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__addProjectResponse, 0, sizeof(struct ns6__addProjectResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns6__addProjectResponse * SOAP_FMAC6 soap_new_ns6__addProjectResponse(struct soap *soap, int n)
{	return soap_instantiate_ns6__addProjectResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns6__addProjectResponse(struct soap *soap, struct ns6__addProjectResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns6__addProjectResponse * SOAP_FMAC4 soap_instantiate_ns6__addProjectResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__addProjectResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__addProjectResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns6__addProjectResponse;
		if (size)
			*size = sizeof(struct ns6__addProjectResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns6__addProjectResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns6__addProjectResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns6__addProjectResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__addProjectResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns6__addProjectResponse %p -> %p\n", q, p));
	*(struct ns6__addProjectResponse*)p = *(struct ns6__addProjectResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns6__getProjects(struct soap *soap, struct ns6__getProjects *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns6__getProjects(struct soap *soap, const struct ns6__getProjects *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__getProjects(struct soap *soap, const struct ns6__getProjects *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns6__getProjects);
	if (soap_out_ns6__getProjects(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__getProjects(struct soap *soap, const char *tag, int id, const struct ns6__getProjects *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__getProjects), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns6__getProjects * SOAP_FMAC4 soap_get_ns6__getProjects(struct soap *soap, struct ns6__getProjects *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__getProjects(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns6__getProjects * SOAP_FMAC4 soap_in_ns6__getProjects(struct soap *soap, const char *tag, struct ns6__getProjects *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns6__getProjects *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__getProjects, sizeof(struct ns6__getProjects), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns6__getProjects(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns6__getProjects *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__getProjects, 0, sizeof(struct ns6__getProjects), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns6__getProjects * SOAP_FMAC6 soap_new_ns6__getProjects(struct soap *soap, int n)
{	return soap_instantiate_ns6__getProjects(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns6__getProjects(struct soap *soap, struct ns6__getProjects *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns6__getProjects * SOAP_FMAC4 soap_instantiate_ns6__getProjects(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__getProjects(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__getProjects, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns6__getProjects;
		if (size)
			*size = sizeof(struct ns6__getProjects);
	}
	else
	{	cp->ptr = (void*)new struct ns6__getProjects[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns6__getProjects);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns6__getProjects*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__getProjects(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns6__getProjects %p -> %p\n", q, p));
	*(struct ns6__getProjects*)p = *(struct ns6__getProjects*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns6__getProjectsResponse(struct soap *soap, struct ns6__getProjectsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->getProjectsReturn = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns6__getProjectsResponse(struct soap *soap, const struct ns6__getProjectsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToArrayOf_USCOREtns1_USCOREProjectData(soap, &a->getProjectsReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__getProjectsResponse(struct soap *soap, const struct ns6__getProjectsResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns6__getProjectsResponse);
	if (soap_out_ns6__getProjectsResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__getProjectsResponse(struct soap *soap, const char *tag, int id, const struct ns6__getProjectsResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__getProjectsResponse), type))
		return soap->error;
	if (soap_out_PointerToArrayOf_USCOREtns1_USCOREProjectData(soap, "getProjectsReturn", -1, &a->getProjectsReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns6__getProjectsResponse * SOAP_FMAC4 soap_get_ns6__getProjectsResponse(struct soap *soap, struct ns6__getProjectsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__getProjectsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns6__getProjectsResponse * SOAP_FMAC4 soap_in_ns6__getProjectsResponse(struct soap *soap, const char *tag, struct ns6__getProjectsResponse *a, const char *type)
{
	short soap_flag_getProjectsReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns6__getProjectsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__getProjectsResponse, sizeof(struct ns6__getProjectsResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns6__getProjectsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_getProjectsReturn && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOf_USCOREtns1_USCOREProjectData(soap, "getProjectsReturn", &a->getProjectsReturn, "ns4:ProjectData"))
				{	soap_flag_getProjectsReturn--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns6__getProjectsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__getProjectsResponse, 0, sizeof(struct ns6__getProjectsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns6__getProjectsResponse * SOAP_FMAC6 soap_new_ns6__getProjectsResponse(struct soap *soap, int n)
{	return soap_instantiate_ns6__getProjectsResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns6__getProjectsResponse(struct soap *soap, struct ns6__getProjectsResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns6__getProjectsResponse * SOAP_FMAC4 soap_instantiate_ns6__getProjectsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__getProjectsResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__getProjectsResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns6__getProjectsResponse;
		if (size)
			*size = sizeof(struct ns6__getProjectsResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns6__getProjectsResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns6__getProjectsResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns6__getProjectsResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__getProjectsResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns6__getProjectsResponse %p -> %p\n", q, p));
	*(struct ns6__getProjectsResponse*)p = *(struct ns6__getProjectsResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns6__getUserStory(struct soap *soap, struct ns6__getUserStory *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns6__getUserStory(struct soap *soap, const struct ns6__getUserStory *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__getUserStory(struct soap *soap, const struct ns6__getUserStory *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns6__getUserStory);
	if (soap_out_ns6__getUserStory(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__getUserStory(struct soap *soap, const char *tag, int id, const struct ns6__getUserStory *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__getUserStory), type))
		return soap->error;
	if (soap_out_int(soap, "id", -1, &a->_id, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns6__getUserStory * SOAP_FMAC4 soap_get_ns6__getUserStory(struct soap *soap, struct ns6__getUserStory *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__getUserStory(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns6__getUserStory * SOAP_FMAC4 soap_in_ns6__getUserStory(struct soap *soap, const char *tag, struct ns6__getUserStory *a, const char *type)
{
	short soap_flag__id = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns6__getUserStory *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__getUserStory, sizeof(struct ns6__getUserStory), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns6__getUserStory(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__id && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_id, "xsd:int"))
				{	soap_flag__id--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns6__getUserStory *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__getUserStory, 0, sizeof(struct ns6__getUserStory), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__id > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns6__getUserStory * SOAP_FMAC6 soap_new_ns6__getUserStory(struct soap *soap, int n)
{	return soap_instantiate_ns6__getUserStory(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns6__getUserStory(struct soap *soap, struct ns6__getUserStory *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns6__getUserStory * SOAP_FMAC4 soap_instantiate_ns6__getUserStory(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__getUserStory(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__getUserStory, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns6__getUserStory;
		if (size)
			*size = sizeof(struct ns6__getUserStory);
	}
	else
	{	cp->ptr = (void*)new struct ns6__getUserStory[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns6__getUserStory);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns6__getUserStory*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__getUserStory(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns6__getUserStory %p -> %p\n", q, p));
	*(struct ns6__getUserStory*)p = *(struct ns6__getUserStory*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns6__getUserStoryResponse(struct soap *soap, struct ns6__getUserStoryResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_getUserStoryReturn = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns6__getUserStoryResponse(struct soap *soap, const struct ns6__getUserStoryResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__UserStoryData(soap, &a->_getUserStoryReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__getUserStoryResponse(struct soap *soap, const struct ns6__getUserStoryResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns6__getUserStoryResponse);
	if (soap_out_ns6__getUserStoryResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__getUserStoryResponse(struct soap *soap, const char *tag, int id, const struct ns6__getUserStoryResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__getUserStoryResponse), type))
		return soap->error;
	if (soap_out_PointerTons4__UserStoryData(soap, "getUserStoryReturn", -1, &a->_getUserStoryReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns6__getUserStoryResponse * SOAP_FMAC4 soap_get_ns6__getUserStoryResponse(struct soap *soap, struct ns6__getUserStoryResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__getUserStoryResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns6__getUserStoryResponse * SOAP_FMAC4 soap_in_ns6__getUserStoryResponse(struct soap *soap, const char *tag, struct ns6__getUserStoryResponse *a, const char *type)
{
	short soap_flag__getUserStoryReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns6__getUserStoryResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__getUserStoryResponse, sizeof(struct ns6__getUserStoryResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns6__getUserStoryResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__getUserStoryReturn && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__UserStoryData(soap, NULL, &a->_getUserStoryReturn, "ns4:UserStoryData"))
				{	soap_flag__getUserStoryReturn--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns6__getUserStoryResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__getUserStoryResponse, 0, sizeof(struct ns6__getUserStoryResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns6__getUserStoryResponse * SOAP_FMAC6 soap_new_ns6__getUserStoryResponse(struct soap *soap, int n)
{	return soap_instantiate_ns6__getUserStoryResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns6__getUserStoryResponse(struct soap *soap, struct ns6__getUserStoryResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns6__getUserStoryResponse * SOAP_FMAC4 soap_instantiate_ns6__getUserStoryResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__getUserStoryResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__getUserStoryResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns6__getUserStoryResponse;
		if (size)
			*size = sizeof(struct ns6__getUserStoryResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns6__getUserStoryResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns6__getUserStoryResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns6__getUserStoryResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__getUserStoryResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns6__getUserStoryResponse %p -> %p\n", q, p));
	*(struct ns6__getUserStoryResponse*)p = *(struct ns6__getUserStoryResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns6__getTask(struct soap *soap, struct ns6__getTask *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns6__getTask(struct soap *soap, const struct ns6__getTask *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__getTask(struct soap *soap, const struct ns6__getTask *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns6__getTask);
	if (soap_out_ns6__getTask(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__getTask(struct soap *soap, const char *tag, int id, const struct ns6__getTask *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__getTask), type))
		return soap->error;
	if (soap_out_int(soap, "id", -1, &a->_id, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns6__getTask * SOAP_FMAC4 soap_get_ns6__getTask(struct soap *soap, struct ns6__getTask *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__getTask(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns6__getTask * SOAP_FMAC4 soap_in_ns6__getTask(struct soap *soap, const char *tag, struct ns6__getTask *a, const char *type)
{
	short soap_flag__id = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns6__getTask *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__getTask, sizeof(struct ns6__getTask), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns6__getTask(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__id && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_id, "xsd:int"))
				{	soap_flag__id--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns6__getTask *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__getTask, 0, sizeof(struct ns6__getTask), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__id > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns6__getTask * SOAP_FMAC6 soap_new_ns6__getTask(struct soap *soap, int n)
{	return soap_instantiate_ns6__getTask(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns6__getTask(struct soap *soap, struct ns6__getTask *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns6__getTask * SOAP_FMAC4 soap_instantiate_ns6__getTask(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__getTask(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__getTask, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns6__getTask;
		if (size)
			*size = sizeof(struct ns6__getTask);
	}
	else
	{	cp->ptr = (void*)new struct ns6__getTask[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns6__getTask);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns6__getTask*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__getTask(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns6__getTask %p -> %p\n", q, p));
	*(struct ns6__getTask*)p = *(struct ns6__getTask*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns6__getTaskResponse(struct soap *soap, struct ns6__getTaskResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_getTaskReturn = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns6__getTaskResponse(struct soap *soap, const struct ns6__getTaskResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__TaskData(soap, &a->_getTaskReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__getTaskResponse(struct soap *soap, const struct ns6__getTaskResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns6__getTaskResponse);
	if (soap_out_ns6__getTaskResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__getTaskResponse(struct soap *soap, const char *tag, int id, const struct ns6__getTaskResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__getTaskResponse), type))
		return soap->error;
	if (soap_out_PointerTons4__TaskData(soap, "getTaskReturn", -1, &a->_getTaskReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns6__getTaskResponse * SOAP_FMAC4 soap_get_ns6__getTaskResponse(struct soap *soap, struct ns6__getTaskResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__getTaskResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns6__getTaskResponse * SOAP_FMAC4 soap_in_ns6__getTaskResponse(struct soap *soap, const char *tag, struct ns6__getTaskResponse *a, const char *type)
{
	short soap_flag__getTaskReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns6__getTaskResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__getTaskResponse, sizeof(struct ns6__getTaskResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns6__getTaskResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__getTaskReturn && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__TaskData(soap, NULL, &a->_getTaskReturn, "ns4:TaskData"))
				{	soap_flag__getTaskReturn--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns6__getTaskResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__getTaskResponse, 0, sizeof(struct ns6__getTaskResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns6__getTaskResponse * SOAP_FMAC6 soap_new_ns6__getTaskResponse(struct soap *soap, int n)
{	return soap_instantiate_ns6__getTaskResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns6__getTaskResponse(struct soap *soap, struct ns6__getTaskResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns6__getTaskResponse * SOAP_FMAC4 soap_instantiate_ns6__getTaskResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__getTaskResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__getTaskResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns6__getTaskResponse;
		if (size)
			*size = sizeof(struct ns6__getTaskResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns6__getTaskResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns6__getTaskResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns6__getTaskResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__getTaskResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns6__getTaskResponse %p -> %p\n", q, p));
	*(struct ns6__getTaskResponse*)p = *(struct ns6__getTaskResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns6__getIteration(struct soap *soap, struct ns6__getIteration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns6__getIteration(struct soap *soap, const struct ns6__getIteration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__getIteration(struct soap *soap, const struct ns6__getIteration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns6__getIteration);
	if (soap_out_ns6__getIteration(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__getIteration(struct soap *soap, const char *tag, int id, const struct ns6__getIteration *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__getIteration), type))
		return soap->error;
	if (soap_out_int(soap, "id", -1, &a->_id, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns6__getIteration * SOAP_FMAC4 soap_get_ns6__getIteration(struct soap *soap, struct ns6__getIteration *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__getIteration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns6__getIteration * SOAP_FMAC4 soap_in_ns6__getIteration(struct soap *soap, const char *tag, struct ns6__getIteration *a, const char *type)
{
	short soap_flag__id = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns6__getIteration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__getIteration, sizeof(struct ns6__getIteration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns6__getIteration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__id && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_id, "xsd:int"))
				{	soap_flag__id--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns6__getIteration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__getIteration, 0, sizeof(struct ns6__getIteration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__id > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns6__getIteration * SOAP_FMAC6 soap_new_ns6__getIteration(struct soap *soap, int n)
{	return soap_instantiate_ns6__getIteration(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns6__getIteration(struct soap *soap, struct ns6__getIteration *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns6__getIteration * SOAP_FMAC4 soap_instantiate_ns6__getIteration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__getIteration(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__getIteration, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns6__getIteration;
		if (size)
			*size = sizeof(struct ns6__getIteration);
	}
	else
	{	cp->ptr = (void*)new struct ns6__getIteration[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns6__getIteration);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns6__getIteration*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__getIteration(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns6__getIteration %p -> %p\n", q, p));
	*(struct ns6__getIteration*)p = *(struct ns6__getIteration*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns6__getIterationResponse(struct soap *soap, struct ns6__getIterationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_getIterationReturn = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns6__getIterationResponse(struct soap *soap, const struct ns6__getIterationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__IterationData(soap, &a->_getIterationReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__getIterationResponse(struct soap *soap, const struct ns6__getIterationResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns6__getIterationResponse);
	if (soap_out_ns6__getIterationResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__getIterationResponse(struct soap *soap, const char *tag, int id, const struct ns6__getIterationResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__getIterationResponse), type))
		return soap->error;
	if (soap_out_PointerTons4__IterationData(soap, "getIterationReturn", -1, &a->_getIterationReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns6__getIterationResponse * SOAP_FMAC4 soap_get_ns6__getIterationResponse(struct soap *soap, struct ns6__getIterationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__getIterationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns6__getIterationResponse * SOAP_FMAC4 soap_in_ns6__getIterationResponse(struct soap *soap, const char *tag, struct ns6__getIterationResponse *a, const char *type)
{
	short soap_flag__getIterationReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns6__getIterationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__getIterationResponse, sizeof(struct ns6__getIterationResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns6__getIterationResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__getIterationReturn && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__IterationData(soap, NULL, &a->_getIterationReturn, "ns4:IterationData"))
				{	soap_flag__getIterationReturn--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns6__getIterationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__getIterationResponse, 0, sizeof(struct ns6__getIterationResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns6__getIterationResponse * SOAP_FMAC6 soap_new_ns6__getIterationResponse(struct soap *soap, int n)
{	return soap_instantiate_ns6__getIterationResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns6__getIterationResponse(struct soap *soap, struct ns6__getIterationResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns6__getIterationResponse * SOAP_FMAC4 soap_instantiate_ns6__getIterationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__getIterationResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__getIterationResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns6__getIterationResponse;
		if (size)
			*size = sizeof(struct ns6__getIterationResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns6__getIterationResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns6__getIterationResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns6__getIterationResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__getIterationResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns6__getIterationResponse %p -> %p\n", q, p));
	*(struct ns6__getIterationResponse*)p = *(struct ns6__getIterationResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns6__getProject(struct soap *soap, struct ns6__getProject *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns6__getProject(struct soap *soap, const struct ns6__getProject *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__getProject(struct soap *soap, const struct ns6__getProject *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns6__getProject);
	if (soap_out_ns6__getProject(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__getProject(struct soap *soap, const char *tag, int id, const struct ns6__getProject *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__getProject), type))
		return soap->error;
	if (soap_out_int(soap, "id", -1, &a->_id, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns6__getProject * SOAP_FMAC4 soap_get_ns6__getProject(struct soap *soap, struct ns6__getProject *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__getProject(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns6__getProject * SOAP_FMAC4 soap_in_ns6__getProject(struct soap *soap, const char *tag, struct ns6__getProject *a, const char *type)
{
	short soap_flag__id = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns6__getProject *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__getProject, sizeof(struct ns6__getProject), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns6__getProject(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__id && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_id, "xsd:int"))
				{	soap_flag__id--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns6__getProject *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__getProject, 0, sizeof(struct ns6__getProject), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__id > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns6__getProject * SOAP_FMAC6 soap_new_ns6__getProject(struct soap *soap, int n)
{	return soap_instantiate_ns6__getProject(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns6__getProject(struct soap *soap, struct ns6__getProject *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns6__getProject * SOAP_FMAC4 soap_instantiate_ns6__getProject(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__getProject(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__getProject, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns6__getProject;
		if (size)
			*size = sizeof(struct ns6__getProject);
	}
	else
	{	cp->ptr = (void*)new struct ns6__getProject[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns6__getProject);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns6__getProject*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__getProject(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns6__getProject %p -> %p\n", q, p));
	*(struct ns6__getProject*)p = *(struct ns6__getProject*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns6__getProjectResponse(struct soap *soap, struct ns6__getProjectResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_getProjectReturn = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns6__getProjectResponse(struct soap *soap, const struct ns6__getProjectResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__ProjectData(soap, &a->_getProjectReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__getProjectResponse(struct soap *soap, const struct ns6__getProjectResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns6__getProjectResponse);
	if (soap_out_ns6__getProjectResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__getProjectResponse(struct soap *soap, const char *tag, int id, const struct ns6__getProjectResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__getProjectResponse), type))
		return soap->error;
	if (soap_out_PointerTons4__ProjectData(soap, "getProjectReturn", -1, &a->_getProjectReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns6__getProjectResponse * SOAP_FMAC4 soap_get_ns6__getProjectResponse(struct soap *soap, struct ns6__getProjectResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__getProjectResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns6__getProjectResponse * SOAP_FMAC4 soap_in_ns6__getProjectResponse(struct soap *soap, const char *tag, struct ns6__getProjectResponse *a, const char *type)
{
	short soap_flag__getProjectReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns6__getProjectResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__getProjectResponse, sizeof(struct ns6__getProjectResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns6__getProjectResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__getProjectReturn && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__ProjectData(soap, NULL, &a->_getProjectReturn, "ns4:ProjectData"))
				{	soap_flag__getProjectReturn--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns6__getProjectResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__getProjectResponse, 0, sizeof(struct ns6__getProjectResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns6__getProjectResponse * SOAP_FMAC6 soap_new_ns6__getProjectResponse(struct soap *soap, int n)
{	return soap_instantiate_ns6__getProjectResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns6__getProjectResponse(struct soap *soap, struct ns6__getProjectResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns6__getProjectResponse * SOAP_FMAC4 soap_instantiate_ns6__getProjectResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__getProjectResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__getProjectResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns6__getProjectResponse;
		if (size)
			*size = sizeof(struct ns6__getProjectResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns6__getProjectResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns6__getProjectResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns6__getProjectResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__getProjectResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns6__getProjectResponse %p -> %p\n", q, p));
	*(struct ns6__getProjectResponse*)p = *(struct ns6__getProjectResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns6__getPeople(struct soap *soap, struct ns6__getPeople *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns6__getPeople(struct soap *soap, const struct ns6__getPeople *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__getPeople(struct soap *soap, const struct ns6__getPeople *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns6__getPeople);
	if (soap_out_ns6__getPeople(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__getPeople(struct soap *soap, const char *tag, int id, const struct ns6__getPeople *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__getPeople), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns6__getPeople * SOAP_FMAC4 soap_get_ns6__getPeople(struct soap *soap, struct ns6__getPeople *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__getPeople(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns6__getPeople * SOAP_FMAC4 soap_in_ns6__getPeople(struct soap *soap, const char *tag, struct ns6__getPeople *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns6__getPeople *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__getPeople, sizeof(struct ns6__getPeople), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns6__getPeople(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns6__getPeople *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__getPeople, 0, sizeof(struct ns6__getPeople), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns6__getPeople * SOAP_FMAC6 soap_new_ns6__getPeople(struct soap *soap, int n)
{	return soap_instantiate_ns6__getPeople(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns6__getPeople(struct soap *soap, struct ns6__getPeople *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns6__getPeople * SOAP_FMAC4 soap_instantiate_ns6__getPeople(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__getPeople(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__getPeople, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns6__getPeople;
		if (size)
			*size = sizeof(struct ns6__getPeople);
	}
	else
	{	cp->ptr = (void*)new struct ns6__getPeople[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns6__getPeople);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns6__getPeople*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__getPeople(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns6__getPeople %p -> %p\n", q, p));
	*(struct ns6__getPeople*)p = *(struct ns6__getPeople*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns6__getPeopleResponse(struct soap *soap, struct ns6__getPeopleResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->getPeopleReturn = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns6__getPeopleResponse(struct soap *soap, const struct ns6__getPeopleResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToArrayOf_USCOREtns1_USCOREPersonData(soap, &a->getPeopleReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__getPeopleResponse(struct soap *soap, const struct ns6__getPeopleResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns6__getPeopleResponse);
	if (soap_out_ns6__getPeopleResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__getPeopleResponse(struct soap *soap, const char *tag, int id, const struct ns6__getPeopleResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__getPeopleResponse), type))
		return soap->error;
	if (soap_out_PointerToArrayOf_USCOREtns1_USCOREPersonData(soap, "getPeopleReturn", -1, &a->getPeopleReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns6__getPeopleResponse * SOAP_FMAC4 soap_get_ns6__getPeopleResponse(struct soap *soap, struct ns6__getPeopleResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__getPeopleResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns6__getPeopleResponse * SOAP_FMAC4 soap_in_ns6__getPeopleResponse(struct soap *soap, const char *tag, struct ns6__getPeopleResponse *a, const char *type)
{
	short soap_flag_getPeopleReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns6__getPeopleResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__getPeopleResponse, sizeof(struct ns6__getPeopleResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns6__getPeopleResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_getPeopleReturn && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOf_USCOREtns1_USCOREPersonData(soap, "getPeopleReturn", &a->getPeopleReturn, "ns4:PersonData"))
				{	soap_flag_getPeopleReturn--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns6__getPeopleResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__getPeopleResponse, 0, sizeof(struct ns6__getPeopleResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns6__getPeopleResponse * SOAP_FMAC6 soap_new_ns6__getPeopleResponse(struct soap *soap, int n)
{	return soap_instantiate_ns6__getPeopleResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns6__getPeopleResponse(struct soap *soap, struct ns6__getPeopleResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns6__getPeopleResponse * SOAP_FMAC4 soap_instantiate_ns6__getPeopleResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__getPeopleResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__getPeopleResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns6__getPeopleResponse;
		if (size)
			*size = sizeof(struct ns6__getPeopleResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns6__getPeopleResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns6__getPeopleResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns6__getPeopleResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__getPeopleResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns6__getPeopleResponse %p -> %p\n", q, p));
	*(struct ns6__getPeopleResponse*)p = *(struct ns6__getPeopleResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns6__addTask(struct soap *soap, struct ns6__addTask *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_task = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns6__addTask(struct soap *soap, const struct ns6__addTask *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__TaskData(soap, &a->_task);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__addTask(struct soap *soap, const struct ns6__addTask *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns6__addTask);
	if (soap_out_ns6__addTask(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__addTask(struct soap *soap, const char *tag, int id, const struct ns6__addTask *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__addTask), type))
		return soap->error;
	if (soap_out_PointerTons4__TaskData(soap, "task", -1, &a->_task, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns6__addTask * SOAP_FMAC4 soap_get_ns6__addTask(struct soap *soap, struct ns6__addTask *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__addTask(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns6__addTask * SOAP_FMAC4 soap_in_ns6__addTask(struct soap *soap, const char *tag, struct ns6__addTask *a, const char *type)
{
	short soap_flag__task = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns6__addTask *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__addTask, sizeof(struct ns6__addTask), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns6__addTask(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__task && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__TaskData(soap, NULL, &a->_task, "ns4:TaskData"))
				{	soap_flag__task--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns6__addTask *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__addTask, 0, sizeof(struct ns6__addTask), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns6__addTask * SOAP_FMAC6 soap_new_ns6__addTask(struct soap *soap, int n)
{	return soap_instantiate_ns6__addTask(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns6__addTask(struct soap *soap, struct ns6__addTask *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns6__addTask * SOAP_FMAC4 soap_instantiate_ns6__addTask(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__addTask(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__addTask, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns6__addTask;
		if (size)
			*size = sizeof(struct ns6__addTask);
	}
	else
	{	cp->ptr = (void*)new struct ns6__addTask[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns6__addTask);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns6__addTask*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__addTask(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns6__addTask %p -> %p\n", q, p));
	*(struct ns6__addTask*)p = *(struct ns6__addTask*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns6__addTaskResponse(struct soap *soap, struct ns6__addTaskResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_addTaskReturn = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns6__addTaskResponse(struct soap *soap, const struct ns6__addTaskResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__TaskData(soap, &a->_addTaskReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__addTaskResponse(struct soap *soap, const struct ns6__addTaskResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns6__addTaskResponse);
	if (soap_out_ns6__addTaskResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__addTaskResponse(struct soap *soap, const char *tag, int id, const struct ns6__addTaskResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__addTaskResponse), type))
		return soap->error;
	if (soap_out_PointerTons4__TaskData(soap, "addTaskReturn", -1, &a->_addTaskReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns6__addTaskResponse * SOAP_FMAC4 soap_get_ns6__addTaskResponse(struct soap *soap, struct ns6__addTaskResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__addTaskResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns6__addTaskResponse * SOAP_FMAC4 soap_in_ns6__addTaskResponse(struct soap *soap, const char *tag, struct ns6__addTaskResponse *a, const char *type)
{
	short soap_flag__addTaskReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns6__addTaskResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__addTaskResponse, sizeof(struct ns6__addTaskResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns6__addTaskResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__addTaskReturn && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__TaskData(soap, NULL, &a->_addTaskReturn, "ns4:TaskData"))
				{	soap_flag__addTaskReturn--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns6__addTaskResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__addTaskResponse, 0, sizeof(struct ns6__addTaskResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns6__addTaskResponse * SOAP_FMAC6 soap_new_ns6__addTaskResponse(struct soap *soap, int n)
{	return soap_instantiate_ns6__addTaskResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns6__addTaskResponse(struct soap *soap, struct ns6__addTaskResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns6__addTaskResponse * SOAP_FMAC4 soap_instantiate_ns6__addTaskResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__addTaskResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__addTaskResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns6__addTaskResponse;
		if (size)
			*size = sizeof(struct ns6__addTaskResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns6__addTaskResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns6__addTaskResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns6__addTaskResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__addTaskResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns6__addTaskResponse %p -> %p\n", q, p));
	*(struct ns6__addTaskResponse*)p = *(struct ns6__addTaskResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns6__getCurrentTasksForPerson(struct soap *soap, struct ns6__getCurrentTasksForPerson *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_personId);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns6__getCurrentTasksForPerson(struct soap *soap, const struct ns6__getCurrentTasksForPerson *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__getCurrentTasksForPerson(struct soap *soap, const struct ns6__getCurrentTasksForPerson *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns6__getCurrentTasksForPerson);
	if (soap_out_ns6__getCurrentTasksForPerson(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__getCurrentTasksForPerson(struct soap *soap, const char *tag, int id, const struct ns6__getCurrentTasksForPerson *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__getCurrentTasksForPerson), type))
		return soap->error;
	if (soap_out_int(soap, "personId", -1, &a->_personId, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns6__getCurrentTasksForPerson * SOAP_FMAC4 soap_get_ns6__getCurrentTasksForPerson(struct soap *soap, struct ns6__getCurrentTasksForPerson *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__getCurrentTasksForPerson(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns6__getCurrentTasksForPerson * SOAP_FMAC4 soap_in_ns6__getCurrentTasksForPerson(struct soap *soap, const char *tag, struct ns6__getCurrentTasksForPerson *a, const char *type)
{
	short soap_flag__personId = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns6__getCurrentTasksForPerson *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__getCurrentTasksForPerson, sizeof(struct ns6__getCurrentTasksForPerson), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns6__getCurrentTasksForPerson(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__personId && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_personId, "xsd:int"))
				{	soap_flag__personId--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns6__getCurrentTasksForPerson *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__getCurrentTasksForPerson, 0, sizeof(struct ns6__getCurrentTasksForPerson), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__personId > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns6__getCurrentTasksForPerson * SOAP_FMAC6 soap_new_ns6__getCurrentTasksForPerson(struct soap *soap, int n)
{	return soap_instantiate_ns6__getCurrentTasksForPerson(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns6__getCurrentTasksForPerson(struct soap *soap, struct ns6__getCurrentTasksForPerson *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns6__getCurrentTasksForPerson * SOAP_FMAC4 soap_instantiate_ns6__getCurrentTasksForPerson(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__getCurrentTasksForPerson(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__getCurrentTasksForPerson, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns6__getCurrentTasksForPerson;
		if (size)
			*size = sizeof(struct ns6__getCurrentTasksForPerson);
	}
	else
	{	cp->ptr = (void*)new struct ns6__getCurrentTasksForPerson[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns6__getCurrentTasksForPerson);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns6__getCurrentTasksForPerson*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__getCurrentTasksForPerson(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns6__getCurrentTasksForPerson %p -> %p\n", q, p));
	*(struct ns6__getCurrentTasksForPerson*)p = *(struct ns6__getCurrentTasksForPerson*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns6__getCurrentTasksForPersonResponse(struct soap *soap, struct ns6__getCurrentTasksForPersonResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_getCurrentTasksForPersonReturn = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns6__getCurrentTasksForPersonResponse(struct soap *soap, const struct ns6__getCurrentTasksForPersonResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToArrayOf_USCOREtns1_USCORETaskData(soap, &a->_getCurrentTasksForPersonReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__getCurrentTasksForPersonResponse(struct soap *soap, const struct ns6__getCurrentTasksForPersonResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns6__getCurrentTasksForPersonResponse);
	if (soap_out_ns6__getCurrentTasksForPersonResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__getCurrentTasksForPersonResponse(struct soap *soap, const char *tag, int id, const struct ns6__getCurrentTasksForPersonResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__getCurrentTasksForPersonResponse), type))
		return soap->error;
	if (soap_out_PointerToArrayOf_USCOREtns1_USCORETaskData(soap, "getCurrentTasksForPersonReturn", -1, &a->_getCurrentTasksForPersonReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns6__getCurrentTasksForPersonResponse * SOAP_FMAC4 soap_get_ns6__getCurrentTasksForPersonResponse(struct soap *soap, struct ns6__getCurrentTasksForPersonResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__getCurrentTasksForPersonResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns6__getCurrentTasksForPersonResponse * SOAP_FMAC4 soap_in_ns6__getCurrentTasksForPersonResponse(struct soap *soap, const char *tag, struct ns6__getCurrentTasksForPersonResponse *a, const char *type)
{
	short soap_flag__getCurrentTasksForPersonReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns6__getCurrentTasksForPersonResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__getCurrentTasksForPersonResponse, sizeof(struct ns6__getCurrentTasksForPersonResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns6__getCurrentTasksForPersonResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__getCurrentTasksForPersonReturn && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOf_USCOREtns1_USCORETaskData(soap, NULL, &a->_getCurrentTasksForPersonReturn, "ns4:TaskData"))
				{	soap_flag__getCurrentTasksForPersonReturn--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns6__getCurrentTasksForPersonResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__getCurrentTasksForPersonResponse, 0, sizeof(struct ns6__getCurrentTasksForPersonResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns6__getCurrentTasksForPersonResponse * SOAP_FMAC6 soap_new_ns6__getCurrentTasksForPersonResponse(struct soap *soap, int n)
{	return soap_instantiate_ns6__getCurrentTasksForPersonResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns6__getCurrentTasksForPersonResponse(struct soap *soap, struct ns6__getCurrentTasksForPersonResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns6__getCurrentTasksForPersonResponse * SOAP_FMAC4 soap_instantiate_ns6__getCurrentTasksForPersonResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__getCurrentTasksForPersonResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__getCurrentTasksForPersonResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns6__getCurrentTasksForPersonResponse;
		if (size)
			*size = sizeof(struct ns6__getCurrentTasksForPersonResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns6__getCurrentTasksForPersonResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns6__getCurrentTasksForPersonResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns6__getCurrentTasksForPersonResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__getCurrentTasksForPersonResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns6__getCurrentTasksForPersonResponse %p -> %p\n", q, p));
	*(struct ns6__getCurrentTasksForPersonResponse*)p = *(struct ns6__getCurrentTasksForPersonResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns6__getTimeEntries(struct soap *soap, struct ns6__getTimeEntries *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_containerId);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns6__getTimeEntries(struct soap *soap, const struct ns6__getTimeEntries *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__getTimeEntries(struct soap *soap, const struct ns6__getTimeEntries *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns6__getTimeEntries);
	if (soap_out_ns6__getTimeEntries(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__getTimeEntries(struct soap *soap, const char *tag, int id, const struct ns6__getTimeEntries *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__getTimeEntries), type))
		return soap->error;
	if (soap_out_int(soap, "containerId", -1, &a->_containerId, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns6__getTimeEntries * SOAP_FMAC4 soap_get_ns6__getTimeEntries(struct soap *soap, struct ns6__getTimeEntries *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__getTimeEntries(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns6__getTimeEntries * SOAP_FMAC4 soap_in_ns6__getTimeEntries(struct soap *soap, const char *tag, struct ns6__getTimeEntries *a, const char *type)
{
	short soap_flag__containerId = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns6__getTimeEntries *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__getTimeEntries, sizeof(struct ns6__getTimeEntries), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns6__getTimeEntries(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__containerId && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_containerId, "xsd:int"))
				{	soap_flag__containerId--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns6__getTimeEntries *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__getTimeEntries, 0, sizeof(struct ns6__getTimeEntries), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__containerId > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns6__getTimeEntries * SOAP_FMAC6 soap_new_ns6__getTimeEntries(struct soap *soap, int n)
{	return soap_instantiate_ns6__getTimeEntries(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns6__getTimeEntries(struct soap *soap, struct ns6__getTimeEntries *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns6__getTimeEntries * SOAP_FMAC4 soap_instantiate_ns6__getTimeEntries(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__getTimeEntries(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__getTimeEntries, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns6__getTimeEntries;
		if (size)
			*size = sizeof(struct ns6__getTimeEntries);
	}
	else
	{	cp->ptr = (void*)new struct ns6__getTimeEntries[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns6__getTimeEntries);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns6__getTimeEntries*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__getTimeEntries(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns6__getTimeEntries %p -> %p\n", q, p));
	*(struct ns6__getTimeEntries*)p = *(struct ns6__getTimeEntries*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns6__getTimeEntriesResponse(struct soap *soap, struct ns6__getTimeEntriesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_getTimeEntriesReturn = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns6__getTimeEntriesResponse(struct soap *soap, const struct ns6__getTimeEntriesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToArrayOf_USCOREtns1_USCORETimeEntryData(soap, &a->_getTimeEntriesReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__getTimeEntriesResponse(struct soap *soap, const struct ns6__getTimeEntriesResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns6__getTimeEntriesResponse);
	if (soap_out_ns6__getTimeEntriesResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__getTimeEntriesResponse(struct soap *soap, const char *tag, int id, const struct ns6__getTimeEntriesResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__getTimeEntriesResponse), type))
		return soap->error;
	if (soap_out_PointerToArrayOf_USCOREtns1_USCORETimeEntryData(soap, "getTimeEntriesReturn", -1, &a->_getTimeEntriesReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns6__getTimeEntriesResponse * SOAP_FMAC4 soap_get_ns6__getTimeEntriesResponse(struct soap *soap, struct ns6__getTimeEntriesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__getTimeEntriesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns6__getTimeEntriesResponse * SOAP_FMAC4 soap_in_ns6__getTimeEntriesResponse(struct soap *soap, const char *tag, struct ns6__getTimeEntriesResponse *a, const char *type)
{
	short soap_flag__getTimeEntriesReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns6__getTimeEntriesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__getTimeEntriesResponse, sizeof(struct ns6__getTimeEntriesResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns6__getTimeEntriesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__getTimeEntriesReturn && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOf_USCOREtns1_USCORETimeEntryData(soap, NULL, &a->_getTimeEntriesReturn, "ns4:TimeEntryData"))
				{	soap_flag__getTimeEntriesReturn--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns6__getTimeEntriesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__getTimeEntriesResponse, 0, sizeof(struct ns6__getTimeEntriesResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns6__getTimeEntriesResponse * SOAP_FMAC6 soap_new_ns6__getTimeEntriesResponse(struct soap *soap, int n)
{	return soap_instantiate_ns6__getTimeEntriesResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns6__getTimeEntriesResponse(struct soap *soap, struct ns6__getTimeEntriesResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns6__getTimeEntriesResponse * SOAP_FMAC4 soap_instantiate_ns6__getTimeEntriesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__getTimeEntriesResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__getTimeEntriesResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns6__getTimeEntriesResponse;
		if (size)
			*size = sizeof(struct ns6__getTimeEntriesResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns6__getTimeEntriesResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns6__getTimeEntriesResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns6__getTimeEntriesResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__getTimeEntriesResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns6__getTimeEntriesResponse %p -> %p\n", q, p));
	*(struct ns6__getTimeEntriesResponse*)p = *(struct ns6__getTimeEntriesResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns6__getTasks(struct soap *soap, struct ns6__getTasks *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_containerId);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns6__getTasks(struct soap *soap, const struct ns6__getTasks *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__getTasks(struct soap *soap, const struct ns6__getTasks *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns6__getTasks);
	if (soap_out_ns6__getTasks(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__getTasks(struct soap *soap, const char *tag, int id, const struct ns6__getTasks *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__getTasks), type))
		return soap->error;
	if (soap_out_int(soap, "containerId", -1, &a->_containerId, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns6__getTasks * SOAP_FMAC4 soap_get_ns6__getTasks(struct soap *soap, struct ns6__getTasks *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__getTasks(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns6__getTasks * SOAP_FMAC4 soap_in_ns6__getTasks(struct soap *soap, const char *tag, struct ns6__getTasks *a, const char *type)
{
	short soap_flag__containerId = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns6__getTasks *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__getTasks, sizeof(struct ns6__getTasks), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns6__getTasks(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__containerId && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_containerId, "xsd:int"))
				{	soap_flag__containerId--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns6__getTasks *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__getTasks, 0, sizeof(struct ns6__getTasks), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__containerId > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns6__getTasks * SOAP_FMAC6 soap_new_ns6__getTasks(struct soap *soap, int n)
{	return soap_instantiate_ns6__getTasks(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns6__getTasks(struct soap *soap, struct ns6__getTasks *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns6__getTasks * SOAP_FMAC4 soap_instantiate_ns6__getTasks(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__getTasks(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__getTasks, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns6__getTasks;
		if (size)
			*size = sizeof(struct ns6__getTasks);
	}
	else
	{	cp->ptr = (void*)new struct ns6__getTasks[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns6__getTasks);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns6__getTasks*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__getTasks(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns6__getTasks %p -> %p\n", q, p));
	*(struct ns6__getTasks*)p = *(struct ns6__getTasks*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns6__getTasksResponse(struct soap *soap, struct ns6__getTasksResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_getTasksReturn = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns6__getTasksResponse(struct soap *soap, const struct ns6__getTasksResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToArrayOf_USCOREtns1_USCORETaskData(soap, &a->_getTasksReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__getTasksResponse(struct soap *soap, const struct ns6__getTasksResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns6__getTasksResponse);
	if (soap_out_ns6__getTasksResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__getTasksResponse(struct soap *soap, const char *tag, int id, const struct ns6__getTasksResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__getTasksResponse), type))
		return soap->error;
	if (soap_out_PointerToArrayOf_USCOREtns1_USCORETaskData(soap, "getTasksReturn", -1, &a->_getTasksReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns6__getTasksResponse * SOAP_FMAC4 soap_get_ns6__getTasksResponse(struct soap *soap, struct ns6__getTasksResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__getTasksResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns6__getTasksResponse * SOAP_FMAC4 soap_in_ns6__getTasksResponse(struct soap *soap, const char *tag, struct ns6__getTasksResponse *a, const char *type)
{
	short soap_flag__getTasksReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns6__getTasksResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__getTasksResponse, sizeof(struct ns6__getTasksResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns6__getTasksResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__getTasksReturn && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOf_USCOREtns1_USCORETaskData(soap, NULL, &a->_getTasksReturn, "ns4:TaskData"))
				{	soap_flag__getTasksReturn--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns6__getTasksResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__getTasksResponse, 0, sizeof(struct ns6__getTasksResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns6__getTasksResponse * SOAP_FMAC6 soap_new_ns6__getTasksResponse(struct soap *soap, int n)
{	return soap_instantiate_ns6__getTasksResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns6__getTasksResponse(struct soap *soap, struct ns6__getTasksResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns6__getTasksResponse * SOAP_FMAC4 soap_instantiate_ns6__getTasksResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__getTasksResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__getTasksResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns6__getTasksResponse;
		if (size)
			*size = sizeof(struct ns6__getTasksResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns6__getTasksResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns6__getTasksResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns6__getTasksResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__getTasksResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns6__getTasksResponse %p -> %p\n", q, p));
	*(struct ns6__getTasksResponse*)p = *(struct ns6__getTasksResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns6__getUserStories(struct soap *soap, struct ns6__getUserStories *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_containerId);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns6__getUserStories(struct soap *soap, const struct ns6__getUserStories *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__getUserStories(struct soap *soap, const struct ns6__getUserStories *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns6__getUserStories);
	if (soap_out_ns6__getUserStories(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__getUserStories(struct soap *soap, const char *tag, int id, const struct ns6__getUserStories *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__getUserStories), type))
		return soap->error;
	if (soap_out_int(soap, "containerId", -1, &a->_containerId, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns6__getUserStories * SOAP_FMAC4 soap_get_ns6__getUserStories(struct soap *soap, struct ns6__getUserStories *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__getUserStories(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns6__getUserStories * SOAP_FMAC4 soap_in_ns6__getUserStories(struct soap *soap, const char *tag, struct ns6__getUserStories *a, const char *type)
{
	short soap_flag__containerId = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns6__getUserStories *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__getUserStories, sizeof(struct ns6__getUserStories), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns6__getUserStories(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__containerId && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_containerId, "xsd:int"))
				{	soap_flag__containerId--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns6__getUserStories *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__getUserStories, 0, sizeof(struct ns6__getUserStories), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__containerId > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns6__getUserStories * SOAP_FMAC6 soap_new_ns6__getUserStories(struct soap *soap, int n)
{	return soap_instantiate_ns6__getUserStories(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns6__getUserStories(struct soap *soap, struct ns6__getUserStories *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns6__getUserStories * SOAP_FMAC4 soap_instantiate_ns6__getUserStories(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__getUserStories(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__getUserStories, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns6__getUserStories;
		if (size)
			*size = sizeof(struct ns6__getUserStories);
	}
	else
	{	cp->ptr = (void*)new struct ns6__getUserStories[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns6__getUserStories);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns6__getUserStories*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__getUserStories(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns6__getUserStories %p -> %p\n", q, p));
	*(struct ns6__getUserStories*)p = *(struct ns6__getUserStories*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns6__getUserStoriesResponse(struct soap *soap, struct ns6__getUserStoriesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_getUserStoriesReturn = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns6__getUserStoriesResponse(struct soap *soap, const struct ns6__getUserStoriesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToArrayOf_USCOREtns1_USCOREUserStoryData(soap, &a->_getUserStoriesReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__getUserStoriesResponse(struct soap *soap, const struct ns6__getUserStoriesResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns6__getUserStoriesResponse);
	if (soap_out_ns6__getUserStoriesResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__getUserStoriesResponse(struct soap *soap, const char *tag, int id, const struct ns6__getUserStoriesResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__getUserStoriesResponse), type))
		return soap->error;
	if (soap_out_PointerToArrayOf_USCOREtns1_USCOREUserStoryData(soap, "getUserStoriesReturn", -1, &a->_getUserStoriesReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns6__getUserStoriesResponse * SOAP_FMAC4 soap_get_ns6__getUserStoriesResponse(struct soap *soap, struct ns6__getUserStoriesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__getUserStoriesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns6__getUserStoriesResponse * SOAP_FMAC4 soap_in_ns6__getUserStoriesResponse(struct soap *soap, const char *tag, struct ns6__getUserStoriesResponse *a, const char *type)
{
	short soap_flag__getUserStoriesReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns6__getUserStoriesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__getUserStoriesResponse, sizeof(struct ns6__getUserStoriesResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns6__getUserStoriesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__getUserStoriesReturn && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOf_USCOREtns1_USCOREUserStoryData(soap, NULL, &a->_getUserStoriesReturn, "ns4:UserStoryData"))
				{	soap_flag__getUserStoriesReturn--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns6__getUserStoriesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__getUserStoriesResponse, 0, sizeof(struct ns6__getUserStoriesResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns6__getUserStoriesResponse * SOAP_FMAC6 soap_new_ns6__getUserStoriesResponse(struct soap *soap, int n)
{	return soap_instantiate_ns6__getUserStoriesResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns6__getUserStoriesResponse(struct soap *soap, struct ns6__getUserStoriesResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns6__getUserStoriesResponse * SOAP_FMAC4 soap_instantiate_ns6__getUserStoriesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__getUserStoriesResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__getUserStoriesResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns6__getUserStoriesResponse;
		if (size)
			*size = sizeof(struct ns6__getUserStoriesResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns6__getUserStoriesResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns6__getUserStoriesResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns6__getUserStoriesResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__getUserStoriesResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns6__getUserStoriesResponse %p -> %p\n", q, p));
	*(struct ns6__getUserStoriesResponse*)p = *(struct ns6__getUserStoriesResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns6__getCurrentIteration(struct soap *soap, struct ns6__getCurrentIteration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_projectId);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns6__getCurrentIteration(struct soap *soap, const struct ns6__getCurrentIteration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__getCurrentIteration(struct soap *soap, const struct ns6__getCurrentIteration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns6__getCurrentIteration);
	if (soap_out_ns6__getCurrentIteration(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__getCurrentIteration(struct soap *soap, const char *tag, int id, const struct ns6__getCurrentIteration *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__getCurrentIteration), type))
		return soap->error;
	if (soap_out_int(soap, "projectId", -1, &a->_projectId, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns6__getCurrentIteration * SOAP_FMAC4 soap_get_ns6__getCurrentIteration(struct soap *soap, struct ns6__getCurrentIteration *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__getCurrentIteration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns6__getCurrentIteration * SOAP_FMAC4 soap_in_ns6__getCurrentIteration(struct soap *soap, const char *tag, struct ns6__getCurrentIteration *a, const char *type)
{
	short soap_flag__projectId = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns6__getCurrentIteration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__getCurrentIteration, sizeof(struct ns6__getCurrentIteration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns6__getCurrentIteration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__projectId && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_projectId, "xsd:int"))
				{	soap_flag__projectId--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns6__getCurrentIteration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__getCurrentIteration, 0, sizeof(struct ns6__getCurrentIteration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__projectId > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns6__getCurrentIteration * SOAP_FMAC6 soap_new_ns6__getCurrentIteration(struct soap *soap, int n)
{	return soap_instantiate_ns6__getCurrentIteration(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns6__getCurrentIteration(struct soap *soap, struct ns6__getCurrentIteration *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns6__getCurrentIteration * SOAP_FMAC4 soap_instantiate_ns6__getCurrentIteration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__getCurrentIteration(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__getCurrentIteration, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns6__getCurrentIteration;
		if (size)
			*size = sizeof(struct ns6__getCurrentIteration);
	}
	else
	{	cp->ptr = (void*)new struct ns6__getCurrentIteration[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns6__getCurrentIteration);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns6__getCurrentIteration*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__getCurrentIteration(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns6__getCurrentIteration %p -> %p\n", q, p));
	*(struct ns6__getCurrentIteration*)p = *(struct ns6__getCurrentIteration*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns6__getCurrentIterationResponse(struct soap *soap, struct ns6__getCurrentIterationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_getCurrentIterationReturn = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns6__getCurrentIterationResponse(struct soap *soap, const struct ns6__getCurrentIterationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__IterationData(soap, &a->_getCurrentIterationReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__getCurrentIterationResponse(struct soap *soap, const struct ns6__getCurrentIterationResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns6__getCurrentIterationResponse);
	if (soap_out_ns6__getCurrentIterationResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__getCurrentIterationResponse(struct soap *soap, const char *tag, int id, const struct ns6__getCurrentIterationResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__getCurrentIterationResponse), type))
		return soap->error;
	if (soap_out_PointerTons4__IterationData(soap, "getCurrentIterationReturn", -1, &a->_getCurrentIterationReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns6__getCurrentIterationResponse * SOAP_FMAC4 soap_get_ns6__getCurrentIterationResponse(struct soap *soap, struct ns6__getCurrentIterationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__getCurrentIterationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns6__getCurrentIterationResponse * SOAP_FMAC4 soap_in_ns6__getCurrentIterationResponse(struct soap *soap, const char *tag, struct ns6__getCurrentIterationResponse *a, const char *type)
{
	short soap_flag__getCurrentIterationReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns6__getCurrentIterationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__getCurrentIterationResponse, sizeof(struct ns6__getCurrentIterationResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns6__getCurrentIterationResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__getCurrentIterationReturn && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__IterationData(soap, NULL, &a->_getCurrentIterationReturn, "ns4:IterationData"))
				{	soap_flag__getCurrentIterationReturn--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns6__getCurrentIterationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__getCurrentIterationResponse, 0, sizeof(struct ns6__getCurrentIterationResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns6__getCurrentIterationResponse * SOAP_FMAC6 soap_new_ns6__getCurrentIterationResponse(struct soap *soap, int n)
{	return soap_instantiate_ns6__getCurrentIterationResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns6__getCurrentIterationResponse(struct soap *soap, struct ns6__getCurrentIterationResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns6__getCurrentIterationResponse * SOAP_FMAC4 soap_instantiate_ns6__getCurrentIterationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__getCurrentIterationResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__getCurrentIterationResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns6__getCurrentIterationResponse;
		if (size)
			*size = sizeof(struct ns6__getCurrentIterationResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns6__getCurrentIterationResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns6__getCurrentIterationResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns6__getCurrentIterationResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__getCurrentIterationResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns6__getCurrentIterationResponse %p -> %p\n", q, p));
	*(struct ns6__getCurrentIterationResponse*)p = *(struct ns6__getCurrentIterationResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns6__getIterations(struct soap *soap, struct ns6__getIterations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_projectId);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns6__getIterations(struct soap *soap, const struct ns6__getIterations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__getIterations(struct soap *soap, const struct ns6__getIterations *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns6__getIterations);
	if (soap_out_ns6__getIterations(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__getIterations(struct soap *soap, const char *tag, int id, const struct ns6__getIterations *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__getIterations), type))
		return soap->error;
	if (soap_out_int(soap, "projectId", -1, &a->_projectId, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns6__getIterations * SOAP_FMAC4 soap_get_ns6__getIterations(struct soap *soap, struct ns6__getIterations *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__getIterations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns6__getIterations * SOAP_FMAC4 soap_in_ns6__getIterations(struct soap *soap, const char *tag, struct ns6__getIterations *a, const char *type)
{
	short soap_flag__projectId = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns6__getIterations *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__getIterations, sizeof(struct ns6__getIterations), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns6__getIterations(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__projectId && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_projectId, "xsd:int"))
				{	soap_flag__projectId--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns6__getIterations *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__getIterations, 0, sizeof(struct ns6__getIterations), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__projectId > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns6__getIterations * SOAP_FMAC6 soap_new_ns6__getIterations(struct soap *soap, int n)
{	return soap_instantiate_ns6__getIterations(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns6__getIterations(struct soap *soap, struct ns6__getIterations *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns6__getIterations * SOAP_FMAC4 soap_instantiate_ns6__getIterations(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__getIterations(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__getIterations, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns6__getIterations;
		if (size)
			*size = sizeof(struct ns6__getIterations);
	}
	else
	{	cp->ptr = (void*)new struct ns6__getIterations[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns6__getIterations);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns6__getIterations*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__getIterations(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns6__getIterations %p -> %p\n", q, p));
	*(struct ns6__getIterations*)p = *(struct ns6__getIterations*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns6__getIterationsResponse(struct soap *soap, struct ns6__getIterationsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_getIterationsReturn = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns6__getIterationsResponse(struct soap *soap, const struct ns6__getIterationsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToArrayOf_USCOREtns1_USCOREIterationData(soap, &a->_getIterationsReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__getIterationsResponse(struct soap *soap, const struct ns6__getIterationsResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns6__getIterationsResponse);
	if (soap_out_ns6__getIterationsResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__getIterationsResponse(struct soap *soap, const char *tag, int id, const struct ns6__getIterationsResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__getIterationsResponse), type))
		return soap->error;
	if (soap_out_PointerToArrayOf_USCOREtns1_USCOREIterationData(soap, "getIterationsReturn", -1, &a->_getIterationsReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns6__getIterationsResponse * SOAP_FMAC4 soap_get_ns6__getIterationsResponse(struct soap *soap, struct ns6__getIterationsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__getIterationsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns6__getIterationsResponse * SOAP_FMAC4 soap_in_ns6__getIterationsResponse(struct soap *soap, const char *tag, struct ns6__getIterationsResponse *a, const char *type)
{
	short soap_flag__getIterationsReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns6__getIterationsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__getIterationsResponse, sizeof(struct ns6__getIterationsResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns6__getIterationsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__getIterationsReturn && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOf_USCOREtns1_USCOREIterationData(soap, NULL, &a->_getIterationsReturn, "ns4:IterationData"))
				{	soap_flag__getIterationsReturn--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns6__getIterationsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__getIterationsResponse, 0, sizeof(struct ns6__getIterationsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns6__getIterationsResponse * SOAP_FMAC6 soap_new_ns6__getIterationsResponse(struct soap *soap, int n)
{	return soap_instantiate_ns6__getIterationsResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns6__getIterationsResponse(struct soap *soap, struct ns6__getIterationsResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns6__getIterationsResponse * SOAP_FMAC4 soap_instantiate_ns6__getIterationsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__getIterationsResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__getIterationsResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns6__getIterationsResponse;
		if (size)
			*size = sizeof(struct ns6__getIterationsResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns6__getIterationsResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns6__getIterationsResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns6__getIterationsResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__getIterationsResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns6__getIterationsResponse %p -> %p\n", q, p));
	*(struct ns6__getIterationsResponse*)p = *(struct ns6__getIterationsResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns6__getPerson(struct soap *soap, struct ns6__getPerson *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns6__getPerson(struct soap *soap, const struct ns6__getPerson *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__getPerson(struct soap *soap, const struct ns6__getPerson *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns6__getPerson);
	if (soap_out_ns6__getPerson(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__getPerson(struct soap *soap, const char *tag, int id, const struct ns6__getPerson *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__getPerson), type))
		return soap->error;
	if (soap_out_int(soap, "id", -1, &a->_id, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns6__getPerson * SOAP_FMAC4 soap_get_ns6__getPerson(struct soap *soap, struct ns6__getPerson *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__getPerson(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns6__getPerson * SOAP_FMAC4 soap_in_ns6__getPerson(struct soap *soap, const char *tag, struct ns6__getPerson *a, const char *type)
{
	short soap_flag__id = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns6__getPerson *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__getPerson, sizeof(struct ns6__getPerson), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns6__getPerson(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__id && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_id, "xsd:int"))
				{	soap_flag__id--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns6__getPerson *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__getPerson, 0, sizeof(struct ns6__getPerson), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__id > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns6__getPerson * SOAP_FMAC6 soap_new_ns6__getPerson(struct soap *soap, int n)
{	return soap_instantiate_ns6__getPerson(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns6__getPerson(struct soap *soap, struct ns6__getPerson *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns6__getPerson * SOAP_FMAC4 soap_instantiate_ns6__getPerson(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__getPerson(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__getPerson, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns6__getPerson;
		if (size)
			*size = sizeof(struct ns6__getPerson);
	}
	else
	{	cp->ptr = (void*)new struct ns6__getPerson[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns6__getPerson);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns6__getPerson*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__getPerson(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns6__getPerson %p -> %p\n", q, p));
	*(struct ns6__getPerson*)p = *(struct ns6__getPerson*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns6__getPersonResponse(struct soap *soap, struct ns6__getPersonResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_getPersonReturn = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns6__getPersonResponse(struct soap *soap, const struct ns6__getPersonResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__PersonData(soap, &a->_getPersonReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__getPersonResponse(struct soap *soap, const struct ns6__getPersonResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns6__getPersonResponse);
	if (soap_out_ns6__getPersonResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__getPersonResponse(struct soap *soap, const char *tag, int id, const struct ns6__getPersonResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__getPersonResponse), type))
		return soap->error;
	if (soap_out_PointerTons4__PersonData(soap, "getPersonReturn", -1, &a->_getPersonReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns6__getPersonResponse * SOAP_FMAC4 soap_get_ns6__getPersonResponse(struct soap *soap, struct ns6__getPersonResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__getPersonResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns6__getPersonResponse * SOAP_FMAC4 soap_in_ns6__getPersonResponse(struct soap *soap, const char *tag, struct ns6__getPersonResponse *a, const char *type)
{
	short soap_flag__getPersonReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns6__getPersonResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__getPersonResponse, sizeof(struct ns6__getPersonResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns6__getPersonResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__getPersonReturn && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__PersonData(soap, NULL, &a->_getPersonReturn, "ns4:PersonData"))
				{	soap_flag__getPersonReturn--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns6__getPersonResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__getPersonResponse, 0, sizeof(struct ns6__getPersonResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns6__getPersonResponse * SOAP_FMAC6 soap_new_ns6__getPersonResponse(struct soap *soap, int n)
{	return soap_instantiate_ns6__getPersonResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns6__getPersonResponse(struct soap *soap, struct ns6__getPersonResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns6__getPersonResponse * SOAP_FMAC4 soap_instantiate_ns6__getPersonResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__getPersonResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__getPersonResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns6__getPersonResponse;
		if (size)
			*size = sizeof(struct ns6__getPersonResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns6__getPersonResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns6__getPersonResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns6__getPersonResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__getPersonResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns6__getPersonResponse %p -> %p\n", q, p));
	*(struct ns6__getPersonResponse*)p = *(struct ns6__getPersonResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns6__removeNote(struct soap *soap, struct ns6__removeNote *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns6__removeNote(struct soap *soap, const struct ns6__removeNote *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__removeNote(struct soap *soap, const struct ns6__removeNote *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns6__removeNote);
	if (soap_out_ns6__removeNote(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__removeNote(struct soap *soap, const char *tag, int id, const struct ns6__removeNote *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__removeNote), type))
		return soap->error;
	if (soap_out_int(soap, "id", -1, &a->_id, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns6__removeNote * SOAP_FMAC4 soap_get_ns6__removeNote(struct soap *soap, struct ns6__removeNote *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__removeNote(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns6__removeNote * SOAP_FMAC4 soap_in_ns6__removeNote(struct soap *soap, const char *tag, struct ns6__removeNote *a, const char *type)
{
	short soap_flag__id = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns6__removeNote *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__removeNote, sizeof(struct ns6__removeNote), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns6__removeNote(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__id && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_id, "xsd:int"))
				{	soap_flag__id--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns6__removeNote *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__removeNote, 0, sizeof(struct ns6__removeNote), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__id > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns6__removeNote * SOAP_FMAC6 soap_new_ns6__removeNote(struct soap *soap, int n)
{	return soap_instantiate_ns6__removeNote(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns6__removeNote(struct soap *soap, struct ns6__removeNote *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns6__removeNote * SOAP_FMAC4 soap_instantiate_ns6__removeNote(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__removeNote(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__removeNote, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns6__removeNote;
		if (size)
			*size = sizeof(struct ns6__removeNote);
	}
	else
	{	cp->ptr = (void*)new struct ns6__removeNote[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns6__removeNote);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns6__removeNote*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__removeNote(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns6__removeNote %p -> %p\n", q, p));
	*(struct ns6__removeNote*)p = *(struct ns6__removeNote*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns6__removeNoteResponse(struct soap *soap, struct ns6__removeNoteResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns6__removeNoteResponse(struct soap *soap, const struct ns6__removeNoteResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__removeNoteResponse(struct soap *soap, const struct ns6__removeNoteResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns6__removeNoteResponse);
	if (soap_out_ns6__removeNoteResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__removeNoteResponse(struct soap *soap, const char *tag, int id, const struct ns6__removeNoteResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__removeNoteResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns6__removeNoteResponse * SOAP_FMAC4 soap_get_ns6__removeNoteResponse(struct soap *soap, struct ns6__removeNoteResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__removeNoteResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns6__removeNoteResponse * SOAP_FMAC4 soap_in_ns6__removeNoteResponse(struct soap *soap, const char *tag, struct ns6__removeNoteResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns6__removeNoteResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__removeNoteResponse, sizeof(struct ns6__removeNoteResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns6__removeNoteResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns6__removeNoteResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__removeNoteResponse, 0, sizeof(struct ns6__removeNoteResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns6__removeNoteResponse * SOAP_FMAC6 soap_new_ns6__removeNoteResponse(struct soap *soap, int n)
{	return soap_instantiate_ns6__removeNoteResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns6__removeNoteResponse(struct soap *soap, struct ns6__removeNoteResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns6__removeNoteResponse * SOAP_FMAC4 soap_instantiate_ns6__removeNoteResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__removeNoteResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__removeNoteResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns6__removeNoteResponse;
		if (size)
			*size = sizeof(struct ns6__removeNoteResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns6__removeNoteResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns6__removeNoteResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns6__removeNoteResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__removeNoteResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns6__removeNoteResponse %p -> %p\n", q, p));
	*(struct ns6__removeNoteResponse*)p = *(struct ns6__removeNoteResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns6__getNote(struct soap *soap, struct ns6__getNote *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns6__getNote(struct soap *soap, const struct ns6__getNote *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__getNote(struct soap *soap, const struct ns6__getNote *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns6__getNote);
	if (soap_out_ns6__getNote(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__getNote(struct soap *soap, const char *tag, int id, const struct ns6__getNote *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__getNote), type))
		return soap->error;
	if (soap_out_int(soap, "id", -1, &a->_id, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns6__getNote * SOAP_FMAC4 soap_get_ns6__getNote(struct soap *soap, struct ns6__getNote *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__getNote(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns6__getNote * SOAP_FMAC4 soap_in_ns6__getNote(struct soap *soap, const char *tag, struct ns6__getNote *a, const char *type)
{
	short soap_flag__id = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns6__getNote *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__getNote, sizeof(struct ns6__getNote), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns6__getNote(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__id && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_id, "xsd:int"))
				{	soap_flag__id--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns6__getNote *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__getNote, 0, sizeof(struct ns6__getNote), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__id > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns6__getNote * SOAP_FMAC6 soap_new_ns6__getNote(struct soap *soap, int n)
{	return soap_instantiate_ns6__getNote(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns6__getNote(struct soap *soap, struct ns6__getNote *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns6__getNote * SOAP_FMAC4 soap_instantiate_ns6__getNote(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__getNote(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__getNote, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns6__getNote;
		if (size)
			*size = sizeof(struct ns6__getNote);
	}
	else
	{	cp->ptr = (void*)new struct ns6__getNote[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns6__getNote);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns6__getNote*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__getNote(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns6__getNote %p -> %p\n", q, p));
	*(struct ns6__getNote*)p = *(struct ns6__getNote*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns6__getNoteResponse(struct soap *soap, struct ns6__getNoteResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_getNoteReturn = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns6__getNoteResponse(struct soap *soap, const struct ns6__getNoteResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__NoteData(soap, &a->_getNoteReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__getNoteResponse(struct soap *soap, const struct ns6__getNoteResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns6__getNoteResponse);
	if (soap_out_ns6__getNoteResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__getNoteResponse(struct soap *soap, const char *tag, int id, const struct ns6__getNoteResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__getNoteResponse), type))
		return soap->error;
	if (soap_out_PointerTons4__NoteData(soap, "getNoteReturn", -1, &a->_getNoteReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns6__getNoteResponse * SOAP_FMAC4 soap_get_ns6__getNoteResponse(struct soap *soap, struct ns6__getNoteResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__getNoteResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns6__getNoteResponse * SOAP_FMAC4 soap_in_ns6__getNoteResponse(struct soap *soap, const char *tag, struct ns6__getNoteResponse *a, const char *type)
{
	short soap_flag__getNoteReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns6__getNoteResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__getNoteResponse, sizeof(struct ns6__getNoteResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns6__getNoteResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__getNoteReturn && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__NoteData(soap, NULL, &a->_getNoteReturn, "ns4:NoteData"))
				{	soap_flag__getNoteReturn--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns6__getNoteResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__getNoteResponse, 0, sizeof(struct ns6__getNoteResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns6__getNoteResponse * SOAP_FMAC6 soap_new_ns6__getNoteResponse(struct soap *soap, int n)
{	return soap_instantiate_ns6__getNoteResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns6__getNoteResponse(struct soap *soap, struct ns6__getNoteResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns6__getNoteResponse * SOAP_FMAC4 soap_instantiate_ns6__getNoteResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__getNoteResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__getNoteResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns6__getNoteResponse;
		if (size)
			*size = sizeof(struct ns6__getNoteResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns6__getNoteResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns6__getNoteResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns6__getNoteResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__getNoteResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns6__getNoteResponse %p -> %p\n", q, p));
	*(struct ns6__getNoteResponse*)p = *(struct ns6__getNoteResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns6__setAttribute(struct soap *soap, struct ns6__setAttribute *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_objectId);
	soap_default_string(soap, &a->_key);
	soap_default_string(soap, &a->_value);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns6__setAttribute(struct soap *soap, const struct ns6__setAttribute *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_key);
	soap_serialize_string(soap, &a->_value);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__setAttribute(struct soap *soap, const struct ns6__setAttribute *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns6__setAttribute);
	if (soap_out_ns6__setAttribute(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__setAttribute(struct soap *soap, const char *tag, int id, const struct ns6__setAttribute *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__setAttribute), type))
		return soap->error;
	if (soap_out_int(soap, "objectId", -1, &a->_objectId, ""))
		return soap->error;
	if (soap_out_string(soap, "key", -1, &a->_key, ""))
		return soap->error;
	if (soap_out_string(soap, "value", -1, &a->_value, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns6__setAttribute * SOAP_FMAC4 soap_get_ns6__setAttribute(struct soap *soap, struct ns6__setAttribute *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__setAttribute(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns6__setAttribute * SOAP_FMAC4 soap_in_ns6__setAttribute(struct soap *soap, const char *tag, struct ns6__setAttribute *a, const char *type)
{
	short soap_flag__objectId = 1, soap_flag__key = 1, soap_flag__value = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns6__setAttribute *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__setAttribute, sizeof(struct ns6__setAttribute), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns6__setAttribute(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__objectId && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_objectId, "xsd:int"))
				{	soap_flag__objectId--;
					continue;
				}
			if (soap_flag__key && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_key, "xsd:string"))
				{	soap_flag__key--;
					continue;
				}
			if (soap_flag__value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_value, "xsd:string"))
				{	soap_flag__value--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns6__setAttribute *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__setAttribute, 0, sizeof(struct ns6__setAttribute), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__objectId > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns6__setAttribute * SOAP_FMAC6 soap_new_ns6__setAttribute(struct soap *soap, int n)
{	return soap_instantiate_ns6__setAttribute(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns6__setAttribute(struct soap *soap, struct ns6__setAttribute *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns6__setAttribute * SOAP_FMAC4 soap_instantiate_ns6__setAttribute(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__setAttribute(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__setAttribute, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns6__setAttribute;
		if (size)
			*size = sizeof(struct ns6__setAttribute);
	}
	else
	{	cp->ptr = (void*)new struct ns6__setAttribute[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns6__setAttribute);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns6__setAttribute*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__setAttribute(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns6__setAttribute %p -> %p\n", q, p));
	*(struct ns6__setAttribute*)p = *(struct ns6__setAttribute*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns6__setAttributeResponse(struct soap *soap, struct ns6__setAttributeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns6__setAttributeResponse(struct soap *soap, const struct ns6__setAttributeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__setAttributeResponse(struct soap *soap, const struct ns6__setAttributeResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns6__setAttributeResponse);
	if (soap_out_ns6__setAttributeResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__setAttributeResponse(struct soap *soap, const char *tag, int id, const struct ns6__setAttributeResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__setAttributeResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns6__setAttributeResponse * SOAP_FMAC4 soap_get_ns6__setAttributeResponse(struct soap *soap, struct ns6__setAttributeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__setAttributeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns6__setAttributeResponse * SOAP_FMAC4 soap_in_ns6__setAttributeResponse(struct soap *soap, const char *tag, struct ns6__setAttributeResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns6__setAttributeResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__setAttributeResponse, sizeof(struct ns6__setAttributeResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns6__setAttributeResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns6__setAttributeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__setAttributeResponse, 0, sizeof(struct ns6__setAttributeResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns6__setAttributeResponse * SOAP_FMAC6 soap_new_ns6__setAttributeResponse(struct soap *soap, int n)
{	return soap_instantiate_ns6__setAttributeResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns6__setAttributeResponse(struct soap *soap, struct ns6__setAttributeResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns6__setAttributeResponse * SOAP_FMAC4 soap_instantiate_ns6__setAttributeResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__setAttributeResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__setAttributeResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns6__setAttributeResponse;
		if (size)
			*size = sizeof(struct ns6__setAttributeResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns6__setAttributeResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns6__setAttributeResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns6__setAttributeResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__setAttributeResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns6__setAttributeResponse %p -> %p\n", q, p));
	*(struct ns6__setAttributeResponse*)p = *(struct ns6__setAttributeResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns6__getAttribute(struct soap *soap, struct ns6__getAttribute *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_objectId);
	soap_default_string(soap, &a->_key);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns6__getAttribute(struct soap *soap, const struct ns6__getAttribute *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_key);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__getAttribute(struct soap *soap, const struct ns6__getAttribute *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns6__getAttribute);
	if (soap_out_ns6__getAttribute(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__getAttribute(struct soap *soap, const char *tag, int id, const struct ns6__getAttribute *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__getAttribute), type))
		return soap->error;
	if (soap_out_int(soap, "objectId", -1, &a->_objectId, ""))
		return soap->error;
	if (soap_out_string(soap, "key", -1, &a->_key, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns6__getAttribute * SOAP_FMAC4 soap_get_ns6__getAttribute(struct soap *soap, struct ns6__getAttribute *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__getAttribute(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns6__getAttribute * SOAP_FMAC4 soap_in_ns6__getAttribute(struct soap *soap, const char *tag, struct ns6__getAttribute *a, const char *type)
{
	short soap_flag__objectId = 1, soap_flag__key = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns6__getAttribute *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__getAttribute, sizeof(struct ns6__getAttribute), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns6__getAttribute(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__objectId && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_objectId, "xsd:int"))
				{	soap_flag__objectId--;
					continue;
				}
			if (soap_flag__key && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_key, "xsd:string"))
				{	soap_flag__key--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns6__getAttribute *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__getAttribute, 0, sizeof(struct ns6__getAttribute), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__objectId > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns6__getAttribute * SOAP_FMAC6 soap_new_ns6__getAttribute(struct soap *soap, int n)
{	return soap_instantiate_ns6__getAttribute(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns6__getAttribute(struct soap *soap, struct ns6__getAttribute *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns6__getAttribute * SOAP_FMAC4 soap_instantiate_ns6__getAttribute(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__getAttribute(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__getAttribute, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns6__getAttribute;
		if (size)
			*size = sizeof(struct ns6__getAttribute);
	}
	else
	{	cp->ptr = (void*)new struct ns6__getAttribute[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns6__getAttribute);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns6__getAttribute*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__getAttribute(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns6__getAttribute %p -> %p\n", q, p));
	*(struct ns6__getAttribute*)p = *(struct ns6__getAttribute*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns6__getAttributeResponse(struct soap *soap, struct ns6__getAttributeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->_getAttributeReturn);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns6__getAttributeResponse(struct soap *soap, const struct ns6__getAttributeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->_getAttributeReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__getAttributeResponse(struct soap *soap, const struct ns6__getAttributeResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns6__getAttributeResponse);
	if (soap_out_ns6__getAttributeResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__getAttributeResponse(struct soap *soap, const char *tag, int id, const struct ns6__getAttributeResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__getAttributeResponse), type))
		return soap->error;
	if (soap_out_string(soap, "getAttributeReturn", -1, &a->_getAttributeReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns6__getAttributeResponse * SOAP_FMAC4 soap_get_ns6__getAttributeResponse(struct soap *soap, struct ns6__getAttributeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__getAttributeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns6__getAttributeResponse * SOAP_FMAC4 soap_in_ns6__getAttributeResponse(struct soap *soap, const char *tag, struct ns6__getAttributeResponse *a, const char *type)
{
	short soap_flag__getAttributeReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns6__getAttributeResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__getAttributeResponse, sizeof(struct ns6__getAttributeResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns6__getAttributeResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__getAttributeReturn && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, NULL, &a->_getAttributeReturn, "xsd:string"))
				{	soap_flag__getAttributeReturn--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns6__getAttributeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__getAttributeResponse, 0, sizeof(struct ns6__getAttributeResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__getAttributeReturn > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns6__getAttributeResponse * SOAP_FMAC6 soap_new_ns6__getAttributeResponse(struct soap *soap, int n)
{	return soap_instantiate_ns6__getAttributeResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns6__getAttributeResponse(struct soap *soap, struct ns6__getAttributeResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns6__getAttributeResponse * SOAP_FMAC4 soap_instantiate_ns6__getAttributeResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__getAttributeResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__getAttributeResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns6__getAttributeResponse;
		if (size)
			*size = sizeof(struct ns6__getAttributeResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns6__getAttributeResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns6__getAttributeResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns6__getAttributeResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__getAttributeResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns6__getAttributeResponse %p -> %p\n", q, p));
	*(struct ns6__getAttributeResponse*)p = *(struct ns6__getAttributeResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns6__update______(struct soap *soap, struct ns6__update______ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_note = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns6__update______(struct soap *soap, const struct ns6__update______ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__NoteData(soap, &a->_note);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__update______(struct soap *soap, const struct ns6__update______ *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns6__update______);
	if (soap_out_ns6__update______(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__update______(struct soap *soap, const char *tag, int id, const struct ns6__update______ *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__update______), type))
		return soap->error;
	if (soap_out_PointerTons4__NoteData(soap, "note", -1, &a->_note, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns6__update______ * SOAP_FMAC4 soap_get_ns6__update______(struct soap *soap, struct ns6__update______ *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__update______(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns6__update______ * SOAP_FMAC4 soap_in_ns6__update______(struct soap *soap, const char *tag, struct ns6__update______ *a, const char *type)
{
	short soap_flag__note = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns6__update______ *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__update______, sizeof(struct ns6__update______), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns6__update______(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__note && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__NoteData(soap, NULL, &a->_note, "ns4:NoteData"))
				{	soap_flag__note--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns6__update______ *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__update______, 0, sizeof(struct ns6__update______), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns6__update______ * SOAP_FMAC6 soap_new_ns6__update______(struct soap *soap, int n)
{	return soap_instantiate_ns6__update______(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns6__update______(struct soap *soap, struct ns6__update______ *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns6__update______ * SOAP_FMAC4 soap_instantiate_ns6__update______(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__update______(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__update______, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns6__update______;
		if (size)
			*size = sizeof(struct ns6__update______);
	}
	else
	{	cp->ptr = (void*)new struct ns6__update______[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns6__update______);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns6__update______*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__update______(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns6__update______ %p -> %p\n", q, p));
	*(struct ns6__update______*)p = *(struct ns6__update______*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns6__updateResponse______(struct soap *soap, struct ns6__updateResponse______ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns6__updateResponse______(struct soap *soap, const struct ns6__updateResponse______ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__updateResponse______(struct soap *soap, const struct ns6__updateResponse______ *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns6__updateResponse______);
	if (soap_out_ns6__updateResponse______(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__updateResponse______(struct soap *soap, const char *tag, int id, const struct ns6__updateResponse______ *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__updateResponse______), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns6__updateResponse______ * SOAP_FMAC4 soap_get_ns6__updateResponse______(struct soap *soap, struct ns6__updateResponse______ *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__updateResponse______(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns6__updateResponse______ * SOAP_FMAC4 soap_in_ns6__updateResponse______(struct soap *soap, const char *tag, struct ns6__updateResponse______ *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns6__updateResponse______ *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__updateResponse______, sizeof(struct ns6__updateResponse______), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns6__updateResponse______(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns6__updateResponse______ *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__updateResponse______, 0, sizeof(struct ns6__updateResponse______), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns6__updateResponse______ * SOAP_FMAC6 soap_new_ns6__updateResponse______(struct soap *soap, int n)
{	return soap_instantiate_ns6__updateResponse______(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns6__updateResponse______(struct soap *soap, struct ns6__updateResponse______ *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns6__updateResponse______ * SOAP_FMAC4 soap_instantiate_ns6__updateResponse______(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__updateResponse______(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__updateResponse______, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns6__updateResponse______;
		if (size)
			*size = sizeof(struct ns6__updateResponse______);
	}
	else
	{	cp->ptr = (void*)new struct ns6__updateResponse______[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns6__updateResponse______);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns6__updateResponse______*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__updateResponse______(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns6__updateResponse______ %p -> %p\n", q, p));
	*(struct ns6__updateResponse______*)p = *(struct ns6__updateResponse______*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns6__update_____(struct soap *soap, struct ns6__update_____ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_note = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns6__update_____(struct soap *soap, const struct ns6__update_____ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__NoteData(soap, &a->_note);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__update_____(struct soap *soap, const struct ns6__update_____ *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns6__update_____);
	if (soap_out_ns6__update_____(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__update_____(struct soap *soap, const char *tag, int id, const struct ns6__update_____ *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__update_____), type))
		return soap->error;
	if (soap_out_PointerTons4__NoteData(soap, "note", -1, &a->_note, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns6__update_____ * SOAP_FMAC4 soap_get_ns6__update_____(struct soap *soap, struct ns6__update_____ *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__update_____(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns6__update_____ * SOAP_FMAC4 soap_in_ns6__update_____(struct soap *soap, const char *tag, struct ns6__update_____ *a, const char *type)
{
	short soap_flag__note = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns6__update_____ *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__update_____, sizeof(struct ns6__update_____), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns6__update_____(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__note && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__NoteData(soap, NULL, &a->_note, "ns4:NoteData"))
				{	soap_flag__note--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns6__update_____ *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__update_____, 0, sizeof(struct ns6__update_____), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns6__update_____ * SOAP_FMAC6 soap_new_ns6__update_____(struct soap *soap, int n)
{	return soap_instantiate_ns6__update_____(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns6__update_____(struct soap *soap, struct ns6__update_____ *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns6__update_____ * SOAP_FMAC4 soap_instantiate_ns6__update_____(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__update_____(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__update_____, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns6__update_____;
		if (size)
			*size = sizeof(struct ns6__update_____);
	}
	else
	{	cp->ptr = (void*)new struct ns6__update_____[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns6__update_____);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns6__update_____*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__update_____(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns6__update_____ %p -> %p\n", q, p));
	*(struct ns6__update_____*)p = *(struct ns6__update_____*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns6__updateResponse_____(struct soap *soap, struct ns6__updateResponse_____ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns6__updateResponse_____(struct soap *soap, const struct ns6__updateResponse_____ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__updateResponse_____(struct soap *soap, const struct ns6__updateResponse_____ *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns6__updateResponse_____);
	if (soap_out_ns6__updateResponse_____(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__updateResponse_____(struct soap *soap, const char *tag, int id, const struct ns6__updateResponse_____ *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__updateResponse_____), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns6__updateResponse_____ * SOAP_FMAC4 soap_get_ns6__updateResponse_____(struct soap *soap, struct ns6__updateResponse_____ *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__updateResponse_____(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns6__updateResponse_____ * SOAP_FMAC4 soap_in_ns6__updateResponse_____(struct soap *soap, const char *tag, struct ns6__updateResponse_____ *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns6__updateResponse_____ *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__updateResponse_____, sizeof(struct ns6__updateResponse_____), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns6__updateResponse_____(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns6__updateResponse_____ *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__updateResponse_____, 0, sizeof(struct ns6__updateResponse_____), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns6__updateResponse_____ * SOAP_FMAC6 soap_new_ns6__updateResponse_____(struct soap *soap, int n)
{	return soap_instantiate_ns6__updateResponse_____(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns6__updateResponse_____(struct soap *soap, struct ns6__updateResponse_____ *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns6__updateResponse_____ * SOAP_FMAC4 soap_instantiate_ns6__updateResponse_____(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__updateResponse_____(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__updateResponse_____, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns6__updateResponse_____;
		if (size)
			*size = sizeof(struct ns6__updateResponse_____);
	}
	else
	{	cp->ptr = (void*)new struct ns6__updateResponse_____[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns6__updateResponse_____);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns6__updateResponse_____*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__updateResponse_____(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns6__updateResponse_____ %p -> %p\n", q, p));
	*(struct ns6__updateResponse_____*)p = *(struct ns6__updateResponse_____*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns6__update____(struct soap *soap, struct ns6__update____ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_note = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns6__update____(struct soap *soap, const struct ns6__update____ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__NoteData(soap, &a->_note);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__update____(struct soap *soap, const struct ns6__update____ *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns6__update____);
	if (soap_out_ns6__update____(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__update____(struct soap *soap, const char *tag, int id, const struct ns6__update____ *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__update____), type))
		return soap->error;
	if (soap_out_PointerTons4__NoteData(soap, "note", -1, &a->_note, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns6__update____ * SOAP_FMAC4 soap_get_ns6__update____(struct soap *soap, struct ns6__update____ *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__update____(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns6__update____ * SOAP_FMAC4 soap_in_ns6__update____(struct soap *soap, const char *tag, struct ns6__update____ *a, const char *type)
{
	short soap_flag__note = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns6__update____ *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__update____, sizeof(struct ns6__update____), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns6__update____(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__note && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__NoteData(soap, NULL, &a->_note, "ns4:NoteData"))
				{	soap_flag__note--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns6__update____ *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__update____, 0, sizeof(struct ns6__update____), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns6__update____ * SOAP_FMAC6 soap_new_ns6__update____(struct soap *soap, int n)
{	return soap_instantiate_ns6__update____(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns6__update____(struct soap *soap, struct ns6__update____ *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns6__update____ * SOAP_FMAC4 soap_instantiate_ns6__update____(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__update____(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__update____, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns6__update____;
		if (size)
			*size = sizeof(struct ns6__update____);
	}
	else
	{	cp->ptr = (void*)new struct ns6__update____[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns6__update____);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns6__update____*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__update____(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns6__update____ %p -> %p\n", q, p));
	*(struct ns6__update____*)p = *(struct ns6__update____*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns6__updateResponse____(struct soap *soap, struct ns6__updateResponse____ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns6__updateResponse____(struct soap *soap, const struct ns6__updateResponse____ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__updateResponse____(struct soap *soap, const struct ns6__updateResponse____ *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns6__updateResponse____);
	if (soap_out_ns6__updateResponse____(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__updateResponse____(struct soap *soap, const char *tag, int id, const struct ns6__updateResponse____ *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__updateResponse____), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns6__updateResponse____ * SOAP_FMAC4 soap_get_ns6__updateResponse____(struct soap *soap, struct ns6__updateResponse____ *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__updateResponse____(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns6__updateResponse____ * SOAP_FMAC4 soap_in_ns6__updateResponse____(struct soap *soap, const char *tag, struct ns6__updateResponse____ *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns6__updateResponse____ *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__updateResponse____, sizeof(struct ns6__updateResponse____), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns6__updateResponse____(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns6__updateResponse____ *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__updateResponse____, 0, sizeof(struct ns6__updateResponse____), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns6__updateResponse____ * SOAP_FMAC6 soap_new_ns6__updateResponse____(struct soap *soap, int n)
{	return soap_instantiate_ns6__updateResponse____(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns6__updateResponse____(struct soap *soap, struct ns6__updateResponse____ *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns6__updateResponse____ * SOAP_FMAC4 soap_instantiate_ns6__updateResponse____(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__updateResponse____(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__updateResponse____, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns6__updateResponse____;
		if (size)
			*size = sizeof(struct ns6__updateResponse____);
	}
	else
	{	cp->ptr = (void*)new struct ns6__updateResponse____[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns6__updateResponse____);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns6__updateResponse____*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__updateResponse____(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns6__updateResponse____ %p -> %p\n", q, p));
	*(struct ns6__updateResponse____*)p = *(struct ns6__updateResponse____*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns6__update___(struct soap *soap, struct ns6__update___ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_note = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns6__update___(struct soap *soap, const struct ns6__update___ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__NoteData(soap, &a->_note);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__update___(struct soap *soap, const struct ns6__update___ *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns6__update___);
	if (soap_out_ns6__update___(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__update___(struct soap *soap, const char *tag, int id, const struct ns6__update___ *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__update___), type))
		return soap->error;
	if (soap_out_PointerTons4__NoteData(soap, "note", -1, &a->_note, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns6__update___ * SOAP_FMAC4 soap_get_ns6__update___(struct soap *soap, struct ns6__update___ *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__update___(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns6__update___ * SOAP_FMAC4 soap_in_ns6__update___(struct soap *soap, const char *tag, struct ns6__update___ *a, const char *type)
{
	short soap_flag__note = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns6__update___ *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__update___, sizeof(struct ns6__update___), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns6__update___(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__note && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__NoteData(soap, NULL, &a->_note, "ns4:NoteData"))
				{	soap_flag__note--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns6__update___ *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__update___, 0, sizeof(struct ns6__update___), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns6__update___ * SOAP_FMAC6 soap_new_ns6__update___(struct soap *soap, int n)
{	return soap_instantiate_ns6__update___(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns6__update___(struct soap *soap, struct ns6__update___ *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns6__update___ * SOAP_FMAC4 soap_instantiate_ns6__update___(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__update___(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__update___, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns6__update___;
		if (size)
			*size = sizeof(struct ns6__update___);
	}
	else
	{	cp->ptr = (void*)new struct ns6__update___[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns6__update___);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns6__update___*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__update___(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns6__update___ %p -> %p\n", q, p));
	*(struct ns6__update___*)p = *(struct ns6__update___*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns6__updateResponse___(struct soap *soap, struct ns6__updateResponse___ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns6__updateResponse___(struct soap *soap, const struct ns6__updateResponse___ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__updateResponse___(struct soap *soap, const struct ns6__updateResponse___ *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns6__updateResponse___);
	if (soap_out_ns6__updateResponse___(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__updateResponse___(struct soap *soap, const char *tag, int id, const struct ns6__updateResponse___ *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__updateResponse___), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns6__updateResponse___ * SOAP_FMAC4 soap_get_ns6__updateResponse___(struct soap *soap, struct ns6__updateResponse___ *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__updateResponse___(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns6__updateResponse___ * SOAP_FMAC4 soap_in_ns6__updateResponse___(struct soap *soap, const char *tag, struct ns6__updateResponse___ *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns6__updateResponse___ *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__updateResponse___, sizeof(struct ns6__updateResponse___), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns6__updateResponse___(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns6__updateResponse___ *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__updateResponse___, 0, sizeof(struct ns6__updateResponse___), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns6__updateResponse___ * SOAP_FMAC6 soap_new_ns6__updateResponse___(struct soap *soap, int n)
{	return soap_instantiate_ns6__updateResponse___(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns6__updateResponse___(struct soap *soap, struct ns6__updateResponse___ *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns6__updateResponse___ * SOAP_FMAC4 soap_instantiate_ns6__updateResponse___(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__updateResponse___(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__updateResponse___, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns6__updateResponse___;
		if (size)
			*size = sizeof(struct ns6__updateResponse___);
	}
	else
	{	cp->ptr = (void*)new struct ns6__updateResponse___[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns6__updateResponse___);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns6__updateResponse___*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__updateResponse___(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns6__updateResponse___ %p -> %p\n", q, p));
	*(struct ns6__updateResponse___*)p = *(struct ns6__updateResponse___*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns6__update__(struct soap *soap, struct ns6__update__ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_note = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns6__update__(struct soap *soap, const struct ns6__update__ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__NoteData(soap, &a->_note);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__update__(struct soap *soap, const struct ns6__update__ *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns6__update__);
	if (soap_out_ns6__update__(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__update__(struct soap *soap, const char *tag, int id, const struct ns6__update__ *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__update__), type))
		return soap->error;
	if (soap_out_PointerTons4__NoteData(soap, "note", -1, &a->_note, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns6__update__ * SOAP_FMAC4 soap_get_ns6__update__(struct soap *soap, struct ns6__update__ *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__update__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns6__update__ * SOAP_FMAC4 soap_in_ns6__update__(struct soap *soap, const char *tag, struct ns6__update__ *a, const char *type)
{
	short soap_flag__note = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns6__update__ *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__update__, sizeof(struct ns6__update__), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns6__update__(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__note && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__NoteData(soap, NULL, &a->_note, "ns4:NoteData"))
				{	soap_flag__note--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns6__update__ *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__update__, 0, sizeof(struct ns6__update__), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns6__update__ * SOAP_FMAC6 soap_new_ns6__update__(struct soap *soap, int n)
{	return soap_instantiate_ns6__update__(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns6__update__(struct soap *soap, struct ns6__update__ *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns6__update__ * SOAP_FMAC4 soap_instantiate_ns6__update__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__update__(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__update__, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns6__update__;
		if (size)
			*size = sizeof(struct ns6__update__);
	}
	else
	{	cp->ptr = (void*)new struct ns6__update__[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns6__update__);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns6__update__*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__update__(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns6__update__ %p -> %p\n", q, p));
	*(struct ns6__update__*)p = *(struct ns6__update__*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns6__updateResponse__(struct soap *soap, struct ns6__updateResponse__ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns6__updateResponse__(struct soap *soap, const struct ns6__updateResponse__ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__updateResponse__(struct soap *soap, const struct ns6__updateResponse__ *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns6__updateResponse__);
	if (soap_out_ns6__updateResponse__(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__updateResponse__(struct soap *soap, const char *tag, int id, const struct ns6__updateResponse__ *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__updateResponse__), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns6__updateResponse__ * SOAP_FMAC4 soap_get_ns6__updateResponse__(struct soap *soap, struct ns6__updateResponse__ *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__updateResponse__(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns6__updateResponse__ * SOAP_FMAC4 soap_in_ns6__updateResponse__(struct soap *soap, const char *tag, struct ns6__updateResponse__ *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns6__updateResponse__ *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__updateResponse__, sizeof(struct ns6__updateResponse__), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns6__updateResponse__(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns6__updateResponse__ *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__updateResponse__, 0, sizeof(struct ns6__updateResponse__), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns6__updateResponse__ * SOAP_FMAC6 soap_new_ns6__updateResponse__(struct soap *soap, int n)
{	return soap_instantiate_ns6__updateResponse__(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns6__updateResponse__(struct soap *soap, struct ns6__updateResponse__ *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns6__updateResponse__ * SOAP_FMAC4 soap_instantiate_ns6__updateResponse__(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__updateResponse__(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__updateResponse__, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns6__updateResponse__;
		if (size)
			*size = sizeof(struct ns6__updateResponse__);
	}
	else
	{	cp->ptr = (void*)new struct ns6__updateResponse__[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns6__updateResponse__);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns6__updateResponse__*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__updateResponse__(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns6__updateResponse__ %p -> %p\n", q, p));
	*(struct ns6__updateResponse__*)p = *(struct ns6__updateResponse__*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns6__update_(struct soap *soap, struct ns6__update_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_note = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns6__update_(struct soap *soap, const struct ns6__update_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__NoteData(soap, &a->_note);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__update_(struct soap *soap, const struct ns6__update_ *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns6__update_);
	if (soap_out_ns6__update_(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__update_(struct soap *soap, const char *tag, int id, const struct ns6__update_ *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__update_), type))
		return soap->error;
	if (soap_out_PointerTons4__NoteData(soap, "note", -1, &a->_note, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns6__update_ * SOAP_FMAC4 soap_get_ns6__update_(struct soap *soap, struct ns6__update_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__update_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns6__update_ * SOAP_FMAC4 soap_in_ns6__update_(struct soap *soap, const char *tag, struct ns6__update_ *a, const char *type)
{
	short soap_flag__note = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns6__update_ *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__update_, sizeof(struct ns6__update_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns6__update_(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__note && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__NoteData(soap, NULL, &a->_note, "ns4:NoteData"))
				{	soap_flag__note--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns6__update_ *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__update_, 0, sizeof(struct ns6__update_), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns6__update_ * SOAP_FMAC6 soap_new_ns6__update_(struct soap *soap, int n)
{	return soap_instantiate_ns6__update_(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns6__update_(struct soap *soap, struct ns6__update_ *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns6__update_ * SOAP_FMAC4 soap_instantiate_ns6__update_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__update_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__update_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns6__update_;
		if (size)
			*size = sizeof(struct ns6__update_);
	}
	else
	{	cp->ptr = (void*)new struct ns6__update_[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns6__update_);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns6__update_*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__update_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns6__update_ %p -> %p\n", q, p));
	*(struct ns6__update_*)p = *(struct ns6__update_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns6__updateResponse_(struct soap *soap, struct ns6__updateResponse_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns6__updateResponse_(struct soap *soap, const struct ns6__updateResponse_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__updateResponse_(struct soap *soap, const struct ns6__updateResponse_ *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns6__updateResponse_);
	if (soap_out_ns6__updateResponse_(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__updateResponse_(struct soap *soap, const char *tag, int id, const struct ns6__updateResponse_ *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__updateResponse_), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns6__updateResponse_ * SOAP_FMAC4 soap_get_ns6__updateResponse_(struct soap *soap, struct ns6__updateResponse_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__updateResponse_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns6__updateResponse_ * SOAP_FMAC4 soap_in_ns6__updateResponse_(struct soap *soap, const char *tag, struct ns6__updateResponse_ *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns6__updateResponse_ *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__updateResponse_, sizeof(struct ns6__updateResponse_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns6__updateResponse_(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns6__updateResponse_ *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__updateResponse_, 0, sizeof(struct ns6__updateResponse_), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns6__updateResponse_ * SOAP_FMAC6 soap_new_ns6__updateResponse_(struct soap *soap, int n)
{	return soap_instantiate_ns6__updateResponse_(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns6__updateResponse_(struct soap *soap, struct ns6__updateResponse_ *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns6__updateResponse_ * SOAP_FMAC4 soap_instantiate_ns6__updateResponse_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__updateResponse_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__updateResponse_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns6__updateResponse_;
		if (size)
			*size = sizeof(struct ns6__updateResponse_);
	}
	else
	{	cp->ptr = (void*)new struct ns6__updateResponse_[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns6__updateResponse_);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns6__updateResponse_*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__updateResponse_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns6__updateResponse_ %p -> %p\n", q, p));
	*(struct ns6__updateResponse_*)p = *(struct ns6__updateResponse_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns6__update(struct soap *soap, struct ns6__update *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_note = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns6__update(struct soap *soap, const struct ns6__update *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons4__NoteData(soap, &a->_note);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__update(struct soap *soap, const struct ns6__update *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns6__update);
	if (soap_out_ns6__update(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__update(struct soap *soap, const char *tag, int id, const struct ns6__update *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__update), type))
		return soap->error;
	if (soap_out_PointerTons4__NoteData(soap, "note", -1, &a->_note, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns6__update * SOAP_FMAC4 soap_get_ns6__update(struct soap *soap, struct ns6__update *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__update(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns6__update * SOAP_FMAC4 soap_in_ns6__update(struct soap *soap, const char *tag, struct ns6__update *a, const char *type)
{
	short soap_flag__note = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns6__update *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__update, sizeof(struct ns6__update), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns6__update(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__note && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons4__NoteData(soap, NULL, &a->_note, "ns4:NoteData"))
				{	soap_flag__note--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns6__update *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__update, 0, sizeof(struct ns6__update), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns6__update * SOAP_FMAC6 soap_new_ns6__update(struct soap *soap, int n)
{	return soap_instantiate_ns6__update(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns6__update(struct soap *soap, struct ns6__update *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns6__update * SOAP_FMAC4 soap_instantiate_ns6__update(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__update(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__update, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns6__update;
		if (size)
			*size = sizeof(struct ns6__update);
	}
	else
	{	cp->ptr = (void*)new struct ns6__update[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns6__update);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns6__update*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__update(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns6__update %p -> %p\n", q, p));
	*(struct ns6__update*)p = *(struct ns6__update*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns6__updateResponse(struct soap *soap, struct ns6__updateResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns6__updateResponse(struct soap *soap, const struct ns6__updateResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__updateResponse(struct soap *soap, const struct ns6__updateResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns6__updateResponse);
	if (soap_out_ns6__updateResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__updateResponse(struct soap *soap, const char *tag, int id, const struct ns6__updateResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__updateResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns6__updateResponse * SOAP_FMAC4 soap_get_ns6__updateResponse(struct soap *soap, struct ns6__updateResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__updateResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns6__updateResponse * SOAP_FMAC4 soap_in_ns6__updateResponse(struct soap *soap, const char *tag, struct ns6__updateResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns6__updateResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__updateResponse, sizeof(struct ns6__updateResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns6__updateResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns6__updateResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__updateResponse, 0, sizeof(struct ns6__updateResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns6__updateResponse * SOAP_FMAC6 soap_new_ns6__updateResponse(struct soap *soap, int n)
{	return soap_instantiate_ns6__updateResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns6__updateResponse(struct soap *soap, struct ns6__updateResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns6__updateResponse * SOAP_FMAC4 soap_instantiate_ns6__updateResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__updateResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__updateResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns6__updateResponse;
		if (size)
			*size = sizeof(struct ns6__updateResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns6__updateResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns6__updateResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns6__updateResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__updateResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns6__updateResponse %p -> %p\n", q, p));
	*(struct ns6__updateResponse*)p = *(struct ns6__updateResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns6__getAttributes(struct soap *soap, struct ns6__getAttributes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->_objectId);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns6__getAttributes(struct soap *soap, const struct ns6__getAttributes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__getAttributes(struct soap *soap, const struct ns6__getAttributes *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns6__getAttributes);
	if (soap_out_ns6__getAttributes(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__getAttributes(struct soap *soap, const char *tag, int id, const struct ns6__getAttributes *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__getAttributes), type))
		return soap->error;
	if (soap_out_int(soap, "objectId", -1, &a->_objectId, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns6__getAttributes * SOAP_FMAC4 soap_get_ns6__getAttributes(struct soap *soap, struct ns6__getAttributes *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__getAttributes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns6__getAttributes * SOAP_FMAC4 soap_in_ns6__getAttributes(struct soap *soap, const char *tag, struct ns6__getAttributes *a, const char *type)
{
	short soap_flag__objectId = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns6__getAttributes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__getAttributes, sizeof(struct ns6__getAttributes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns6__getAttributes(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__objectId && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, NULL, &a->_objectId, "xsd:int"))
				{	soap_flag__objectId--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns6__getAttributes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__getAttributes, 0, sizeof(struct ns6__getAttributes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag__objectId > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns6__getAttributes * SOAP_FMAC6 soap_new_ns6__getAttributes(struct soap *soap, int n)
{	return soap_instantiate_ns6__getAttributes(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns6__getAttributes(struct soap *soap, struct ns6__getAttributes *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns6__getAttributes * SOAP_FMAC4 soap_instantiate_ns6__getAttributes(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__getAttributes(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__getAttributes, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns6__getAttributes;
		if (size)
			*size = sizeof(struct ns6__getAttributes);
	}
	else
	{	cp->ptr = (void*)new struct ns6__getAttributes[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns6__getAttributes);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns6__getAttributes*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__getAttributes(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns6__getAttributes %p -> %p\n", q, p));
	*(struct ns6__getAttributes*)p = *(struct ns6__getAttributes*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns6__getAttributesResponse(struct soap *soap, struct ns6__getAttributesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_getAttributesReturn = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns6__getAttributesResponse(struct soap *soap, const struct ns6__getAttributesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__Map(soap, &a->_getAttributesReturn);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns6__getAttributesResponse(struct soap *soap, const struct ns6__getAttributesResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns6__getAttributesResponse);
	if (soap_out_ns6__getAttributesResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns6__getAttributesResponse(struct soap *soap, const char *tag, int id, const struct ns6__getAttributesResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns6__getAttributesResponse), type))
		return soap->error;
	if (soap_out_PointerTons2__Map(soap, "getAttributesReturn", -1, &a->_getAttributesReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns6__getAttributesResponse * SOAP_FMAC4 soap_get_ns6__getAttributesResponse(struct soap *soap, struct ns6__getAttributesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns6__getAttributesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns6__getAttributesResponse * SOAP_FMAC4 soap_in_ns6__getAttributesResponse(struct soap *soap, const char *tag, struct ns6__getAttributesResponse *a, const char *type)
{
	short soap_flag__getAttributesReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns6__getAttributesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns6__getAttributesResponse, sizeof(struct ns6__getAttributesResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns6__getAttributesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__getAttributesReturn && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__Map(soap, NULL, &a->_getAttributesReturn, "ns2:Map"))
				{	soap_flag__getAttributesReturn--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns6__getAttributesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns6__getAttributesResponse, 0, sizeof(struct ns6__getAttributesResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns6__getAttributesResponse * SOAP_FMAC6 soap_new_ns6__getAttributesResponse(struct soap *soap, int n)
{	return soap_instantiate_ns6__getAttributesResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns6__getAttributesResponse(struct soap *soap, struct ns6__getAttributesResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns6__getAttributesResponse * SOAP_FMAC4 soap_instantiate_ns6__getAttributesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns6__getAttributesResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns6__getAttributesResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns6__getAttributesResponse;
		if (size)
			*size = sizeof(struct ns6__getAttributesResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns6__getAttributesResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns6__getAttributesResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns6__getAttributesResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns6__getAttributesResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns6__getAttributesResponse %p -> %p\n", q, p));
	*(struct ns6__getAttributesResponse*)p = *(struct ns6__getAttributesResponse*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__QueryException = NULL;
	a->__type = 0;
	a->fault = NULL;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_ns1__QueryException(soap, &a->ns1__QueryException);
	soap_markelement(soap, a->fault, a->__type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Detail);
	if (soap_out_SOAP_ENV__Detail(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
		return soap->error;
	if (soap_out_PointerTo_ns1__QueryException(soap, "ns1:QueryException", -1, &a->ns1__QueryException, ""))
		return soap->error;
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	short soap_flag_ns1__QueryException = 1, soap_flag_fault = 1, soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__QueryException && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__QueryException(soap, "ns1:QueryException", &a->ns1__QueryException, ""))
				{	soap_flag_ns1__QueryException--;
					continue;
				}
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
				if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, 0, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_fault > 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct SOAP_ENV__Detail * SOAP_FMAC6 soap_new_SOAP_ENV__Detail(struct soap *soap, int n)
{	return soap_instantiate_SOAP_ENV__Detail(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Detail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Detail(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Detail, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Detail;
		if (size)
			*size = sizeof(struct SOAP_ENV__Detail);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Detail[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Detail);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Detail*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Detail(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Detail %p -> %p\n", q, p));
	*(struct SOAP_ENV__Detail*)p = *(struct SOAP_ENV__Detail*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Reason);
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Detail);
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Code);
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToArrayOf_USCOREtns1_USCORENoteData(struct soap *soap, ArrayOf_USCOREtns1_USCORENoteData *const*a)
{
	if (*a)
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToArrayOf_USCOREtns1_USCORENoteData(struct soap *soap, ArrayOf_USCOREtns1_USCORENoteData *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToArrayOf_USCOREtns1_USCORENoteData);
	if (soap_out_PointerToArrayOf_USCOREtns1_USCORENoteData(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToArrayOf_USCOREtns1_USCORENoteData(struct soap *soap, const char *tag, int id, ArrayOf_USCOREtns1_USCORENoteData *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_ArrayOf_USCOREtns1_USCORENoteData);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ArrayOf_USCOREtns1_USCORENoteData ** SOAP_FMAC4 soap_get_PointerToArrayOf_USCOREtns1_USCORENoteData(struct soap *soap, ArrayOf_USCOREtns1_USCORENoteData **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToArrayOf_USCOREtns1_USCORENoteData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ArrayOf_USCOREtns1_USCORENoteData ** SOAP_FMAC4 soap_in_PointerToArrayOf_USCOREtns1_USCORENoteData(struct soap *soap, const char *tag, ArrayOf_USCOREtns1_USCORENoteData **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ArrayOf_USCOREtns1_USCORENoteData **)soap_malloc(soap, sizeof(ArrayOf_USCOREtns1_USCORENoteData *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ArrayOf_USCOREtns1_USCORENoteData *)soap_instantiate_ArrayOf_USCOREtns1_USCORENoteData(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ArrayOf_USCOREtns1_USCORENoteData ** p = (ArrayOf_USCOREtns1_USCORENoteData **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ArrayOf_USCOREtns1_USCORENoteData, sizeof(ArrayOf_USCOREtns1_USCORENoteData), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToArrayOf_USCOREtns1_USCOREProjectData(struct soap *soap, ArrayOf_USCOREtns1_USCOREProjectData *const*a)
{
	if (*a)
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToArrayOf_USCOREtns1_USCOREProjectData(struct soap *soap, ArrayOf_USCOREtns1_USCOREProjectData *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToArrayOf_USCOREtns1_USCOREProjectData);
	if (soap_out_PointerToArrayOf_USCOREtns1_USCOREProjectData(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToArrayOf_USCOREtns1_USCOREProjectData(struct soap *soap, const char *tag, int id, ArrayOf_USCOREtns1_USCOREProjectData *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_ArrayOf_USCOREtns1_USCOREProjectData);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ArrayOf_USCOREtns1_USCOREProjectData ** SOAP_FMAC4 soap_get_PointerToArrayOf_USCOREtns1_USCOREProjectData(struct soap *soap, ArrayOf_USCOREtns1_USCOREProjectData **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToArrayOf_USCOREtns1_USCOREProjectData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ArrayOf_USCOREtns1_USCOREProjectData ** SOAP_FMAC4 soap_in_PointerToArrayOf_USCOREtns1_USCOREProjectData(struct soap *soap, const char *tag, ArrayOf_USCOREtns1_USCOREProjectData **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ArrayOf_USCOREtns1_USCOREProjectData **)soap_malloc(soap, sizeof(ArrayOf_USCOREtns1_USCOREProjectData *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ArrayOf_USCOREtns1_USCOREProjectData *)soap_instantiate_ArrayOf_USCOREtns1_USCOREProjectData(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ArrayOf_USCOREtns1_USCOREProjectData ** p = (ArrayOf_USCOREtns1_USCOREProjectData **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ArrayOf_USCOREtns1_USCOREProjectData, sizeof(ArrayOf_USCOREtns1_USCOREProjectData), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToArrayOf_USCOREtns1_USCOREPersonData(struct soap *soap, ArrayOf_USCOREtns1_USCOREPersonData *const*a)
{
	if (*a)
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToArrayOf_USCOREtns1_USCOREPersonData(struct soap *soap, ArrayOf_USCOREtns1_USCOREPersonData *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToArrayOf_USCOREtns1_USCOREPersonData);
	if (soap_out_PointerToArrayOf_USCOREtns1_USCOREPersonData(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToArrayOf_USCOREtns1_USCOREPersonData(struct soap *soap, const char *tag, int id, ArrayOf_USCOREtns1_USCOREPersonData *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_ArrayOf_USCOREtns1_USCOREPersonData);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ArrayOf_USCOREtns1_USCOREPersonData ** SOAP_FMAC4 soap_get_PointerToArrayOf_USCOREtns1_USCOREPersonData(struct soap *soap, ArrayOf_USCOREtns1_USCOREPersonData **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToArrayOf_USCOREtns1_USCOREPersonData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ArrayOf_USCOREtns1_USCOREPersonData ** SOAP_FMAC4 soap_in_PointerToArrayOf_USCOREtns1_USCOREPersonData(struct soap *soap, const char *tag, ArrayOf_USCOREtns1_USCOREPersonData **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ArrayOf_USCOREtns1_USCOREPersonData **)soap_malloc(soap, sizeof(ArrayOf_USCOREtns1_USCOREPersonData *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ArrayOf_USCOREtns1_USCOREPersonData *)soap_instantiate_ArrayOf_USCOREtns1_USCOREPersonData(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ArrayOf_USCOREtns1_USCOREPersonData ** p = (ArrayOf_USCOREtns1_USCOREPersonData **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ArrayOf_USCOREtns1_USCOREPersonData, sizeof(ArrayOf_USCOREtns1_USCOREPersonData), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToArrayOf_USCOREtns1_USCORETimeEntryData(struct soap *soap, ArrayOf_USCOREtns1_USCORETimeEntryData *const*a)
{
	if (*a)
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToArrayOf_USCOREtns1_USCORETimeEntryData(struct soap *soap, ArrayOf_USCOREtns1_USCORETimeEntryData *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToArrayOf_USCOREtns1_USCORETimeEntryData);
	if (soap_out_PointerToArrayOf_USCOREtns1_USCORETimeEntryData(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToArrayOf_USCOREtns1_USCORETimeEntryData(struct soap *soap, const char *tag, int id, ArrayOf_USCOREtns1_USCORETimeEntryData *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_ArrayOf_USCOREtns1_USCORETimeEntryData);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ArrayOf_USCOREtns1_USCORETimeEntryData ** SOAP_FMAC4 soap_get_PointerToArrayOf_USCOREtns1_USCORETimeEntryData(struct soap *soap, ArrayOf_USCOREtns1_USCORETimeEntryData **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToArrayOf_USCOREtns1_USCORETimeEntryData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ArrayOf_USCOREtns1_USCORETimeEntryData ** SOAP_FMAC4 soap_in_PointerToArrayOf_USCOREtns1_USCORETimeEntryData(struct soap *soap, const char *tag, ArrayOf_USCOREtns1_USCORETimeEntryData **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ArrayOf_USCOREtns1_USCORETimeEntryData **)soap_malloc(soap, sizeof(ArrayOf_USCOREtns1_USCORETimeEntryData *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ArrayOf_USCOREtns1_USCORETimeEntryData *)soap_instantiate_ArrayOf_USCOREtns1_USCORETimeEntryData(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ArrayOf_USCOREtns1_USCORETimeEntryData ** p = (ArrayOf_USCOREtns1_USCORETimeEntryData **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ArrayOf_USCOREtns1_USCORETimeEntryData, sizeof(ArrayOf_USCOREtns1_USCORETimeEntryData), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToArrayOf_USCOREtns1_USCORETaskData(struct soap *soap, ArrayOf_USCOREtns1_USCORETaskData *const*a)
{
	if (*a)
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToArrayOf_USCOREtns1_USCORETaskData(struct soap *soap, ArrayOf_USCOREtns1_USCORETaskData *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToArrayOf_USCOREtns1_USCORETaskData);
	if (soap_out_PointerToArrayOf_USCOREtns1_USCORETaskData(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToArrayOf_USCOREtns1_USCORETaskData(struct soap *soap, const char *tag, int id, ArrayOf_USCOREtns1_USCORETaskData *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_ArrayOf_USCOREtns1_USCORETaskData);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ArrayOf_USCOREtns1_USCORETaskData ** SOAP_FMAC4 soap_get_PointerToArrayOf_USCOREtns1_USCORETaskData(struct soap *soap, ArrayOf_USCOREtns1_USCORETaskData **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToArrayOf_USCOREtns1_USCORETaskData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ArrayOf_USCOREtns1_USCORETaskData ** SOAP_FMAC4 soap_in_PointerToArrayOf_USCOREtns1_USCORETaskData(struct soap *soap, const char *tag, ArrayOf_USCOREtns1_USCORETaskData **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ArrayOf_USCOREtns1_USCORETaskData **)soap_malloc(soap, sizeof(ArrayOf_USCOREtns1_USCORETaskData *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ArrayOf_USCOREtns1_USCORETaskData *)soap_instantiate_ArrayOf_USCOREtns1_USCORETaskData(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ArrayOf_USCOREtns1_USCORETaskData ** p = (ArrayOf_USCOREtns1_USCORETaskData **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ArrayOf_USCOREtns1_USCORETaskData, sizeof(ArrayOf_USCOREtns1_USCORETaskData), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToArrayOf_USCOREtns1_USCOREUserStoryData(struct soap *soap, ArrayOf_USCOREtns1_USCOREUserStoryData *const*a)
{
	if (*a)
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToArrayOf_USCOREtns1_USCOREUserStoryData(struct soap *soap, ArrayOf_USCOREtns1_USCOREUserStoryData *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToArrayOf_USCOREtns1_USCOREUserStoryData);
	if (soap_out_PointerToArrayOf_USCOREtns1_USCOREUserStoryData(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToArrayOf_USCOREtns1_USCOREUserStoryData(struct soap *soap, const char *tag, int id, ArrayOf_USCOREtns1_USCOREUserStoryData *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_ArrayOf_USCOREtns1_USCOREUserStoryData);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ArrayOf_USCOREtns1_USCOREUserStoryData ** SOAP_FMAC4 soap_get_PointerToArrayOf_USCOREtns1_USCOREUserStoryData(struct soap *soap, ArrayOf_USCOREtns1_USCOREUserStoryData **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToArrayOf_USCOREtns1_USCOREUserStoryData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ArrayOf_USCOREtns1_USCOREUserStoryData ** SOAP_FMAC4 soap_in_PointerToArrayOf_USCOREtns1_USCOREUserStoryData(struct soap *soap, const char *tag, ArrayOf_USCOREtns1_USCOREUserStoryData **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ArrayOf_USCOREtns1_USCOREUserStoryData **)soap_malloc(soap, sizeof(ArrayOf_USCOREtns1_USCOREUserStoryData *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ArrayOf_USCOREtns1_USCOREUserStoryData *)soap_instantiate_ArrayOf_USCOREtns1_USCOREUserStoryData(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ArrayOf_USCOREtns1_USCOREUserStoryData ** p = (ArrayOf_USCOREtns1_USCOREUserStoryData **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ArrayOf_USCOREtns1_USCOREUserStoryData, sizeof(ArrayOf_USCOREtns1_USCOREUserStoryData), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToArrayOf_USCOREtns1_USCOREIterationData(struct soap *soap, ArrayOf_USCOREtns1_USCOREIterationData *const*a)
{
	if (*a)
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToArrayOf_USCOREtns1_USCOREIterationData(struct soap *soap, ArrayOf_USCOREtns1_USCOREIterationData *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToArrayOf_USCOREtns1_USCOREIterationData);
	if (soap_out_PointerToArrayOf_USCOREtns1_USCOREIterationData(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToArrayOf_USCOREtns1_USCOREIterationData(struct soap *soap, const char *tag, int id, ArrayOf_USCOREtns1_USCOREIterationData *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_ArrayOf_USCOREtns1_USCOREIterationData);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ArrayOf_USCOREtns1_USCOREIterationData ** SOAP_FMAC4 soap_get_PointerToArrayOf_USCOREtns1_USCOREIterationData(struct soap *soap, ArrayOf_USCOREtns1_USCOREIterationData **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToArrayOf_USCOREtns1_USCOREIterationData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ArrayOf_USCOREtns1_USCOREIterationData ** SOAP_FMAC4 soap_in_PointerToArrayOf_USCOREtns1_USCOREIterationData(struct soap *soap, const char *tag, ArrayOf_USCOREtns1_USCOREIterationData **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ArrayOf_USCOREtns1_USCOREIterationData **)soap_malloc(soap, sizeof(ArrayOf_USCOREtns1_USCOREIterationData *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ArrayOf_USCOREtns1_USCOREIterationData *)soap_instantiate_ArrayOf_USCOREtns1_USCOREIterationData(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ArrayOf_USCOREtns1_USCOREIterationData ** p = (ArrayOf_USCOREtns1_USCOREIterationData **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ArrayOf_USCOREtns1_USCOREIterationData, sizeof(ArrayOf_USCOREtns1_USCOREIterationData), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__Map(struct soap *soap, ns2__Map *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__Map))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__Map(struct soap *soap, ns2__Map *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__Map);
	if (soap_out_PointerTons2__Map(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__Map(struct soap *soap, const char *tag, int id, ns2__Map *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__Map);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__Map ** SOAP_FMAC4 soap_get_PointerTons2__Map(struct soap *soap, ns2__Map **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__Map(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns2__Map ** SOAP_FMAC4 soap_in_PointerTons2__Map(struct soap *soap, const char *tag, ns2__Map **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__Map **)soap_malloc(soap, sizeof(ns2__Map *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__Map *)soap_instantiate_ns2__Map(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__Map ** p = (ns2__Map **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__Map, sizeof(ns2__Map), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__QueryException(struct soap *soap, _ns1__QueryException *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__QueryException))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__QueryException(struct soap *soap, _ns1__QueryException *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__QueryException);
	if (soap_out_PointerTo_ns1__QueryException(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__QueryException(struct soap *soap, const char *tag, int id, _ns1__QueryException *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__QueryException);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _ns1__QueryException ** SOAP_FMAC4 soap_get_PointerTo_ns1__QueryException(struct soap *soap, _ns1__QueryException **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__QueryException(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _ns1__QueryException ** SOAP_FMAC4 soap_in_PointerTo_ns1__QueryException(struct soap *soap, const char *tag, _ns1__QueryException **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__QueryException **)soap_malloc(soap, sizeof(_ns1__QueryException *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__QueryException *)soap_instantiate__ns1__QueryException(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_ns1__QueryException ** p = (_ns1__QueryException **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__QueryException, sizeof(_ns1__QueryException), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons5__QueryException(struct soap *soap, ns5__QueryException *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns5__QueryException))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons5__QueryException(struct soap *soap, ns5__QueryException *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons5__QueryException);
	if (soap_out_PointerTons5__QueryException(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons5__QueryException(struct soap *soap, const char *tag, int id, ns5__QueryException *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns5__QueryException);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns5__QueryException ** SOAP_FMAC4 soap_get_PointerTons5__QueryException(struct soap *soap, ns5__QueryException **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons5__QueryException(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns5__QueryException ** SOAP_FMAC4 soap_in_PointerTons5__QueryException(struct soap *soap, const char *tag, ns5__QueryException **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns5__QueryException **)soap_malloc(soap, sizeof(ns5__QueryException *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns5__QueryException *)soap_instantiate_ns5__QueryException(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns5__QueryException ** p = (ns5__QueryException **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__QueryException, sizeof(ns5__QueryException), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons4__NoteData(struct soap *soap, ns4__NoteData **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons4__NoteData))
		soap_serialize_PointerTons4__NoteData(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons4__NoteData(struct soap *soap, ns4__NoteData **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons4__NoteData);
	if (soap_out_PointerToPointerTons4__NoteData(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons4__NoteData(struct soap *soap, const char *tag, int id, ns4__NoteData **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons4__NoteData);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons4__NoteData(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns4__NoteData *** SOAP_FMAC4 soap_get_PointerToPointerTons4__NoteData(struct soap *soap, ns4__NoteData ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons4__NoteData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns4__NoteData *** SOAP_FMAC4 soap_in_PointerToPointerTons4__NoteData(struct soap *soap, const char *tag, ns4__NoteData ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns4__NoteData ***)soap_malloc(soap, sizeof(ns4__NoteData **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons4__NoteData(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns4__NoteData ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons4__NoteData, sizeof(ns4__NoteData *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__NoteData(struct soap *soap, ns4__NoteData *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__NoteData))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__NoteData(struct soap *soap, ns4__NoteData *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__NoteData);
	if (soap_out_PointerTons4__NoteData(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__NoteData(struct soap *soap, const char *tag, int id, ns4__NoteData *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__NoteData);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns4__NoteData ** SOAP_FMAC4 soap_get_PointerTons4__NoteData(struct soap *soap, ns4__NoteData **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__NoteData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns4__NoteData ** SOAP_FMAC4 soap_in_PointerTons4__NoteData(struct soap *soap, const char *tag, ns4__NoteData **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns4__NoteData **)soap_malloc(soap, sizeof(ns4__NoteData *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns4__NoteData *)soap_instantiate_ns4__NoteData(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns4__NoteData ** p = (ns4__NoteData **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__NoteData, sizeof(ns4__NoteData), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons4__ProjectData(struct soap *soap, ns4__ProjectData **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons4__ProjectData))
		soap_serialize_PointerTons4__ProjectData(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons4__ProjectData(struct soap *soap, ns4__ProjectData **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons4__ProjectData);
	if (soap_out_PointerToPointerTons4__ProjectData(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons4__ProjectData(struct soap *soap, const char *tag, int id, ns4__ProjectData **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons4__ProjectData);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons4__ProjectData(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns4__ProjectData *** SOAP_FMAC4 soap_get_PointerToPointerTons4__ProjectData(struct soap *soap, ns4__ProjectData ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons4__ProjectData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns4__ProjectData *** SOAP_FMAC4 soap_in_PointerToPointerTons4__ProjectData(struct soap *soap, const char *tag, ns4__ProjectData ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns4__ProjectData ***)soap_malloc(soap, sizeof(ns4__ProjectData **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons4__ProjectData(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns4__ProjectData ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons4__ProjectData, sizeof(ns4__ProjectData *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__ProjectData(struct soap *soap, ns4__ProjectData *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__ProjectData))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__ProjectData(struct soap *soap, ns4__ProjectData *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__ProjectData);
	if (soap_out_PointerTons4__ProjectData(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__ProjectData(struct soap *soap, const char *tag, int id, ns4__ProjectData *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__ProjectData);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns4__ProjectData ** SOAP_FMAC4 soap_get_PointerTons4__ProjectData(struct soap *soap, ns4__ProjectData **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__ProjectData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns4__ProjectData ** SOAP_FMAC4 soap_in_PointerTons4__ProjectData(struct soap *soap, const char *tag, ns4__ProjectData **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns4__ProjectData **)soap_malloc(soap, sizeof(ns4__ProjectData *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns4__ProjectData *)soap_instantiate_ns4__ProjectData(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns4__ProjectData ** p = (ns4__ProjectData **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__ProjectData, sizeof(ns4__ProjectData), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons4__PersonData(struct soap *soap, ns4__PersonData **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons4__PersonData))
		soap_serialize_PointerTons4__PersonData(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons4__PersonData(struct soap *soap, ns4__PersonData **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons4__PersonData);
	if (soap_out_PointerToPointerTons4__PersonData(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons4__PersonData(struct soap *soap, const char *tag, int id, ns4__PersonData **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons4__PersonData);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons4__PersonData(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns4__PersonData *** SOAP_FMAC4 soap_get_PointerToPointerTons4__PersonData(struct soap *soap, ns4__PersonData ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons4__PersonData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns4__PersonData *** SOAP_FMAC4 soap_in_PointerToPointerTons4__PersonData(struct soap *soap, const char *tag, ns4__PersonData ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns4__PersonData ***)soap_malloc(soap, sizeof(ns4__PersonData **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons4__PersonData(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns4__PersonData ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons4__PersonData, sizeof(ns4__PersonData *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__PersonData(struct soap *soap, ns4__PersonData *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__PersonData))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__PersonData(struct soap *soap, ns4__PersonData *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__PersonData);
	if (soap_out_PointerTons4__PersonData(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__PersonData(struct soap *soap, const char *tag, int id, ns4__PersonData *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__PersonData);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns4__PersonData ** SOAP_FMAC4 soap_get_PointerTons4__PersonData(struct soap *soap, ns4__PersonData **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__PersonData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns4__PersonData ** SOAP_FMAC4 soap_in_PointerTons4__PersonData(struct soap *soap, const char *tag, ns4__PersonData **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns4__PersonData **)soap_malloc(soap, sizeof(ns4__PersonData *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns4__PersonData *)soap_instantiate_ns4__PersonData(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns4__PersonData ** p = (ns4__PersonData **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__PersonData, sizeof(ns4__PersonData), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons4__TimeEntryData(struct soap *soap, ns4__TimeEntryData **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons4__TimeEntryData))
		soap_serialize_PointerTons4__TimeEntryData(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons4__TimeEntryData(struct soap *soap, ns4__TimeEntryData **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons4__TimeEntryData);
	if (soap_out_PointerToPointerTons4__TimeEntryData(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons4__TimeEntryData(struct soap *soap, const char *tag, int id, ns4__TimeEntryData **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons4__TimeEntryData);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons4__TimeEntryData(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns4__TimeEntryData *** SOAP_FMAC4 soap_get_PointerToPointerTons4__TimeEntryData(struct soap *soap, ns4__TimeEntryData ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons4__TimeEntryData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns4__TimeEntryData *** SOAP_FMAC4 soap_in_PointerToPointerTons4__TimeEntryData(struct soap *soap, const char *tag, ns4__TimeEntryData ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns4__TimeEntryData ***)soap_malloc(soap, sizeof(ns4__TimeEntryData **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons4__TimeEntryData(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns4__TimeEntryData ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons4__TimeEntryData, sizeof(ns4__TimeEntryData *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__TimeEntryData(struct soap *soap, ns4__TimeEntryData *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__TimeEntryData))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__TimeEntryData(struct soap *soap, ns4__TimeEntryData *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__TimeEntryData);
	if (soap_out_PointerTons4__TimeEntryData(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__TimeEntryData(struct soap *soap, const char *tag, int id, ns4__TimeEntryData *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__TimeEntryData);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns4__TimeEntryData ** SOAP_FMAC4 soap_get_PointerTons4__TimeEntryData(struct soap *soap, ns4__TimeEntryData **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__TimeEntryData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns4__TimeEntryData ** SOAP_FMAC4 soap_in_PointerTons4__TimeEntryData(struct soap *soap, const char *tag, ns4__TimeEntryData **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns4__TimeEntryData **)soap_malloc(soap, sizeof(ns4__TimeEntryData *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns4__TimeEntryData *)soap_instantiate_ns4__TimeEntryData(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns4__TimeEntryData ** p = (ns4__TimeEntryData **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__TimeEntryData, sizeof(ns4__TimeEntryData), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons4__TaskData(struct soap *soap, ns4__TaskData **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons4__TaskData))
		soap_serialize_PointerTons4__TaskData(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons4__TaskData(struct soap *soap, ns4__TaskData **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons4__TaskData);
	if (soap_out_PointerToPointerTons4__TaskData(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons4__TaskData(struct soap *soap, const char *tag, int id, ns4__TaskData **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons4__TaskData);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons4__TaskData(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns4__TaskData *** SOAP_FMAC4 soap_get_PointerToPointerTons4__TaskData(struct soap *soap, ns4__TaskData ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons4__TaskData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns4__TaskData *** SOAP_FMAC4 soap_in_PointerToPointerTons4__TaskData(struct soap *soap, const char *tag, ns4__TaskData ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns4__TaskData ***)soap_malloc(soap, sizeof(ns4__TaskData **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons4__TaskData(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns4__TaskData ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons4__TaskData, sizeof(ns4__TaskData *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__TaskData(struct soap *soap, ns4__TaskData *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__TaskData))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__TaskData(struct soap *soap, ns4__TaskData *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__TaskData);
	if (soap_out_PointerTons4__TaskData(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__TaskData(struct soap *soap, const char *tag, int id, ns4__TaskData *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__TaskData);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns4__TaskData ** SOAP_FMAC4 soap_get_PointerTons4__TaskData(struct soap *soap, ns4__TaskData **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__TaskData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns4__TaskData ** SOAP_FMAC4 soap_in_PointerTons4__TaskData(struct soap *soap, const char *tag, ns4__TaskData **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns4__TaskData **)soap_malloc(soap, sizeof(ns4__TaskData *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns4__TaskData *)soap_instantiate_ns4__TaskData(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns4__TaskData ** p = (ns4__TaskData **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__TaskData, sizeof(ns4__TaskData), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons4__UserStoryData(struct soap *soap, ns4__UserStoryData **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons4__UserStoryData))
		soap_serialize_PointerTons4__UserStoryData(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons4__UserStoryData(struct soap *soap, ns4__UserStoryData **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons4__UserStoryData);
	if (soap_out_PointerToPointerTons4__UserStoryData(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons4__UserStoryData(struct soap *soap, const char *tag, int id, ns4__UserStoryData **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons4__UserStoryData);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons4__UserStoryData(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns4__UserStoryData *** SOAP_FMAC4 soap_get_PointerToPointerTons4__UserStoryData(struct soap *soap, ns4__UserStoryData ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons4__UserStoryData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns4__UserStoryData *** SOAP_FMAC4 soap_in_PointerToPointerTons4__UserStoryData(struct soap *soap, const char *tag, ns4__UserStoryData ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns4__UserStoryData ***)soap_malloc(soap, sizeof(ns4__UserStoryData **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons4__UserStoryData(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns4__UserStoryData ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons4__UserStoryData, sizeof(ns4__UserStoryData *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__UserStoryData(struct soap *soap, ns4__UserStoryData *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__UserStoryData))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__UserStoryData(struct soap *soap, ns4__UserStoryData *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__UserStoryData);
	if (soap_out_PointerTons4__UserStoryData(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__UserStoryData(struct soap *soap, const char *tag, int id, ns4__UserStoryData *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__UserStoryData);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns4__UserStoryData ** SOAP_FMAC4 soap_get_PointerTons4__UserStoryData(struct soap *soap, ns4__UserStoryData **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__UserStoryData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns4__UserStoryData ** SOAP_FMAC4 soap_in_PointerTons4__UserStoryData(struct soap *soap, const char *tag, ns4__UserStoryData **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns4__UserStoryData **)soap_malloc(soap, sizeof(ns4__UserStoryData *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns4__UserStoryData *)soap_instantiate_ns4__UserStoryData(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns4__UserStoryData ** p = (ns4__UserStoryData **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__UserStoryData, sizeof(ns4__UserStoryData), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons4__IterationData(struct soap *soap, ns4__IterationData **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons4__IterationData))
		soap_serialize_PointerTons4__IterationData(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons4__IterationData(struct soap *soap, ns4__IterationData **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons4__IterationData);
	if (soap_out_PointerToPointerTons4__IterationData(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons4__IterationData(struct soap *soap, const char *tag, int id, ns4__IterationData **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons4__IterationData);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons4__IterationData(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns4__IterationData *** SOAP_FMAC4 soap_get_PointerToPointerTons4__IterationData(struct soap *soap, ns4__IterationData ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons4__IterationData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns4__IterationData *** SOAP_FMAC4 soap_in_PointerToPointerTons4__IterationData(struct soap *soap, const char *tag, ns4__IterationData ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns4__IterationData ***)soap_malloc(soap, sizeof(ns4__IterationData **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons4__IterationData(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns4__IterationData ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons4__IterationData, sizeof(ns4__IterationData *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons4__IterationData(struct soap *soap, ns4__IterationData *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns4__IterationData))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons4__IterationData(struct soap *soap, ns4__IterationData *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons4__IterationData);
	if (soap_out_PointerTons4__IterationData(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons4__IterationData(struct soap *soap, const char *tag, int id, ns4__IterationData *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns4__IterationData);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns4__IterationData ** SOAP_FMAC4 soap_get_PointerTons4__IterationData(struct soap *soap, ns4__IterationData **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons4__IterationData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns4__IterationData ** SOAP_FMAC4 soap_in_PointerTons4__IterationData(struct soap *soap, const char *tag, ns4__IterationData **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns4__IterationData **)soap_malloc(soap, sizeof(ns4__IterationData *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns4__IterationData *)soap_instantiate_ns4__IterationData(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns4__IterationData ** p = (ns4__IterationData **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns4__IterationData, sizeof(ns4__IterationData), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotime(struct soap *soap, time_t *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_time);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotime(struct soap *soap, time_t *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTotime);
	if (soap_out_PointerTotime(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotime(struct soap *soap, const char *tag, int id, time_t *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_time);
	if (id < 0)
		return soap->error;
	return soap_out_time(soap, tag, id, *a, type);
}

SOAP_FMAC3 time_t ** SOAP_FMAC4 soap_get_PointerTotime(struct soap *soap, time_t **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 time_t ** SOAP_FMAC4 soap_in_PointerTotime(struct soap *soap, const char *tag, time_t **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (time_t **)soap_malloc(soap, sizeof(time_t *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_time(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (time_t **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_time, sizeof(time_t), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons2__mapItem(struct soap *soap, ns2__mapItem **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons2__mapItem))
		soap_serialize_PointerTons2__mapItem(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons2__mapItem(struct soap *soap, ns2__mapItem **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons2__mapItem);
	if (soap_out_PointerToPointerTons2__mapItem(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons2__mapItem(struct soap *soap, const char *tag, int id, ns2__mapItem **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons2__mapItem);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons2__mapItem(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns2__mapItem *** SOAP_FMAC4 soap_get_PointerToPointerTons2__mapItem(struct soap *soap, ns2__mapItem ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons2__mapItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns2__mapItem *** SOAP_FMAC4 soap_in_PointerToPointerTons2__mapItem(struct soap *soap, const char *tag, ns2__mapItem ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__mapItem ***)soap_malloc(soap, sizeof(ns2__mapItem **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons2__mapItem(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns2__mapItem ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons2__mapItem, sizeof(ns2__mapItem *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__mapItem(struct soap *soap, ns2__mapItem *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__mapItem))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__mapItem(struct soap *soap, ns2__mapItem *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__mapItem);
	if (soap_out_PointerTons2__mapItem(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__mapItem(struct soap *soap, const char *tag, int id, ns2__mapItem *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__mapItem);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__mapItem ** SOAP_FMAC4 soap_get_PointerTons2__mapItem(struct soap *soap, ns2__mapItem **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__mapItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns2__mapItem ** SOAP_FMAC4 soap_in_PointerTons2__mapItem(struct soap *soap, const char *tag, ns2__mapItem **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__mapItem **)soap_malloc(soap, sizeof(ns2__mapItem *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__mapItem *)soap_instantiate_ns2__mapItem(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__mapItem ** p = (ns2__mapItem **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__mapItem, sizeof(ns2__mapItem), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__anyType(struct soap *soap, xsd__anyType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__anyType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__anyType(struct soap *soap, xsd__anyType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__anyType);
	if (soap_out_PointerToxsd__anyType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__anyType(struct soap *soap, const char *tag, int id, xsd__anyType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__anyType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 xsd__anyType ** SOAP_FMAC4 soap_get_PointerToxsd__anyType(struct soap *soap, xsd__anyType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__anyType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 xsd__anyType ** SOAP_FMAC4 soap_in_PointerToxsd__anyType(struct soap *soap, const char *tag, xsd__anyType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (xsd__anyType **)soap_malloc(soap, sizeof(xsd__anyType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (xsd__anyType *)soap_instantiate_xsd__anyType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	xsd__anyType ** p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__anyType, sizeof(xsd__anyType), 0);
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__boolean, sizeof(xsd__boolean), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__dateTime, sizeof(xsd__dateTime), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__double, sizeof(xsd__double), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__int, sizeof(xsd__int), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__mapItem, sizeof(ns2__mapItem), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__Map, sizeof(ns2__Map), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns3__DomainData, sizeof(ns3__DomainData), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns5__QueryException, sizeof(ns5__QueryException), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ArrayOf_USCOREtns1_USCOREIterationData, sizeof(ArrayOf_USCOREtns1_USCOREIterationData), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ArrayOf_USCOREtns1_USCOREUserStoryData, sizeof(ArrayOf_USCOREtns1_USCOREUserStoryData), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ArrayOf_USCOREtns1_USCORETaskData, sizeof(ArrayOf_USCOREtns1_USCORETaskData), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ArrayOf_USCOREtns1_USCORETimeEntryData, sizeof(ArrayOf_USCOREtns1_USCORETimeEntryData), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ArrayOf_USCOREtns1_USCOREPersonData, sizeof(ArrayOf_USCOREtns1_USCOREPersonData), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ArrayOf_USCOREtns1_USCOREProjectData, sizeof(ArrayOf_USCOREtns1_USCOREProjectData), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ArrayOf_USCOREtns1_USCORENoteData, sizeof(ArrayOf_USCOREtns1_USCORENoteData), 0);
		}
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__QName(struct soap *soap, char **a)
{	soap_default_string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(struct soap *soap, char *const*a)
{	soap_serialize_string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__QName);
	if (soap_out__QName(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, -1, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap *soap, char **a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_string
	*a = SOAP_DEFAULT_string;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_string);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_string);
	if (soap_out_string(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, -1, -1);
}

/* End of XplannerSOAPC.cpp */
