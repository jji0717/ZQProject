; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.50727.42 

	TITLE	d:\Git_ZQProjs\ZQproj\Generic\CdmiFuse\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT

PUBLIC	??_C@_0P@GHFPNOJB@bad?5allocation?$AA@		; `string'
PUBLIC	?minInt@Value@Json@@2HB				; Json::Value::minInt
PUBLIC	?maxInt@Value@Json@@2HB				; Json::Value::maxInt
PUBLIC	?maxUInt@Value@Json@@2IB			; Json::Value::maxUInt
PUBLIC	?minInt64@Value@Json@@2_JB			; Json::Value::minInt64
PUBLIC	?maxInt64@Value@Json@@2_JB			; Json::Value::maxInt64
PUBLIC	?maxUInt64@Value@Json@@2_KB			; Json::Value::maxUInt64
CONST	SEGMENT
?minInt@Value@Json@@2HB DD 080000000H			; Json::Value::minInt
?maxInt@Value@Json@@2HB DD 07fffffffH			; Json::Value::maxInt
?maxUInt@Value@Json@@2IB DD 0ffffffffH			; Json::Value::maxUInt
	ORG $+4
?minInt64@Value@Json@@2_JB DQ 8000000000000000H		; Json::Value::minInt64
?maxInt64@Value@Json@@2_JB DQ 7fffffffffffffffH		; Json::Value::maxInt64
?maxUInt64@Value@Json@@2_KB DQ ffffffffffffffffH	; Json::Value::maxUInt64
CONST	ENDS
_DATA	SEGMENT
__bad_alloc_Message DD FLAT:??_C@_0P@GHFPNOJB@bad?5allocation?$AA@
_DATA	ENDS
;	COMDAT ??_C@_0P@GHFPNOJB@bad?5allocation?$AA@
CONST	SEGMENT
??_C@_0P@GHFPNOJB@bad?5allocation?$AA@ DB 'bad allocation', 00H ; `string'
CONST	ENDS
PUBLIC	??_7ValueAllocator@Json@@6B@			; Json::ValueAllocator::`vftable'
PUBLIC	??1ValueAllocator@Json@@UAE@XZ			; Json::ValueAllocator::~ValueAllocator
PUBLIC	??_R4ValueAllocator@Json@@6B@			; Json::ValueAllocator::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVValueAllocator@Json@@@8			; Json::ValueAllocator `RTTI Type Descriptor'
PUBLIC	??_R3ValueAllocator@Json@@8			; Json::ValueAllocator::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2ValueAllocator@Json@@8			; Json::ValueAllocator::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@ValueAllocator@Json@@8		; Json::ValueAllocator::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??_EValueAllocator@Json@@UAEPAXI@Z:PROC		; Json::ValueAllocator::`vector deleting destructor'
EXTRN	__purecall:PROC
;	COMDAT ??_R1A@?0A@EA@ValueAllocator@Json@@8
; File d:\git_zqprojs\zqproj\generic\cdmifuse\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp
rdata$r	SEGMENT
??_R1A@?0A@EA@ValueAllocator@Json@@8 DD FLAT:??_R0?AVValueAllocator@Json@@@8 ; Json::ValueAllocator::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3ValueAllocator@Json@@8
rdata$r	ENDS
;	COMDAT ??_R2ValueAllocator@Json@@8
rdata$r	SEGMENT
??_R2ValueAllocator@Json@@8 DD FLAT:??_R1A@?0A@EA@ValueAllocator@Json@@8 ; Json::ValueAllocator::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3ValueAllocator@Json@@8
rdata$r	SEGMENT
??_R3ValueAllocator@Json@@8 DD 00H			; Json::ValueAllocator::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2ValueAllocator@Json@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVValueAllocator@Json@@@8
_DATA	SEGMENT
??_R0?AVValueAllocator@Json@@@8 DD FLAT:??_7type_info@@6B@ ; Json::ValueAllocator `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVValueAllocator@Json@@', 00H
_DATA	ENDS
;	COMDAT ??_R4ValueAllocator@Json@@6B@
rdata$r	SEGMENT
??_R4ValueAllocator@Json@@6B@ DD 00H			; Json::ValueAllocator::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVValueAllocator@Json@@@8
	DD	FLAT:??_R3ValueAllocator@Json@@8
rdata$r	ENDS
;	COMDAT ??_7ValueAllocator@Json@@6B@
CONST	SEGMENT
??_7ValueAllocator@Json@@6B@ DD FLAT:??_R4ValueAllocator@Json@@6B@ ; Json::ValueAllocator::`vftable'
	DD	FLAT:??_EValueAllocator@Json@@UAEPAXI@Z
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ??1ValueAllocator@Json@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1ValueAllocator@Json@@UAE@XZ PROC			; Json::ValueAllocator::~ValueAllocator, COMDAT
; _this$ = ecx

; 60   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7ValueAllocator@Json@@6B@

; 61   : }

	mov	esp, ebp
	pop	ebp
	ret	0
??1ValueAllocator@Json@@UAE@XZ ENDP			; Json::ValueAllocator::~ValueAllocator
_TEXT	ENDS
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Odtp
;	COMDAT ??_GValueAllocator@Json@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GValueAllocator@Json@@UAEPAXI@Z PROC			; Json::ValueAllocator::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1ValueAllocator@Json@@UAE@XZ		; Json::ValueAllocator::~ValueAllocator
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GValueAllocator@Json@@UAEPAXI@Z ENDP			; Json::ValueAllocator::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??0iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::iterator::iterator
PUBLIC	??0ValueIteratorBase@Json@@QAE@XZ		; Json::ValueIteratorBase::ValueIteratorBase
; Function compile flags: /Odtp
; File d:\git_zqprojs\zqproj\generic\cdmifuse\jsoncpp-src-0.5.0\src\lib_json\json_valueiterator.inl
;	COMDAT ??0ValueIteratorBase@Json@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0ValueIteratorBase@Json@@QAE@XZ PROC			; Json::ValueIteratorBase::ValueIteratorBase, COMDAT
; _this$ = ecx

; 17   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::iterator::iterator
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+8], 1

; 18   : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0ValueIteratorBase@Json@@QAE@XZ ENDP			; Json::ValueIteratorBase::ValueIteratorBase
_TEXT	ENDS
PUBLIC	??0ValueIteratorBase@Json@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@Z ; Json::ValueIteratorBase::ValueIteratorBase
; Function compile flags: /Odtp
;	COMDAT ??0ValueIteratorBase@Json@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_current$ = 8						; size = 4
??0ValueIteratorBase@Json@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@Z PROC ; Json::ValueIteratorBase::ValueIteratorBase, COMDAT
; _this$ = ecx

; 32   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _current$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+8], 0

; 33   : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0ValueIteratorBase@Json@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@Z ENDP ; Json::ValueIteratorBase::ValueIteratorBase
_TEXT	ENDS
PUBLIC	??Citerator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBEPAU?$pair@$$CBVCZString@Value@Json@@V23@@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::iterator::operator->
PUBLIC	?deref@ValueIteratorBase@Json@@IBEAAVValue@2@XZ	; Json::ValueIteratorBase::deref
; Function compile flags: /Odtp
;	COMDAT ?deref@ValueIteratorBase@Json@@IBEAAVValue@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?deref@ValueIteratorBase@Json@@IBEAAVValue@2@XZ PROC	; Json::ValueIteratorBase::deref, COMDAT
; _this$ = ecx

; 51   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 52   : #ifndef JSON_VALUE_USE_INTERNAL_MAP
; 53   :    return current_->second;

	mov	ecx, DWORD PTR _this$[ebp]
	call	??Citerator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBEPAU?$pair@$$CBVCZString@Value@Json@@V23@@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::iterator::operator->
	add	eax, 8

; 54   : #else
; 55   :    if ( isArray_ )
; 56   :       return ValueInternalArray::dereference( iterator_.array_ );
; 57   :    return ValueInternalMap::value( iterator_.map_ );
; 58   : #endif
; 59   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?deref@ValueIteratorBase@Json@@IBEAAVValue@2@XZ ENDP	; Json::ValueIteratorBase::deref
_TEXT	ENDS
PUBLIC	??Eiterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::iterator::operator++
PUBLIC	?increment@ValueIteratorBase@Json@@IAEXXZ	; Json::ValueIteratorBase::increment
; Function compile flags: /Odtp
;	COMDAT ?increment@ValueIteratorBase@Json@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?increment@ValueIteratorBase@Json@@IAEXXZ PROC		; Json::ValueIteratorBase::increment, COMDAT
; _this$ = ecx

; 64   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 65   : #ifndef JSON_VALUE_USE_INTERNAL_MAP
; 66   :    ++current_;

	mov	ecx, DWORD PTR _this$[ebp]
	call	??Eiterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::iterator::operator++

; 67   : #else
; 68   :    if ( isArray_ )
; 69   :       ValueInternalArray::increment( iterator_.array_ );
; 70   :    ValueInternalMap::increment( iterator_.map_ );
; 71   : #endif
; 72   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?increment@ValueIteratorBase@Json@@IAEXXZ ENDP		; Json::ValueIteratorBase::increment
_TEXT	ENDS
PUBLIC	??Fiterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::iterator::operator--
PUBLIC	?decrement@ValueIteratorBase@Json@@IAEXXZ	; Json::ValueIteratorBase::decrement
; Function compile flags: /Odtp
;	COMDAT ?decrement@ValueIteratorBase@Json@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?decrement@ValueIteratorBase@Json@@IAEXXZ PROC		; Json::ValueIteratorBase::decrement, COMDAT
; _this$ = ecx

; 77   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 78   : #ifndef JSON_VALUE_USE_INTERNAL_MAP
; 79   :    --current_;

	mov	ecx, DWORD PTR _this$[ebp]
	call	??Fiterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::iterator::operator--

; 80   : #else
; 81   :    if ( isArray_ )
; 82   :       ValueInternalArray::decrement( iterator_.array_ );
; 83   :    ValueInternalMap::decrement( iterator_.map_ );
; 84   : #endif
; 85   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?decrement@ValueIteratorBase@Json@@IAEXXZ ENDP		; Json::ValueIteratorBase::decrement
_TEXT	ENDS
PUBLIC	??9const_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator::operator!=
PUBLIC	?computeDistance@ValueIteratorBase@Json@@IBEHABV12@@Z ; Json::ValueIteratorBase::computeDistance
; Function compile flags: /Odtp
;	COMDAT ?computeDistance@ValueIteratorBase@Json@@IBEHABV12@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
_it$20948 = -12						; size = 8
_myDistance$ = -4					; size = 4
_other$ = 8						; size = 4
?computeDistance@ValueIteratorBase@Json@@IBEHABV12@@Z PROC ; Json::ValueIteratorBase::computeDistance, COMDAT
; _this$ = ecx

; 90   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 91   : #ifndef JSON_VALUE_USE_INTERNAL_MAP
; 92   : # ifdef JSON_USE_CPPTL_SMALLMAP
; 93   :    return current_ - other.current_;
; 94   : # else
; 95   :    // Iterator for null value are initialized using the default
; 96   :    // constructor, which initialize current_ to the default
; 97   :    // std::map::iterator. As begin() and end() are two instance 
; 98   :    // of the default std::map::iterator, they can not be compared.
; 99   :    // To allow this, we handle this comparison specifically.
; 100  :    if ( isNull_  &&  other.isNull_ )

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+8]
	test	ecx, ecx
	je	SHORT $LN4@computeDis
	mov	edx, DWORD PTR _other$[ebp]
	movzx	eax, BYTE PTR [edx+8]
	test	eax, eax
	je	SHORT $LN4@computeDis

; 101  :    {
; 102  :       return 0;

	xor	eax, eax
	jmp	SHORT $LN5@computeDis
$LN4@computeDis:

; 103  :    }
; 104  : 
; 105  : 
; 106  :    // Usage of std::distance is not portable (does not compile with Sun Studio 12 RogueWave STL,
; 107  :    // which is the one used by default).
; 108  :    // Using a portable hand-made version for non random iterator instead:
; 109  :    //   return difference_type( std::distance( current_, other.current_ ) );
; 110  :    difference_type myDistance = 0;

	mov	DWORD PTR _myDistance$[ebp], 0

; 111  :    for ( Value::ObjectValues::iterator it = current_; it != other.current_; ++it )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR _it$20948[ebp], edx
	mov	DWORD PTR _it$20948[ebp+4], eax
	jmp	SHORT $LN3@computeDis
$LN2@computeDis:
	lea	ecx, DWORD PTR _it$20948[ebp]
	call	??Eiterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::iterator::operator++
$LN3@computeDis:
	mov	ecx, DWORD PTR _other$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _it$20948[ebp]
	call	??9const_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator::operator!=
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN1@computeDis

; 112  :    {
; 113  :       ++myDistance;

	mov	eax, DWORD PTR _myDistance$[ebp]
	add	eax, 1
	mov	DWORD PTR _myDistance$[ebp], eax

; 114  :    }

	jmp	SHORT $LN2@computeDis
$LN1@computeDis:

; 115  :    return myDistance;

	mov	eax, DWORD PTR _myDistance$[ebp]
$LN5@computeDis:

; 116  : # endif
; 117  : #else
; 118  :    if ( isArray_ )
; 119  :       return ValueInternalArray::distance( iterator_.array_, other.iterator_.array_ );
; 120  :    return ValueInternalMap::distance( iterator_.map_, other.iterator_.map_ );
; 121  : #endif
; 122  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?computeDistance@ValueIteratorBase@Json@@IBEHABV12@@Z ENDP ; Json::ValueIteratorBase::computeDistance
_TEXT	ENDS
PUBLIC	??8const_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator::operator==
PUBLIC	?isEqual@ValueIteratorBase@Json@@IBE_NABV12@@Z	; Json::ValueIteratorBase::isEqual
; Function compile flags: /Odtp
;	COMDAT ?isEqual@ValueIteratorBase@Json@@IBE_NABV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_other$ = 8						; size = 4
?isEqual@ValueIteratorBase@Json@@IBE_NABV12@@Z PROC	; Json::ValueIteratorBase::isEqual, COMDAT
; _this$ = ecx

; 127  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 128  : #ifndef JSON_VALUE_USE_INTERNAL_MAP
; 129  :    if ( isNull_ )

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+8]
	test	ecx, ecx
	je	SHORT $LN1@isEqual

; 130  :    {
; 131  :       return other.isNull_;

	mov	edx, DWORD PTR _other$[ebp]
	mov	al, BYTE PTR [edx+8]
	jmp	SHORT $LN2@isEqual
$LN1@isEqual:

; 132  :    }
; 133  :    return current_ == other.current_;

	mov	eax, DWORD PTR _other$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8const_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator::operator==
$LN2@isEqual:

; 134  : #else
; 135  :    if ( isArray_ )
; 136  :       return ValueInternalArray::equals( iterator_.array_, other.iterator_.array_ );
; 137  :    return ValueInternalMap::equals( iterator_.map_, other.iterator_.map_ );
; 138  : #endif
; 139  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?isEqual@ValueIteratorBase@Json@@IBE_NABV12@@Z ENDP	; Json::ValueIteratorBase::isEqual
_TEXT	ENDS
PUBLIC	?copy@ValueIteratorBase@Json@@IAEXABV12@@Z	; Json::ValueIteratorBase::copy
; Function compile flags: /Odtp
;	COMDAT ?copy@ValueIteratorBase@Json@@IAEXABV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_other$ = 8						; size = 4
?copy@ValueIteratorBase@Json@@IAEXABV12@@Z PROC		; Json::ValueIteratorBase::copy, COMDAT
; _this$ = ecx

; 144  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 145  : #ifndef JSON_VALUE_USE_INTERNAL_MAP
; 146  :    current_ = other.current_;

	mov	eax, DWORD PTR _other$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx

; 147  :    isNull_ = other.isNull_;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _other$[ebp]
	mov	al, BYTE PTR [edx+8]
	mov	BYTE PTR [ecx+8], al

; 148  : #else
; 149  :    if ( isArray_ )
; 150  :       iterator_.array_ = other.iterator_.array_;
; 151  :    iterator_.map_ = other.iterator_.map_;
; 152  : #endif
; 153  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?copy@ValueIteratorBase@Json@@IAEXABV12@@Z ENDP		; Json::ValueIteratorBase::copy
_TEXT	ENDS
PUBLIC	??1Value@Json@@QAE@XZ				; Json::Value::~Value
PUBLIC	??0Value@Json@@QAE@H@Z				; Json::Value::Value
PUBLIC	?index@CZString@Value@Json@@QBEHXZ		; Json::Value::CZString::index
PUBLIC	??0Value@Json@@QAE@PBD@Z			; Json::Value::Value
PUBLIC	??1CZString@Value@Json@@QAE@XZ			; Json::Value::CZString::~CZString
PUBLIC	??0Value@Json@@QAE@ABVStaticString@1@@Z		; Json::Value::Value
PUBLIC	??0StaticString@Json@@QAE@PBD@Z			; Json::StaticString::StaticString
PUBLIC	?isStaticString@CZString@Value@Json@@QBE_NXZ	; Json::Value::CZString::isStaticString
PUBLIC	?c_str@CZString@Value@Json@@QBEPBDXZ		; Json::Value::CZString::c_str
PUBLIC	??0CZString@Value@Json@@QAE@ABV012@@Z		; Json::Value::CZString::CZString
PUBLIC	??Diterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBEAAU?$pair@$$CBVCZString@Value@Json@@V23@@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::iterator::operator*
PUBLIC	?key@ValueIteratorBase@Json@@QBE?AVValue@2@XZ	; Json::ValueIteratorBase::key
EXTRN	___security_cookie:DWORD
EXTRN	___CxxFrameHandler3:PROC
EXTRN	@__security_check_cookie@4:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?key@ValueIteratorBase@Json@@QBE?AVValue@2@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?key@ValueIteratorBase@Json@@QBE?AVValue@2@XZ$1
	DD	00H
	DD	FLAT:__unwindfunclet$?key@ValueIteratorBase@Json@@QBE?AVValue@2@XZ$0
__ehfuncinfo$?key@ValueIteratorBase@Json@@QBE?AVValue@2@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?key@ValueIteratorBase@Json@@QBE?AVValue@2@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?key@ValueIteratorBase@Json@@QBE?AVValue@2@XZ
_TEXT	SEGMENT
_this$ = -32						; size = 4
$T30923 = -28						; size = 4
$T30920 = -24						; size = 4
_czstring$ = -20					; size = 8
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
?key@ValueIteratorBase@Json@@QBE?AVValue@2@XZ PROC	; Json::ValueIteratorBase::key, COMDAT
; _this$ = ecx

; 158  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?key@ValueIteratorBase@Json@@QBE?AVValue@2@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T30923[ebp], 0

; 159  : #ifndef JSON_VALUE_USE_INTERNAL_MAP
; 160  :    const Value::CZString czstring = (*current_).first;

	mov	ecx, DWORD PTR _this$[ebp]
	call	??Diterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBEAAU?$pair@$$CBVCZString@Value@Json@@V23@@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::iterator::operator*
	push	eax
	lea	ecx, DWORD PTR _czstring$[ebp]
	call	??0CZString@Value@Json@@QAE@ABV012@@Z	; Json::Value::CZString::CZString
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 161  :    if ( czstring.c_str() )

	lea	ecx, DWORD PTR _czstring$[ebp]
	call	?c_str@CZString@Value@Json@@QBEPBDXZ	; Json::Value::CZString::c_str
	test	eax, eax
	je	SHORT $LN2@key

; 162  :    {
; 163  :       if ( czstring.isStaticString() )

	lea	ecx, DWORD PTR _czstring$[ebp]
	call	?isStaticString@CZString@Value@Json@@QBE_NXZ ; Json::Value::CZString::isStaticString
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@key

; 164  :          return Value( StaticString( czstring.c_str() ) );

	lea	ecx, DWORD PTR _czstring$[ebp]
	call	?c_str@CZString@Value@Json@@QBEPBDXZ	; Json::Value::CZString::c_str
	push	eax
	lea	ecx, DWORD PTR $T30920[ebp]
	call	??0StaticString@Json@@QAE@PBD@Z		; Json::StaticString::StaticString
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Value@Json@@QAE@ABVStaticString@1@@Z	; Json::Value::Value
	mov	ecx, DWORD PTR $T30923[ebp]
	or	ecx, 1
	mov	DWORD PTR $T30923[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _czstring$[ebp]
	call	??1CZString@Value@Json@@QAE@XZ		; Json::Value::CZString::~CZString
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN3@key
$LN1@key:

; 165  :       return Value( czstring.c_str() );

	lea	ecx, DWORD PTR _czstring$[ebp]
	call	?c_str@CZString@Value@Json@@QBEPBDXZ	; Json::Value::CZString::c_str
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Value@Json@@QAE@PBD@Z		; Json::Value::Value
	mov	edx, DWORD PTR $T30923[ebp]
	or	edx, 1
	mov	DWORD PTR $T30923[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _czstring$[ebp]
	call	??1CZString@Value@Json@@QAE@XZ		; Json::Value::CZString::~CZString
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN3@key
$LN2@key:

; 166  :    }
; 167  :    return Value( czstring.index() );

	lea	ecx, DWORD PTR _czstring$[ebp]
	call	?index@CZString@Value@Json@@QBEHXZ	; Json::Value::CZString::index
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Value@Json@@QAE@H@Z			; Json::Value::Value
	mov	eax, DWORD PTR $T30923[ebp]
	or	eax, 1
	mov	DWORD PTR $T30923[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _czstring$[ebp]
	call	??1CZString@Value@Json@@QAE@XZ		; Json::Value::CZString::~CZString
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN3@key:

; 168  : #else
; 169  :    if ( isArray_ )
; 170  :       return Value( ValueInternalArray::indexOf( iterator_.array_ ) );
; 171  :    bool isStatic;
; 172  :    const char *memberName = ValueInternalMap::key( iterator_.map_, isStatic );
; 173  :    if ( isStatic )
; 174  :       return Value( StaticString( memberName ) );
; 175  :    return Value( memberName );
; 176  : #endif
; 177  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?key@ValueIteratorBase@Json@@QBE?AVValue@2@XZ$0:
	lea	ecx, DWORD PTR _czstring$[ebp]
	jmp	??1CZString@Value@Json@@QAE@XZ		; Json::Value::CZString::~CZString
__unwindfunclet$?key@ValueIteratorBase@Json@@QBE?AVValue@2@XZ$1:
	mov	eax, DWORD PTR $T30923[ebp]
	and	eax, 1
	je	$LN7@key
	and	DWORD PTR $T30923[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	??1Value@Json@@QAE@XZ			; Json::Value::~Value
$LN7@key:
	ret	0
__ehhandler$?key@ValueIteratorBase@Json@@QBE?AVValue@2@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?key@ValueIteratorBase@Json@@QBE?AVValue@2@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?key@ValueIteratorBase@Json@@QBE?AVValue@2@XZ ENDP	; Json::ValueIteratorBase::key
; Function compile flags: /Odtp
; File d:\git_zqprojs\zqproj\generic\cdmifuse\jsoncpp-src-0.5.0\include\json\value.h
;	COMDAT ??0StaticString@Json@@QAE@PBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_czstring$ = 8						; size = 4
??0StaticString@Json@@QAE@PBD@Z PROC			; Json::StaticString::StaticString, COMDAT
; _this$ = ecx

; 67   :       {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _czstring$[ebp]
	mov	DWORD PTR [eax], ecx

; 68   :       }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0StaticString@Json@@QAE@PBD@Z ENDP			; Json::StaticString::StaticString
_TEXT	ENDS
PUBLIC	?index@ValueIteratorBase@Json@@QBEIXZ		; Json::ValueIteratorBase::index
;	COMDAT xdata$x
; File d:\git_zqprojs\zqproj\generic\cdmifuse\jsoncpp-src-0.5.0\src\lib_json\json_valueiterator.inl
xdata$x	SEGMENT
__unwindtable$?index@ValueIteratorBase@Json@@QBEIXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?index@ValueIteratorBase@Json@@QBEIXZ$0
__ehfuncinfo$?index@ValueIteratorBase@Json@@QBEIXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?index@ValueIteratorBase@Json@@QBEIXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?index@ValueIteratorBase@Json@@QBEIXZ
_TEXT	SEGMENT
_this$ = -32						; size = 4
$T30941 = -28						; size = 4
$T30940 = -24						; size = 4
_czstring$ = -20					; size = 8
__$EHRec$ = -12						; size = 12
?index@ValueIteratorBase@Json@@QBEIXZ PROC		; Json::ValueIteratorBase::index, COMDAT
; _this$ = ecx

; 182  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?index@ValueIteratorBase@Json@@QBEIXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 183  : #ifndef JSON_VALUE_USE_INTERNAL_MAP
; 184  :    const Value::CZString czstring = (*current_).first;

	mov	ecx, DWORD PTR _this$[ebp]
	call	??Diterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBEAAU?$pair@$$CBVCZString@Value@Json@@V23@@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::iterator::operator*
	push	eax
	lea	ecx, DWORD PTR _czstring$[ebp]
	call	??0CZString@Value@Json@@QAE@ABV012@@Z	; Json::Value::CZString::CZString
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 185  :    if ( !czstring.c_str() )

	lea	ecx, DWORD PTR _czstring$[ebp]
	call	?c_str@CZString@Value@Json@@QBEPBDXZ	; Json::Value::CZString::c_str
	test	eax, eax
	jne	SHORT $LN1@index

; 186  :       return czstring.index();

	lea	ecx, DWORD PTR _czstring$[ebp]
	call	?index@CZString@Value@Json@@QBEHXZ	; Json::Value::CZString::index
	mov	DWORD PTR $T30940[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _czstring$[ebp]
	call	??1CZString@Value@Json@@QAE@XZ		; Json::Value::CZString::~CZString
	mov	eax, DWORD PTR $T30940[ebp]
	jmp	SHORT $LN2@index
$LN1@index:

; 187  :    return Value::UInt( -1 );

	mov	DWORD PTR $T30941[ebp], -1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _czstring$[ebp]
	call	??1CZString@Value@Json@@QAE@XZ		; Json::Value::CZString::~CZString
	mov	eax, DWORD PTR $T30941[ebp]
$LN2@index:

; 188  : #else
; 189  :    if ( isArray_ )
; 190  :       return Value::UInt( ValueInternalArray::indexOf( iterator_.array_ ) );
; 191  :    return Value::UInt( -1 );
; 192  : #endif
; 193  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?index@ValueIteratorBase@Json@@QBEIXZ$0:
	lea	ecx, DWORD PTR _czstring$[ebp]
	jmp	??1CZString@Value@Json@@QAE@XZ		; Json::Value::CZString::~CZString
__ehhandler$?index@ValueIteratorBase@Json@@QBEIXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?index@ValueIteratorBase@Json@@QBEIXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?index@ValueIteratorBase@Json@@QBEIXZ ENDP		; Json::ValueIteratorBase::index
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	?memberName@ValueIteratorBase@Json@@QBEPBDXZ	; Json::ValueIteratorBase::memberName
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ?memberName@ValueIteratorBase@Json@@QBEPBDXZ
_TEXT	SEGMENT
tv69 = -12						; size = 4
_this$ = -8						; size = 4
_name$ = -4						; size = 4
?memberName@ValueIteratorBase@Json@@QBEPBDXZ PROC	; Json::ValueIteratorBase::memberName, COMDAT
; _this$ = ecx

; 198  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 199  : #ifndef JSON_VALUE_USE_INTERNAL_MAP
; 200  :    const char *name = (*current_).first.c_str();

	mov	ecx, DWORD PTR _this$[ebp]
	call	??Diterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBEAAU?$pair@$$CBVCZString@Value@Json@@V23@@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::iterator::operator*
	mov	ecx, eax
	call	?c_str@CZString@Value@Json@@QBEPBDXZ	; Json::Value::CZString::c_str
	mov	DWORD PTR _name$[ebp], eax

; 201  :    return name ? name : "";

	cmp	DWORD PTR _name$[ebp], 0
	je	SHORT $LN3@memberName
	mov	eax, DWORD PTR _name$[ebp]
	mov	DWORD PTR tv69[ebp], eax
	jmp	SHORT $LN4@memberName
$LN3@memberName:
	mov	DWORD PTR tv69[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN4@memberName:
	mov	eax, DWORD PTR tv69[ebp]

; 202  : #else
; 203  :    if ( !isArray_ )
; 204  :       return ValueInternalMap::key( iterator_.map_ );
; 205  :    return "";
; 206  : #endif
; 207  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?memberName@ValueIteratorBase@Json@@QBEPBDXZ ENDP	; Json::ValueIteratorBase::memberName
_TEXT	ENDS
PUBLIC	??0ValueConstIterator@Json@@QAE@XZ		; Json::ValueConstIterator::ValueConstIterator
; Function compile flags: /Odtp
;	COMDAT ??0ValueConstIterator@Json@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0ValueConstIterator@Json@@QAE@XZ PROC			; Json::ValueConstIterator::ValueConstIterator, COMDAT
; _this$ = ecx

; 219  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0ValueIteratorBase@Json@@QAE@XZ	; Json::ValueIteratorBase::ValueIteratorBase

; 220  : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0ValueConstIterator@Json@@QAE@XZ ENDP			; Json::ValueConstIterator::ValueConstIterator
_TEXT	ENDS
PUBLIC	??0ValueConstIterator@Json@@AAE@ABViterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@Z ; Json::ValueConstIterator::ValueConstIterator
; Function compile flags: /Odtp
;	COMDAT ??0ValueConstIterator@Json@@AAE@ABViterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_current$ = 8						; size = 4
??0ValueConstIterator@Json@@AAE@ABViterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@Z PROC ; Json::ValueConstIterator::ValueConstIterator, COMDAT
; _this$ = ecx

; 226  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _current$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0ValueIteratorBase@Json@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@Z ; Json::ValueIteratorBase::ValueIteratorBase

; 227  : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0ValueConstIterator@Json@@AAE@ABViterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@Z ENDP ; Json::ValueConstIterator::ValueConstIterator
_TEXT	ENDS
PUBLIC	??4ValueConstIterator@Json@@QAEAAV01@ABVValueIteratorBase@1@@Z ; Json::ValueConstIterator::operator=
; Function compile flags: /Odtp
;	COMDAT ??4ValueConstIterator@Json@@QAEAAV01@ABVValueIteratorBase@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_other$ = 8						; size = 4
??4ValueConstIterator@Json@@QAEAAV01@ABVValueIteratorBase@1@@Z PROC ; Json::ValueConstIterator::operator=, COMDAT
; _this$ = ecx

; 242  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 243  :    copy( other );

	mov	eax, DWORD PTR _other$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?copy@ValueIteratorBase@Json@@IAEXABV12@@Z ; Json::ValueIteratorBase::copy

; 244  :    return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 245  : }

	mov	esp, ebp
	pop	ebp
	ret	4
??4ValueConstIterator@Json@@QAEAAV01@ABVValueIteratorBase@1@@Z ENDP ; Json::ValueConstIterator::operator=
_TEXT	ENDS
PUBLIC	??0ValueIterator@Json@@QAE@XZ			; Json::ValueIterator::ValueIterator
; Function compile flags: /Odtp
;	COMDAT ??0ValueIterator@Json@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0ValueIterator@Json@@QAE@XZ PROC			; Json::ValueIterator::ValueIterator, COMDAT
; _this$ = ecx

; 257  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0ValueIteratorBase@Json@@QAE@XZ	; Json::ValueIteratorBase::ValueIteratorBase

; 258  : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0ValueIterator@Json@@QAE@XZ ENDP			; Json::ValueIterator::ValueIterator
_TEXT	ENDS
PUBLIC	??0ValueIterator@Json@@AAE@ABViterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@Z ; Json::ValueIterator::ValueIterator
; Function compile flags: /Odtp
;	COMDAT ??0ValueIterator@Json@@AAE@ABViterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_current$ = 8						; size = 4
??0ValueIterator@Json@@AAE@ABViterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@Z PROC ; Json::ValueIterator::ValueIterator, COMDAT
; _this$ = ecx

; 264  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _current$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0ValueIteratorBase@Json@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@Z ; Json::ValueIteratorBase::ValueIteratorBase

; 265  : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0ValueIterator@Json@@AAE@ABViterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@Z ENDP ; Json::ValueIterator::ValueIterator
_TEXT	ENDS
PUBLIC	??0ValueIterator@Json@@QAE@ABVValueConstIterator@1@@Z ; Json::ValueIterator::ValueIterator
; Function compile flags: /Odtp
;	COMDAT ??0ValueIterator@Json@@QAE@ABVValueConstIterator@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_other$ = 8						; size = 4
??0ValueIterator@Json@@QAE@ABVValueConstIterator@1@@Z PROC ; Json::ValueIterator::ValueIterator, COMDAT
; _this$ = ecx

; 280  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _other$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 281  : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0ValueIterator@Json@@QAE@ABVValueConstIterator@1@@Z ENDP ; Json::ValueIterator::ValueIterator
_TEXT	ENDS
PUBLIC	??0ValueIterator@Json@@QAE@ABV01@@Z		; Json::ValueIterator::ValueIterator
; Function compile flags: /Odtp
;	COMDAT ??0ValueIterator@Json@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_other$ = 8						; size = 4
??0ValueIterator@Json@@QAE@ABV01@@Z PROC		; Json::ValueIterator::ValueIterator, COMDAT
; _this$ = ecx

; 285  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _other$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 286  : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0ValueIterator@Json@@QAE@ABV01@@Z ENDP		; Json::ValueIterator::ValueIterator
_TEXT	ENDS
PUBLIC	??4ValueIterator@Json@@QAEAAV01@ABV01@@Z	; Json::ValueIterator::operator=
; Function compile flags: /Odtp
;	COMDAT ??4ValueIterator@Json@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_other$ = 8						; size = 4
??4ValueIterator@Json@@QAEAAV01@ABV01@@Z PROC		; Json::ValueIterator::operator=, COMDAT
; _this$ = ecx

; 290  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 291  :    copy( other );

	mov	eax, DWORD PTR _other$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?copy@ValueIteratorBase@Json@@IAEXABV12@@Z ; Json::ValueIteratorBase::copy

; 292  :    return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 293  : }

	mov	esp, ebp
	pop	ebp
	ret	4
??4ValueIterator@Json@@QAEAAV01@ABV01@@Z ENDP		; Json::ValueIterator::operator=
_TEXT	ENDS
PUBLIC	??0CommentInfo@Value@Json@@QAE@XZ		; Json::Value::CommentInfo::CommentInfo
; Function compile flags: /Odtp
; File d:\git_zqprojs\zqproj\generic\cdmifuse\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp
;	COMDAT ??0CommentInfo@Value@Json@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CommentInfo@Value@Json@@QAE@XZ PROC			; Json::Value::CommentInfo::CommentInfo, COMDAT
; _this$ = ecx

; 144  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 145  : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0CommentInfo@Value@Json@@QAE@XZ ENDP			; Json::Value::CommentInfo::CommentInfo
_TEXT	ENDS
PUBLIC	??1CommentInfo@Value@Json@@QAE@XZ		; Json::Value::CommentInfo::~CommentInfo
; Function compile flags: /Odtp
;	COMDAT ??1CommentInfo@Value@Json@@QAE@XZ
_TEXT	SEGMENT
tv68 = -8						; size = 4
_this$ = -4						; size = 4
??1CommentInfo@Value@Json@@QAE@XZ PROC			; Json::Value::CommentInfo::~CommentInfo, COMDAT
; _this$ = ecx

; 148  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 149  :    if ( comment_ )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN2@CommentInf

; 150  :       valueAllocator()->releaseStringValue( comment_ );

	call	?valueAllocator@Json@@YAAAPAVValueAllocator@1@XZ ; Json::valueAllocator
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv68[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR tv68[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv68[ebp]
	mov	eax, DWORD PTR [edx+16]
	call	eax
$LN2@CommentInf:

; 151  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??1CommentInfo@Value@Json@@QAE@XZ ENDP			; Json::Value::CommentInfo::~CommentInfo
_TEXT	ENDS
PUBLIC	??0DefaultValueAllocator@Json@@QAE@XZ		; Json::DefaultValueAllocator::DefaultValueAllocator
EXTRN	_atexit:PROC
;	COMDAT ?defaultAllocator@?1??valueAllocator@Json@@YAAAPAVValueAllocator@2@XZ@4VDefaultValueAllocator@2@A
_BSS	SEGMENT
?defaultAllocator@?1??valueAllocator@Json@@YAAAPAVValueAllocator@2@XZ@4VDefaultValueAllocator@2@A DD 01H DUP (?) ; `Json::valueAllocator'::`2'::defaultAllocator
_BSS	ENDS
;	COMDAT ?$S1@?1??valueAllocator@Json@@YAAAPAVValueAllocator@2@XZ@4IA
_BSS	SEGMENT
?$S1@?1??valueAllocator@Json@@YAAAPAVValueAllocator@2@XZ@4IA DD 01H DUP (?) ; `Json::valueAllocator'::`2'::$S1
_BSS	ENDS
;	COMDAT ?valueAllocator@?1??0Json@@YAAAPAVValueAllocator@1@XZ@4PAV21@A
_DATA	SEGMENT
?valueAllocator@?1??0Json@@YAAAPAVValueAllocator@1@XZ@4PAV21@A DD FLAT:?defaultAllocator@?1??valueAllocator@Json@@YAAAPAVValueAllocator@2@XZ@4VDefaultValueAllocator@2@A ; `Json::valueAllocator'::`2'::valueAllocator
; Function compile flags: /Odtp
_DATA	ENDS
;	COMDAT ?valueAllocator@Json@@YAAAPAVValueAllocator@1@XZ
_TEXT	SEGMENT
?valueAllocator@Json@@YAAAPAVValueAllocator@1@XZ PROC	; Json::valueAllocator, COMDAT

; 103  : {

	push	ebp
	mov	ebp, esp

; 104  :    static DefaultValueAllocator defaultAllocator;

	mov	eax, DWORD PTR ?$S1@?1??valueAllocator@Json@@YAAAPAVValueAllocator@2@XZ@4IA
	and	eax, 1
	jne	SHORT $LN1@valueAlloc
	mov	ecx, DWORD PTR ?$S1@?1??valueAllocator@Json@@YAAAPAVValueAllocator@2@XZ@4IA
	or	ecx, 1
	mov	DWORD PTR ?$S1@?1??valueAllocator@Json@@YAAAPAVValueAllocator@2@XZ@4IA, ecx
	mov	ecx, OFFSET ?defaultAllocator@?1??valueAllocator@Json@@YAAAPAVValueAllocator@2@XZ@4VDefaultValueAllocator@2@A
	call	??0DefaultValueAllocator@Json@@QAE@XZ
	push	OFFSET ??__FdefaultAllocator@?1??valueAllocator@Json@@YAAAPAVValueAllocator@1@XZ@YAXXZ ; `Json::valueAllocator'::`2'::`dynamic atexit destructor for 'defaultAllocator''
	call	_atexit
	add	esp, 4
$LN1@valueAlloc:

; 105  :    static ValueAllocator *valueAllocator = &defaultAllocator;
; 106  :    return valueAllocator;

	mov	eax, OFFSET ?valueAllocator@?1??0Json@@YAAAPAVValueAllocator@1@XZ@4PAV21@A

; 107  : }

	pop	ebp
	ret	0
?valueAllocator@Json@@YAAAPAVValueAllocator@1@XZ ENDP	; Json::valueAllocator
_TEXT	ENDS
PUBLIC	??_7DefaultValueAllocator@Json@@6B@		; Json::DefaultValueAllocator::`vftable'
PUBLIC	??0ValueAllocator@Json@@QAE@XZ			; Json::ValueAllocator::ValueAllocator
PUBLIC	??_R4DefaultValueAllocator@Json@@6B@		; Json::DefaultValueAllocator::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVDefaultValueAllocator@Json@@@8		; Json::DefaultValueAllocator `RTTI Type Descriptor'
PUBLIC	??_R3DefaultValueAllocator@Json@@8		; Json::DefaultValueAllocator::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2DefaultValueAllocator@Json@@8		; Json::DefaultValueAllocator::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@DefaultValueAllocator@Json@@8	; Json::DefaultValueAllocator::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?makeMemberName@DefaultValueAllocator@Json@@UAEPADPBD@Z ; Json::DefaultValueAllocator::makeMemberName
PUBLIC	?releaseMemberName@DefaultValueAllocator@Json@@UAEXPAD@Z ; Json::DefaultValueAllocator::releaseMemberName
PUBLIC	?duplicateStringValue@DefaultValueAllocator@Json@@UAEPADPBDI@Z ; Json::DefaultValueAllocator::duplicateStringValue
PUBLIC	?releaseStringValue@DefaultValueAllocator@Json@@UAEXPAD@Z ; Json::DefaultValueAllocator::releaseStringValue
EXTRN	??_EDefaultValueAllocator@Json@@UAEPAXI@Z:PROC	; Json::DefaultValueAllocator::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@DefaultValueAllocator@Json@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@DefaultValueAllocator@Json@@8 DD FLAT:??_R0?AVDefaultValueAllocator@Json@@@8 ; Json::DefaultValueAllocator::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3DefaultValueAllocator@Json@@8
rdata$r	ENDS
;	COMDAT ??_R2DefaultValueAllocator@Json@@8
rdata$r	SEGMENT
??_R2DefaultValueAllocator@Json@@8 DD FLAT:??_R1A@?0A@EA@DefaultValueAllocator@Json@@8 ; Json::DefaultValueAllocator::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@ValueAllocator@Json@@8
rdata$r	ENDS
;	COMDAT ??_R3DefaultValueAllocator@Json@@8
rdata$r	SEGMENT
??_R3DefaultValueAllocator@Json@@8 DD 00H		; Json::DefaultValueAllocator::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2DefaultValueAllocator@Json@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVDefaultValueAllocator@Json@@@8
_DATA	SEGMENT
??_R0?AVDefaultValueAllocator@Json@@@8 DD FLAT:??_7type_info@@6B@ ; Json::DefaultValueAllocator `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVDefaultValueAllocator@Json@@', 00H
_DATA	ENDS
;	COMDAT ??_R4DefaultValueAllocator@Json@@6B@
rdata$r	SEGMENT
??_R4DefaultValueAllocator@Json@@6B@ DD 00H		; Json::DefaultValueAllocator::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVDefaultValueAllocator@Json@@@8
	DD	FLAT:??_R3DefaultValueAllocator@Json@@8
rdata$r	ENDS
;	COMDAT ??_7DefaultValueAllocator@Json@@6B@
CONST	SEGMENT
??_7DefaultValueAllocator@Json@@6B@ DD FLAT:??_R4DefaultValueAllocator@Json@@6B@ ; Json::DefaultValueAllocator::`vftable'
	DD	FLAT:??_EDefaultValueAllocator@Json@@UAEPAXI@Z
	DD	FLAT:?makeMemberName@DefaultValueAllocator@Json@@UAEPADPBD@Z
	DD	FLAT:?releaseMemberName@DefaultValueAllocator@Json@@UAEXPAD@Z
	DD	FLAT:?duplicateStringValue@DefaultValueAllocator@Json@@UAEPADPBDI@Z
	DD	FLAT:?releaseStringValue@DefaultValueAllocator@Json@@UAEXPAD@Z
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ??0DefaultValueAllocator@Json@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0DefaultValueAllocator@Json@@QAE@XZ PROC		; Json::DefaultValueAllocator::DefaultValueAllocator, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0ValueAllocator@Json@@QAE@XZ
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7DefaultValueAllocator@Json@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0DefaultValueAllocator@Json@@QAE@XZ ENDP		; Json::DefaultValueAllocator::DefaultValueAllocator
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?makeMemberName@DefaultValueAllocator@Json@@UAEPADPBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_memberName$ = 8					; size = 4
?makeMemberName@DefaultValueAllocator@Json@@UAEPADPBD@Z PROC ; Json::DefaultValueAllocator::makeMemberName, COMDAT
; _this$ = ecx

; 71   :    {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 72   :       return duplicateStringValue( memberName );

	push	-1
	mov	eax, DWORD PTR _memberName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax

; 73   :    }

	mov	esp, ebp
	pop	ebp
	ret	4
?makeMemberName@DefaultValueAllocator@Json@@UAEPADPBD@Z ENDP ; Json::DefaultValueAllocator::makeMemberName
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?releaseMemberName@DefaultValueAllocator@Json@@UAEXPAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_memberName$ = 8					; size = 4
?releaseMemberName@DefaultValueAllocator@Json@@UAEXPAD@Z PROC ; Json::DefaultValueAllocator::releaseMemberName, COMDAT
; _this$ = ecx

; 76   :    {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 77   :       releaseStringValue( memberName );

	mov	eax, DWORD PTR _memberName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	call	eax

; 78   :    }

	mov	esp, ebp
	pop	ebp
	ret	4
?releaseMemberName@DefaultValueAllocator@Json@@UAEXPAD@Z ENDP ; Json::DefaultValueAllocator::releaseMemberName
_TEXT	ENDS
EXTRN	__imp__malloc:PROC
EXTRN	_memcpy:PROC
; Function compile flags: /Odtp
;	COMDAT ?duplicateStringValue@DefaultValueAllocator@Json@@UAEPADPBDI@Z
_TEXT	SEGMENT
tv66 = -24						; size = 4
tv82 = -17						; size = 1
tv79 = -16						; size = 4
tv76 = -12						; size = 4
_this$ = -8						; size = 4
_newString$ = -4					; size = 4
_value$ = 8						; size = 4
_length$ = 12						; size = 4
?duplicateStringValue@DefaultValueAllocator@Json@@UAEPADPBDI@Z PROC ; Json::DefaultValueAllocator::duplicateStringValue, COMDAT
; _this$ = ecx

; 82   :    {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 83   :       //@todo invesgate this old optimization
; 84   :       //if ( !value  ||  value[0] == 0 )
; 85   :       //   return 0;
; 86   : 
; 87   :       if ( length == unknown )

	cmp	DWORD PTR _length$[ebp], -1
	jne	SHORT $LN1@duplicateS

; 88   :          length = (unsigned int)strlen(value);

	mov	eax, DWORD PTR _value$[ebp]
	mov	DWORD PTR tv76[ebp], eax
	mov	ecx, DWORD PTR tv76[ebp]
	add	ecx, 1
	mov	DWORD PTR tv79[ebp], ecx
$LL4@duplicateS:
	mov	edx, DWORD PTR tv76[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR tv82[ebp], al
	add	DWORD PTR tv76[ebp], 1
	cmp	BYTE PTR tv82[ebp], 0
	jne	SHORT $LL4@duplicateS
	mov	ecx, DWORD PTR tv76[ebp]
	sub	ecx, DWORD PTR tv79[ebp]
	mov	DWORD PTR tv66[ebp], ecx
	mov	edx, DWORD PTR tv66[ebp]
	mov	DWORD PTR _length$[ebp], edx
$LN1@duplicateS:

; 89   :       char *newString = static_cast<char *>( malloc( length + 1 ) );

	mov	eax, DWORD PTR _length$[ebp]
	add	eax, 1
	push	eax
	call	DWORD PTR __imp__malloc
	add	esp, 4
	mov	DWORD PTR _newString$[ebp], eax

; 90   :       memcpy( newString, value, length );

	mov	ecx, DWORD PTR _length$[ebp]
	push	ecx
	mov	edx, DWORD PTR _value$[ebp]
	push	edx
	mov	eax, DWORD PTR _newString$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 91   :       newString[length] = 0;

	mov	ecx, DWORD PTR _newString$[ebp]
	add	ecx, DWORD PTR _length$[ebp]
	mov	BYTE PTR [ecx], 0

; 92   :       return newString;

	mov	eax, DWORD PTR _newString$[ebp]

; 93   :    }

	mov	esp, ebp
	pop	ebp
	ret	8
?duplicateStringValue@DefaultValueAllocator@Json@@UAEPADPBDI@Z ENDP ; Json::DefaultValueAllocator::duplicateStringValue
_TEXT	ENDS
EXTRN	__imp__free:PROC
; Function compile flags: /Odtp
;	COMDAT ?releaseStringValue@DefaultValueAllocator@Json@@UAEXPAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_value$ = 8						; size = 4
?releaseStringValue@DefaultValueAllocator@Json@@UAEXPAD@Z PROC ; Json::DefaultValueAllocator::releaseStringValue, COMDAT
; _this$ = ecx

; 96   :    {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 97   :       if ( value )

	cmp	DWORD PTR _value$[ebp], 0
	je	SHORT $LN2@releaseStr

; 98   :          free( value );

	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	call	DWORD PTR __imp__free
	add	esp, 4
$LN2@releaseStr:

; 99   :    }

	mov	esp, ebp
	pop	ebp
	ret	4
?releaseStringValue@DefaultValueAllocator@Json@@UAEXPAD@Z ENDP ; Json::DefaultValueAllocator::releaseStringValue
_TEXT	ENDS
PUBLIC	??1DefaultValueAllocator@Json@@UAE@XZ		; Json::DefaultValueAllocator::~DefaultValueAllocator
; Function compile flags: /Odtp
;	COMDAT ??_GDefaultValueAllocator@Json@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GDefaultValueAllocator@Json@@UAEPAXI@Z PROC		; Json::DefaultValueAllocator::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1DefaultValueAllocator@Json@@UAE@XZ	; Json::DefaultValueAllocator::~DefaultValueAllocator
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@2
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@2:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GDefaultValueAllocator@Json@@UAEPAXI@Z ENDP		; Json::DefaultValueAllocator::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1DefaultValueAllocator@Json@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1DefaultValueAllocator@Json@@UAE@XZ PROC		; Json::DefaultValueAllocator::~DefaultValueAllocator, COMDAT
; _this$ = ecx

; 67   :    {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7DefaultValueAllocator@Json@@6B@

; 68   :    }

	mov	ecx, DWORD PTR _this$[ebp]
	call	??1ValueAllocator@Json@@UAE@XZ		; Json::ValueAllocator::~ValueAllocator
	mov	esp, ebp
	pop	ebp
	ret	0
??1DefaultValueAllocator@Json@@UAE@XZ ENDP		; Json::DefaultValueAllocator::~DefaultValueAllocator
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0ValueAllocator@Json@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0ValueAllocator@Json@@QAE@XZ PROC			; Json::ValueAllocator::ValueAllocator, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7ValueAllocator@Json@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0ValueAllocator@Json@@QAE@XZ ENDP			; Json::ValueAllocator::ValueAllocator
_TEXT	ENDS
PUBLIC	__TI2?AVruntime_error@std@@
PUBLIC	??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::runtime_error::runtime_error
PUBLIC	??_C@_0BL@DKGNIMPN@Comments?5must?5start?5with?5?1?$AA@ ; `string'
PUBLIC	?setComment@CommentInfo@Value@Json@@QAEXPBD@Z	; Json::Value::CommentInfo::setComment
PUBLIC	??1runtime_error@std@@UAE@XZ			; std::runtime_error::~runtime_error
PUBLIC	__CTA2?AVruntime_error@std@@
PUBLIC	__CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z40
PUBLIC	??_R0?AVruntime_error@std@@@8			; std::runtime_error `RTTI Type Descriptor'
PUBLIC	??0runtime_error@std@@QAE@ABV01@@Z		; std::runtime_error::runtime_error
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
EXTRN	__imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
;	COMDAT ??_R0?AVexception@std@@@8
_DATA	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVruntime_error@std@@@8
_DATA	SEGMENT
??_R0?AVruntime_error@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::runtime_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVruntime_error@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVruntime_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0runtime_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA2?AVruntime_error@std@@
xdata$x	SEGMENT
__CTA2?AVruntime_error@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVruntime_error@std@@
xdata$x	SEGMENT
__TI2?AVruntime_error@std@@ DD 00H
	DD	FLAT:??1runtime_error@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVruntime_error@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BL@DKGNIMPN@Comments?5must?5start?5with?5?1?$AA@
CONST	SEGMENT
??_C@_0BL@DKGNIMPN@Comments?5must?5start?5with?5?1?$AA@ DB 'Comments must'
	DB	' start with /', 00H				; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?setComment@CommentInfo@Value@Json@@QAEXPBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?setComment@CommentInfo@Value@Json@@QAEXPBD@Z$0
__ehfuncinfo$?setComment@CommentInfo@Value@Json@@QAEXPBD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?setComment@CommentInfo@Value@Json@@QAEXPBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?setComment@CommentInfo@Value@Json@@QAEXPBD@Z
_TEXT	SEGMENT
tv87 = -92						; size = 4
tv68 = -88						; size = 4
_this$ = -84						; size = 4
$T30998 = -80						; size = 28
$T30997 = -52						; size = 40
__$EHRec$ = -12						; size = 12
_text$ = 8						; size = 4
?setComment@CommentInfo@Value@Json@@QAEXPBD@Z PROC	; Json::Value::CommentInfo::setComment, COMDAT
; _this$ = ecx

; 156  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?setComment@CommentInfo@Value@Json@@QAEXPBD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 80					; 00000050H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 157  :    if ( comment_ )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN2@setComment

; 158  :       valueAllocator()->releaseStringValue( comment_ );

	call	?valueAllocator@Json@@YAAAPAVValueAllocator@1@XZ ; Json::valueAllocator
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv68[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR tv68[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv68[ebp]
	mov	eax, DWORD PTR [edx+16]
	call	eax
$LN2@setComment:

; 159  :    JSON_ASSERT( text );
; 160  :    JSON_ASSERT_MESSAGE( text[0]=='\0' || text[0]=='/', "Comments must start with /");

	mov	ecx, DWORD PTR _text$[ebp]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	SHORT $LN1@setComment
	mov	eax, DWORD PTR _text$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 47					; 0000002fH
	je	SHORT $LN1@setComment
	push	OFFSET ??_C@_0BL@DKGNIMPN@Comments?5must?5start?5with?5?1?$AA@
	lea	ecx, DWORD PTR $T30998[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	edx, DWORD PTR $T30998[ebp]
	push	edx
	lea	ecx, DWORD PTR $T30997[ebp]
	call	??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::runtime_error::runtime_error
	push	OFFSET __TI2?AVruntime_error@std@@
	lea	eax, DWORD PTR $T30997[ebp]
	push	eax
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T30998[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN1@setComment:

; 161  :    // It seems that /**/ style comments are acceptable as well.
; 162  :    comment_ = valueAllocator()->duplicateStringValue( text );

	call	?valueAllocator@Json@@YAAAPAVValueAllocator@1@XZ ; Json::valueAllocator
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv87[ebp], ecx
	push	-1
	mov	edx, DWORD PTR _text$[ebp]
	push	edx
	mov	eax, DWORD PTR tv87[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv87[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax
$LN4@setComment:

; 163  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?setComment@CommentInfo@Value@Json@@QAEXPBD@Z$0:
	lea	ecx, DWORD PTR $T30998[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?setComment@CommentInfo@Value@Json@@QAEXPBD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-84]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?setComment@CommentInfo@Value@Json@@QAEXPBD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?setComment@CommentInfo@Value@Json@@QAEXPBD@Z ENDP	; Json::Value::CommentInfo::setComment
PUBLIC	??_7runtime_error@std@@6B@			; std::runtime_error::`vftable'
PUBLIC	??_R4runtime_error@std@@6B@			; std::runtime_error::`RTTI Complete Object Locator'
PUBLIC	??_R3runtime_error@std@@8			; std::runtime_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2runtime_error@std@@8			; std::runtime_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@runtime_error@std@@8		; std::runtime_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	?what@runtime_error@std@@UBEPBDXZ		; std::runtime_error::what
EXTRN	__imp_??1exception@std@@UAE@XZ:PROC
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z:PROC
EXTRN	__imp_??0exception@std@@QAE@XZ:PROC
EXTRN	??_Eruntime_error@std@@UAEPAXI@Z:PROC		; std::runtime_error::`vector deleting destructor'
;	COMDAT ??_R2exception@std@@8
; File c:\program files (x86)\microsoft visual studio 8\vc\include\stdexcept
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@runtime_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@runtime_error@std@@8 DD FLAT:??_R0?AVruntime_error@std@@@8 ; std::runtime_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3runtime_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2runtime_error@std@@8
rdata$r	SEGMENT
??_R2runtime_error@std@@8 DD FLAT:??_R1A@?0A@EA@runtime_error@std@@8 ; std::runtime_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3runtime_error@std@@8
rdata$r	SEGMENT
??_R3runtime_error@std@@8 DD 00H			; std::runtime_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2runtime_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R4runtime_error@std@@6B@
rdata$r	SEGMENT
??_R4runtime_error@std@@6B@ DD 00H			; std::runtime_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVruntime_error@std@@@8
	DD	FLAT:??_R3runtime_error@std@@8
rdata$r	ENDS
;	COMDAT ??_7runtime_error@std@@6B@
CONST	SEGMENT
??_7runtime_error@std@@6B@ DD FLAT:??_R4runtime_error@std@@6B@ ; std::runtime_error::`vftable'
	DD	FLAT:??_Eruntime_error@std@@UAEPAXI@Z
	DD	FLAT:?what@runtime_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0
__ehfuncinfo$??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Message$ = 8						; size = 4
??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::runtime_error::runtime_error, COMDAT
; _this$ = ecx

; 154  : 		{	// construct from message string

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7runtime_error@std@@6B@
	mov	ecx, DWORD PTR __Message$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z

; 155  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::runtime_error::runtime_error
; Function compile flags: /Odtp
;	COMDAT ??1runtime_error@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1runtime_error@std@@UAE@XZ PROC			; std::runtime_error::~runtime_error, COMDAT
; _this$ = ecx

; 158  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7runtime_error@std@@6B@

; 159  : 		}

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1runtime_error@std@@UAE@XZ ENDP			; std::runtime_error::~runtime_error
_TEXT	ENDS
EXTRN	__imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ:PROC
; Function compile flags: /Odtp
;	COMDAT ?what@runtime_error@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?what@runtime_error@std@@UBEPBDXZ PROC			; std::runtime_error::what, COMDAT
; _this$ = ecx

; 162  : 		{	// return pointer to message string

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 163  : 		return (_Str.c_str());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ

; 164  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?what@runtime_error@std@@UBEPBDXZ ENDP			; std::runtime_error::what
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_Gruntime_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gruntime_error@std@@UAEPAXI@Z PROC			; std::runtime_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1runtime_error@std@@UAE@XZ		; std::runtime_error::~runtime_error
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@3
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@3:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Gruntime_error@std@@UAEPAXI@Z ENDP			; std::runtime_error::`scalar deleting destructor'
_TEXT	ENDS
EXTRN	__imp_??0exception@std@@QAE@ABV01@@Z:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0runtime_error@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0runtime_error@std@@QAE@ABV01@@Z$0
__ehfuncinfo$??0runtime_error@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0runtime_error@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0runtime_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0runtime_error@std@@QAE@ABV01@@Z PROC			; std::runtime_error::runtime_error, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0runtime_error@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7runtime_error@std@@6B@
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 12					; 0000000cH
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0runtime_error@std@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0runtime_error@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0runtime_error@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0runtime_error@std@@QAE@ABV01@@Z ENDP			; std::runtime_error::runtime_error
PUBLIC	??0CZString@Value@Json@@QAE@H@Z			; Json::Value::CZString::CZString
; Function compile flags: /Odtp
; File d:\git_zqprojs\zqproj\generic\cdmifuse\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp
;	COMDAT ??0CZString@Value@Json@@QAE@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_index$ = 8						; size = 4
??0CZString@Value@Json@@QAE@H@Z PROC			; Json::Value::CZString::CZString, COMDAT
; _this$ = ecx

; 181  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _index$[ebp]
	mov	DWORD PTR [ecx+4], edx

; 182  : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0CZString@Value@Json@@QAE@H@Z ENDP			; Json::Value::CZString::CZString
_TEXT	ENDS
PUBLIC	??0CZString@Value@Json@@QAE@PBDW4DuplicationPolicy@012@@Z ; Json::Value::CZString::CZString
; Function compile flags: /Odtp
;	COMDAT ??0CZString@Value@Json@@QAE@PBDW4DuplicationPolicy@012@@Z
_TEXT	SEGMENT
tv73 = -12						; size = 4
tv68 = -8						; size = 4
_this$ = -4						; size = 4
_cstr$ = 8						; size = 4
_allocate$ = 12						; size = 4
??0CZString@Value@Json@@QAE@PBDW4DuplicationPolicy@012@@Z PROC ; Json::Value::CZString::CZString, COMDAT
; _this$ = ecx

; 188  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx
	cmp	DWORD PTR _allocate$[ebp], 1
	jne	SHORT $LN3@CZString
	call	?valueAllocator@Json@@YAAAPAVValueAllocator@1@XZ ; Json::valueAllocator
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR tv68[ebp], eax
	mov	ecx, DWORD PTR _cstr$[ebp]
	push	ecx
	mov	edx, DWORD PTR tv68[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv68[ebp]
	mov	edx, DWORD PTR [eax+4]
	call	edx
	mov	DWORD PTR tv73[ebp], eax
	jmp	SHORT $LN4@CZString
$LN3@CZString:
	mov	eax, DWORD PTR _cstr$[ebp]
	mov	DWORD PTR tv73[ebp], eax
$LN4@CZString:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR tv73[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _allocate$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 189  : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0CZString@Value@Json@@QAE@PBDW4DuplicationPolicy@012@@Z ENDP ; Json::Value::CZString::CZString
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0CZString@Value@Json@@QAE@ABV012@@Z
_TEXT	SEGMENT
tv82 = -16						; size = 4
tv75 = -12						; size = 4
tv70 = -8						; size = 4
_this$ = -4						; size = 4
_other$ = 8						; size = 4
??0CZString@Value@Json@@QAE@ABV012@@Z PROC		; Json::Value::CZString::CZString, COMDAT
; _this$ = ecx

; 197  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _other$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN3@CZString@2
	mov	ecx, DWORD PTR _other$[ebp]
	cmp	DWORD PTR [ecx], 0
	je	SHORT $LN3@CZString@2
	call	?valueAllocator@Json@@YAAAPAVValueAllocator@1@XZ ; Json::valueAllocator
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR tv70[ebp], edx
	mov	eax, DWORD PTR _other$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR tv70[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv70[ebp]
	mov	edx, DWORD PTR [eax+4]
	call	edx
	mov	DWORD PTR tv75[ebp], eax
	jmp	SHORT $LN4@CZString@2
$LN3@CZString@2:
	mov	eax, DWORD PTR _other$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv75[ebp], ecx
$LN4@CZString@2:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR tv75[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR _other$[ebp]
	cmp	DWORD PTR [ecx], 0
	je	SHORT $LN5@CZString@2
	mov	edx, DWORD PTR _other$[ebp]
	xor	eax, eax
	cmp	DWORD PTR [edx+4], 0
	setne	al
	mov	DWORD PTR tv82[ebp], eax
	jmp	SHORT $LN6@CZString@2
$LN5@CZString@2:
	mov	ecx, DWORD PTR _other$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv82[ebp], edx
$LN6@CZString@2:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR tv82[ebp]
	mov	DWORD PTR [eax+4], ecx

; 198  : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0CZString@Value@Json@@QAE@ABV012@@Z ENDP		; Json::Value::CZString::CZString
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1CZString@Value@Json@@QAE@XZ
_TEXT	SEGMENT
tv70 = -8						; size = 4
_this$ = -4						; size = 4
??1CZString@Value@Json@@QAE@XZ PROC			; Json::Value::CZString::~CZString, COMDAT
; _this$ = ecx

; 201  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 202  :    if ( cstr_  &&  index_ == duplicate )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN2@CZString@3
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+4], 1
	jne	SHORT $LN2@CZString@3

; 203  :       valueAllocator()->releaseMemberName( const_cast<char *>( cstr_ ) );

	call	?valueAllocator@Json@@YAAAPAVValueAllocator@1@XZ ; Json::valueAllocator
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR tv70[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR tv70[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv70[ebp]
	mov	edx, DWORD PTR [eax+8]
	call	edx
$LN2@CZString@3:

; 204  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??1CZString@Value@Json@@QAE@XZ ENDP			; Json::Value::CZString::~CZString
_TEXT	ENDS
PUBLIC	??$swap@H@std@@YAXAAH0@Z			; std::swap<int>
PUBLIC	??$swap@PBD@std@@YAXAAPBD0@Z			; std::swap<char const *>
PUBLIC	?swap@CZString@Value@Json@@AAEXAAV123@@Z	; Json::Value::CZString::swap
; Function compile flags: /Odtp
;	COMDAT ?swap@CZString@Value@Json@@AAEXAAV123@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_other$ = 8						; size = 4
?swap@CZString@Value@Json@@AAEXAAV123@@Z PROC		; Json::Value::CZString::swap, COMDAT
; _this$ = ecx

; 208  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 209  :    std::swap( cstr_, other.cstr_ );

	mov	eax, DWORD PTR _other$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??$swap@PBD@std@@YAXAAPBD0@Z		; std::swap<char const *>
	add	esp, 8

; 210  :    std::swap( index_, other.index_ );

	mov	edx, DWORD PTR _other$[ebp]
	add	edx, 4
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	push	eax
	call	??$swap@H@std@@YAXAAH0@Z		; std::swap<int>
	add	esp, 8

; 211  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?swap@CZString@Value@Json@@AAEXAAV123@@Z ENDP		; Json::Value::CZString::swap
_TEXT	ENDS
PUBLIC	??4CZString@Value@Json@@QAEAAV012@ABV012@@Z	; Json::Value::CZString::operator=
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??4CZString@Value@Json@@QAEAAV012@ABV012@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??4CZString@Value@Json@@QAEAAV012@ABV012@@Z$0
__ehfuncinfo$??4CZString@Value@Json@@QAEAAV012@ABV012@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??4CZString@Value@Json@@QAEAAV012@ABV012@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??4CZString@Value@Json@@QAEAAV012@ABV012@@Z
_TEXT	SEGMENT
_this$ = -28						; size = 4
$T31051 = -24						; size = 4
_temp$ = -20						; size = 8
__$EHRec$ = -12						; size = 12
_other$ = 8						; size = 4
??4CZString@Value@Json@@QAEAAV012@ABV012@@Z PROC	; Json::Value::CZString::operator=, COMDAT
; _this$ = ecx

; 215  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??4CZString@Value@Json@@QAEAAV012@ABV012@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 216  :    CZString temp( other );

	mov	eax, DWORD PTR _other$[ebp]
	push	eax
	lea	ecx, DWORD PTR _temp$[ebp]
	call	??0CZString@Value@Json@@QAE@ABV012@@Z	; Json::Value::CZString::CZString
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 217  :    swap( temp );

	lea	ecx, DWORD PTR _temp$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?swap@CZString@Value@Json@@AAEXAAV123@@Z ; Json::Value::CZString::swap

; 218  :    return *this;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR $T31051[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _temp$[ebp]
	call	??1CZString@Value@Json@@QAE@XZ		; Json::Value::CZString::~CZString
	mov	eax, DWORD PTR $T31051[ebp]

; 219  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??4CZString@Value@Json@@QAEAAV012@ABV012@@Z$0:
	lea	ecx, DWORD PTR _temp$[ebp]
	jmp	??1CZString@Value@Json@@QAE@XZ		; Json::Value::CZString::~CZString
__ehhandler$??4CZString@Value@Json@@QAEAAV012@ABV012@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??4CZString@Value@Json@@QAEAAV012@ABV012@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??4CZString@Value@Json@@QAEAAV012@ABV012@@Z ENDP	; Json::Value::CZString::operator=
PUBLIC	??MCZString@Value@Json@@QBE_NABV012@@Z		; Json::Value::CZString::operator<
; Function compile flags: /Odtp
;	COMDAT ??MCZString@Value@Json@@QBE_NABV012@@Z
_TEXT	SEGMENT
tv66 = -24						; size = 4
tv130 = -20						; size = 4
tv93 = -14						; size = 1
tv86 = -13						; size = 1
tv80 = -12						; size = 4
tv82 = -8						; size = 4
_this$ = -4						; size = 4
_other$ = 8						; size = 4
??MCZString@Value@Json@@QBE_NABV012@@Z PROC		; Json::Value::CZString::operator<, COMDAT
; _this$ = ecx

; 223  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 224  :    if ( cstr_ )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN1@operator

; 225  :       return strcmp( cstr_, other.cstr_ ) < 0;

	mov	ecx, DWORD PTR _other$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR tv82[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv80[ebp], ecx
$LL4@operator:
	mov	edx, DWORD PTR tv80[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR tv86[ebp], al
	mov	ecx, DWORD PTR tv82[ebp]
	cmp	al, BYTE PTR [ecx]
	jne	SHORT $LN5@operator
	cmp	BYTE PTR tv86[ebp], 0
	je	SHORT $LN6@operator
	mov	edx, DWORD PTR tv80[ebp]
	mov	al, BYTE PTR [edx+1]
	mov	BYTE PTR tv93[ebp], al
	mov	ecx, DWORD PTR tv82[ebp]
	cmp	al, BYTE PTR [ecx+1]
	jne	SHORT $LN5@operator
	add	DWORD PTR tv80[ebp], 2
	add	DWORD PTR tv82[ebp], 2
	cmp	BYTE PTR tv93[ebp], 0
	jne	SHORT $LL4@operator
$LN6@operator:
	mov	DWORD PTR tv130[ebp], 0
	jmp	SHORT $LN7@operator
$LN5@operator:
	sbb	edx, edx
	sbb	edx, -1
	mov	DWORD PTR tv130[ebp], edx
$LN7@operator:
	mov	eax, DWORD PTR tv130[ebp]
	mov	DWORD PTR tv66[ebp], eax
	xor	eax, eax
	cmp	DWORD PTR tv66[ebp], 0
	setl	al
	jmp	SHORT $LN2@operator
$LN1@operator:

; 226  :    return index_ < other.index_;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _other$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx+4]
	setl	cl
	mov	al, cl
$LN2@operator:

; 227  : }

	mov	esp, ebp
	pop	ebp
	ret	4
??MCZString@Value@Json@@QBE_NABV012@@Z ENDP		; Json::Value::CZString::operator<
_TEXT	ENDS
PUBLIC	??8CZString@Value@Json@@QBE_NABV012@@Z		; Json::Value::CZString::operator==
; Function compile flags: /Odtp
;	COMDAT ??8CZString@Value@Json@@QBE_NABV012@@Z
_TEXT	SEGMENT
tv66 = -24						; size = 4
tv130 = -20						; size = 4
tv93 = -14						; size = 1
tv86 = -13						; size = 1
tv80 = -12						; size = 4
tv82 = -8						; size = 4
_this$ = -4						; size = 4
_other$ = 8						; size = 4
??8CZString@Value@Json@@QBE_NABV012@@Z PROC		; Json::Value::CZString::operator==, COMDAT
; _this$ = ecx

; 231  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 232  :    if ( cstr_ )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN1@operator@2

; 233  :       return strcmp( cstr_, other.cstr_ ) == 0;

	mov	ecx, DWORD PTR _other$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR tv82[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv80[ebp], ecx
$LL4@operator@2:
	mov	edx, DWORD PTR tv80[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR tv86[ebp], al
	mov	ecx, DWORD PTR tv82[ebp]
	cmp	al, BYTE PTR [ecx]
	jne	SHORT $LN5@operator@2
	cmp	BYTE PTR tv86[ebp], 0
	je	SHORT $LN6@operator@2
	mov	edx, DWORD PTR tv80[ebp]
	mov	al, BYTE PTR [edx+1]
	mov	BYTE PTR tv93[ebp], al
	mov	ecx, DWORD PTR tv82[ebp]
	cmp	al, BYTE PTR [ecx+1]
	jne	SHORT $LN5@operator@2
	add	DWORD PTR tv80[ebp], 2
	add	DWORD PTR tv82[ebp], 2
	cmp	BYTE PTR tv93[ebp], 0
	jne	SHORT $LL4@operator@2
$LN6@operator@2:
	mov	DWORD PTR tv130[ebp], 0
	jmp	SHORT $LN7@operator@2
$LN5@operator@2:
	sbb	edx, edx
	sbb	edx, -1
	mov	DWORD PTR tv130[ebp], edx
$LN7@operator@2:
	mov	eax, DWORD PTR tv130[ebp]
	mov	DWORD PTR tv66[ebp], eax
	xor	eax, eax
	cmp	DWORD PTR tv66[ebp], 0
	sete	al
	jmp	SHORT $LN2@operator@2
$LN1@operator@2:

; 234  :    return index_ == other.index_;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _other$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx+4]
	sete	cl
	mov	al, cl
$LN2@operator@2:

; 235  : }

	mov	esp, ebp
	pop	ebp
	ret	4
??8CZString@Value@Json@@QBE_NABV012@@Z ENDP		; Json::Value::CZString::operator==
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?index@CZString@Value@Json@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?index@CZString@Value@Json@@QBEHXZ PROC			; Json::Value::CZString::index, COMDAT
; _this$ = ecx

; 240  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 241  :    return index_;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 242  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?index@CZString@Value@Json@@QBEHXZ ENDP			; Json::Value::CZString::index
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?c_str@CZString@Value@Json@@QBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?c_str@CZString@Value@Json@@QBEPBDXZ PROC		; Json::Value::CZString::c_str, COMDAT
; _this$ = ecx

; 247  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 248  :    return cstr_;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 249  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?c_str@CZString@Value@Json@@QBEPBDXZ ENDP		; Json::Value::CZString::c_str
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?isStaticString@CZString@Value@Json@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?isStaticString@CZString@Value@Json@@QBE_NXZ PROC	; Json::Value::CZString::isStaticString, COMDAT
; _this$ = ecx

; 253  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 254  :    return index_ == noDuplication;

	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR [eax+4], 0
	sete	cl
	mov	al, cl

; 255  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?isStaticString@CZString@Value@Json@@QBE_NXZ ENDP	; Json::Value::CZString::isStaticString
_TEXT	ENDS
PUBLIC	??0?$map@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@@std@@QAE@XZ ; std::map<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > >::map<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > >
PUBLIC	__real@0000000000000000
PUBLIC	??0Value@Json@@QAE@W4ValueType@1@@Z		; Json::Value::Value
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	__fltused:DWORD
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0Value@Json@@QAE@W4ValueType@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0Value@Json@@QAE@W4ValueType@1@@Z$0
__ehfuncinfo$??0Value@Json@@QAE@W4ValueType@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0Value@Json@@QAE@W4ValueType@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0Value@Json@@QAE@W4ValueType@1@@Z
_TEXT	SEGMENT
tv81 = -32						; size = 4
tv73 = -28						; size = 4
_this$ = -24						; size = 4
$T31080 = -20						; size = 4
$T31079 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_type$ = 8						; size = 4
??0Value@Json@@QAE@W4ValueType@1@@Z PROC		; Json::Value::Value, COMDAT
; _this$ = ecx

; 279  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0Value@Json@@QAE@W4ValueType@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _type$[ebp]
	and	eax, 255				; 000000ffH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	and	edx, -256				; ffffff00H
	or	edx, eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], edx
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	and	edx, -257				; fffffeffH
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], edx
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0

; 280  :    switch ( type )

	mov	edx, DWORD PTR _type$[ebp]
	mov	DWORD PTR tv73[ebp], edx
	mov	eax, DWORD PTR tv73[ebp]
	sub	eax, 1
	mov	DWORD PTR tv73[ebp], eax
	cmp	DWORD PTR tv73[ebp], 6
	ja	SHORT $LN1@Value
	mov	ecx, DWORD PTR tv73[ebp]
	jmp	DWORD PTR $LN16@Value[ecx*4]

; 281  :    {
; 282  :    case nullValue:
; 283  :       break;

	jmp	SHORT $LN8@Value
$LN6@Value:

; 284  :    case intValue:
; 285  :    case uintValue:
; 286  :       value_.int_ = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], 0
	mov	DWORD PTR [edx+4], 0

; 287  :       break;

	jmp	SHORT $LN8@Value
$LN5@Value:

; 288  :    case realValue:
; 289  :       value_.real_ = 0.0;

	mov	eax, DWORD PTR _this$[ebp]
	fldz
	fstp	QWORD PTR [eax]

; 290  :       break;

	jmp	SHORT $LN8@Value
$LN4@Value:

; 291  :    case stringValue:
; 292  :       value_.string_ = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], 0

; 293  :       break;

	jmp	SHORT $LN8@Value
$LN3@Value:

; 294  : #ifndef JSON_VALUE_USE_INTERNAL_MAP
; 295  :    case arrayValue:
; 296  :    case objectValue:
; 297  :       value_.map_ = new ObjectValues();

	push	12					; 0000000cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T31080[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T31080[ebp], 0
	je	SHORT $LN12@Value
	mov	ecx, DWORD PTR $T31080[ebp]
	call	??0?$map@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@@std@@QAE@XZ ; std::map<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > >::map<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > >
	mov	DWORD PTR tv81[ebp], eax
	jmp	SHORT $LN13@Value
$LN12@Value:
	mov	DWORD PTR tv81[ebp], 0
$LN13@Value:
	mov	edx, DWORD PTR tv81[ebp]
	mov	DWORD PTR $T31079[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T31079[ebp]
	mov	DWORD PTR [eax], ecx

; 298  :       break;

	jmp	SHORT $LN8@Value
$LN2@Value:

; 299  : #else
; 300  :    case arrayValue:
; 301  :       value_.array_ = arrayAllocator()->newArray();
; 302  :       break;
; 303  :    case objectValue:
; 304  :       value_.map_ = mapAllocator()->newMap();
; 305  :       break;
; 306  : #endif
; 307  :    case booleanValue:
; 308  :       value_.bool_ = false;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx], 0
$LN1@Value:
$LN8@Value:

; 309  :       break;
; 310  :    default:
; 311  :       JSON_ASSERT_UNREACHABLE;
; 312  :    }
; 313  : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	2
$LN16@Value:
	DD	$LN6@Value
	DD	$LN6@Value
	DD	$LN5@Value
	DD	$LN4@Value
	DD	$LN2@Value
	DD	$LN3@Value
	DD	$LN3@Value
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0Value@Json@@QAE@W4ValueType@1@@Z$0:
	mov	eax, DWORD PTR $T31080[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$??0Value@Json@@QAE@W4ValueType@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0Value@Json@@QAE@W4ValueType@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0Value@Json@@QAE@W4ValueType@1@@Z ENDP		; Json::Value::Value
; Function compile flags: /Odtp
;	COMDAT ??0Value@Json@@QAE@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_value$ = 8						; size = 4
??0Value@Json@@QAE@H@Z PROC				; Json::Value::Value, COMDAT
; _this$ = ecx

; 322  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, -256				; ffffff00H
	or	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0

; 323  :    value_.int_ = value;

	mov	eax, DWORD PTR _value$[ebp]
	cdq
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [ecx+4], edx

; 324  : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0Value@Json@@QAE@H@Z ENDP				; Json::Value::Value
_TEXT	ENDS
PUBLIC	??0Value@Json@@QAE@I@Z				; Json::Value::Value
; Function compile flags: /Odtp
;	COMDAT ??0Value@Json@@QAE@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_value$ = 8						; size = 4
??0Value@Json@@QAE@I@Z PROC				; Json::Value::Value, COMDAT
; _this$ = ecx

; 333  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, -256				; ffffff00H
	or	ecx, 2
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0

; 334  :    value_.uint_ = value;

	mov	ecx, DWORD PTR _value$[ebp]
	xor	edx, edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx

; 335  : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0Value@Json@@QAE@I@Z ENDP				; Json::Value::Value
_TEXT	ENDS
PUBLIC	??0Value@Json@@QAE@_J@Z				; Json::Value::Value
; Function compile flags: /Odtp
;	COMDAT ??0Value@Json@@QAE@_J@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_value$ = 8						; size = 8
??0Value@Json@@QAE@_J@Z PROC				; Json::Value::Value, COMDAT
; _this$ = ecx

; 343  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, -256				; ffffff00H
	or	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0

; 344  : 	value_.uint_ = value;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _value$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR _value$[ebp+4]
	mov	DWORD PTR [ecx+4], eax

; 345  : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0Value@Json@@QAE@_J@Z ENDP				; Json::Value::Value
_TEXT	ENDS
PUBLIC	??0Value@Json@@QAE@_K@Z				; Json::Value::Value
; Function compile flags: /Odtp
;	COMDAT ??0Value@Json@@QAE@_K@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_value$ = 8						; size = 8
??0Value@Json@@QAE@_K@Z PROC				; Json::Value::Value, COMDAT
; _this$ = ecx

; 353  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, -256				; ffffff00H
	or	ecx, 2
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0

; 354  : 	value_.uint_ = value;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _value$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR _value$[ebp+4]
	mov	DWORD PTR [ecx+4], eax

; 355  : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0Value@Json@@QAE@_K@Z ENDP				; Json::Value::Value
_TEXT	ENDS
PUBLIC	??0Value@Json@@QAE@N@Z				; Json::Value::Value
; Function compile flags: /Odtp
;	COMDAT ??0Value@Json@@QAE@N@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_value$ = 8						; size = 8
??0Value@Json@@QAE@N@Z PROC				; Json::Value::Value, COMDAT
; _this$ = ecx

; 363  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, -256				; ffffff00H
	or	ecx, 3
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0

; 364  :    value_.real_ = value;

	mov	ecx, DWORD PTR _this$[ebp]
	fld	QWORD PTR _value$[ebp]
	fstp	QWORD PTR [ecx]

; 365  : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0Value@Json@@QAE@N@Z ENDP				; Json::Value::Value
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0Value@Json@@QAE@PBD@Z
_TEXT	SEGMENT
tv75 = -8						; size = 4
_this$ = -4						; size = 4
_value$ = 8						; size = 4
??0Value@Json@@QAE@PBD@Z PROC				; Json::Value::Value, COMDAT
; _this$ = ecx

; 374  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, -256				; ffffff00H
	or	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	or	ecx, 256				; 00000100H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0

; 375  :    value_.string_ = valueAllocator()->duplicateStringValue( value );

	call	?valueAllocator@Json@@YAAAPAVValueAllocator@1@XZ ; Json::valueAllocator
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv75[ebp], ecx
	push	-1
	mov	edx, DWORD PTR _value$[ebp]
	push	edx
	mov	eax, DWORD PTR tv75[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv75[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 376  : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0Value@Json@@QAE@PBD@Z ENDP				; Json::Value::Value
_TEXT	ENDS
PUBLIC	??0Value@Json@@QAE@PBD0@Z			; Json::Value::Value
; Function compile flags: /Odtp
;	COMDAT ??0Value@Json@@QAE@PBD0@Z
_TEXT	SEGMENT
tv75 = -8						; size = 4
_this$ = -4						; size = 4
_beginValue$ = 8					; size = 4
_endValue$ = 12						; size = 4
??0Value@Json@@QAE@PBD0@Z PROC				; Json::Value::Value, COMDAT
; _this$ = ecx

; 387  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, -256				; ffffff00H
	or	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	or	ecx, 256				; 00000100H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0

; 388  :    value_.string_ = valueAllocator()->duplicateStringValue( beginValue, 
; 389  :                                                             UInt(endValue - beginValue) );

	call	?valueAllocator@Json@@YAAAPAVValueAllocator@1@XZ ; Json::valueAllocator
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv75[ebp], ecx
	mov	edx, DWORD PTR _endValue$[ebp]
	sub	edx, DWORD PTR _beginValue$[ebp]
	push	edx
	mov	eax, DWORD PTR _beginValue$[ebp]
	push	eax
	mov	ecx, DWORD PTR tv75[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv75[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 390  : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0Value@Json@@QAE@PBD0@Z ENDP				; Json::Value::Value
_TEXT	ENDS
PUBLIC	??0Value@Json@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::Value::Value
EXTRN	__imp_?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ:PROC
; Function compile flags: /Odtp
;	COMDAT ??0Value@Json@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
tv75 = -8						; size = 4
_this$ = -4						; size = 4
_value$ = 8						; size = 4
??0Value@Json@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; Json::Value::Value, COMDAT
; _this$ = ecx

; 400  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, -256				; ffffff00H
	or	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	or	ecx, 256				; 00000100H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0

; 401  :    value_.string_ = valueAllocator()->duplicateStringValue( value.c_str(), 
; 402  :                                                             (unsigned int)value.length() );

	call	?valueAllocator@Json@@YAAAPAVValueAllocator@1@XZ ; Json::valueAllocator
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv75[ebp], ecx
	mov	ecx, DWORD PTR _value$[ebp]
	call	DWORD PTR __imp_?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
	push	eax
	mov	ecx, DWORD PTR _value$[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	mov	edx, DWORD PTR tv75[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv75[ebp]
	mov	edx, DWORD PTR [eax+12]
	call	edx
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 403  : 
; 404  : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0Value@Json@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; Json::Value::Value
_TEXT	ENDS
PUBLIC	?c_str@StaticString@Json@@QBEPBDXZ		; Json::StaticString::c_str
; Function compile flags: /Odtp
;	COMDAT ??0Value@Json@@QAE@ABVStaticString@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_value$ = 8						; size = 4
??0Value@Json@@QAE@ABVStaticString@1@@Z PROC		; Json::Value::Value, COMDAT
; _this$ = ecx

; 413  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, -256				; ffffff00H
	or	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, -257				; fffffeffH
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0

; 414  :    value_.string_ = const_cast<char *>( value.c_str() );

	mov	ecx, DWORD PTR _value$[ebp]
	call	?c_str@StaticString@Json@@QBEPBDXZ	; Json::StaticString::c_str
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 415  : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0Value@Json@@QAE@ABVStaticString@1@@Z ENDP		; Json::Value::Value
; Function compile flags: /Odtp
; File d:\git_zqprojs\zqproj\generic\cdmifuse\jsoncpp-src-0.5.0\include\json\value.h
_TEXT	ENDS
;	COMDAT ?c_str@StaticString@Json@@QBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?c_str@StaticString@Json@@QBEPBDXZ PROC			; Json::StaticString::c_str, COMDAT
; _this$ = ecx

; 76   :       {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 77   :          return str_;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 78   :       }

	mov	esp, ebp
	pop	ebp
	ret	0
?c_str@StaticString@Json@@QBEPBDXZ ENDP			; Json::StaticString::c_str
_TEXT	ENDS
PUBLIC	??0Value@Json@@QAE@_N@Z				; Json::Value::Value
; Function compile flags: /Odtp
; File d:\git_zqprojs\zqproj\generic\cdmifuse\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp
;	COMDAT ??0Value@Json@@QAE@_N@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_value$ = 8						; size = 1
??0Value@Json@@QAE@_N@Z PROC				; Json::Value::Value, COMDAT
; _this$ = ecx

; 437  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, -256				; ffffff00H
	or	ecx, 5
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0

; 438  :    value_.bool_ = value;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR _value$[ebp]
	mov	BYTE PTR [ecx], dl

; 439  : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0Value@Json@@QAE@_N@Z ENDP				; Json::Value::Value
_TEXT	ENDS
PUBLIC	??0?$map@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@@std@@QAE@ABV01@@Z ; std::map<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > >::map<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > >
PUBLIC	??0Value@Json@@QAE@ABV01@@Z			; Json::Value::Value
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
EXTRN	??_L@YGXPAXIHP6EX0@Z1@Z:PROC			; `eh vector constructor iterator'
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0Value@Json@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0Value@Json@@QAE@ABV01@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??0Value@Json@@QAE@ABV01@@Z$1
__ehfuncinfo$??0Value@Json@@QAE@ABV01@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0Value@Json@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0Value@Json@@QAE@ABV01@@Z
_TEXT	SEGMENT
tv147 = -56						; size = 4
tv131 = -52						; size = 4
tv82 = -48						; size = 4
tv76 = -44						; size = 4
_this$ = -40						; size = 4
$T31123 = -36						; size = 4
$T31122 = -32						; size = 4
$T31119 = -28						; size = 4
$T31118 = -24						; size = 4
_otherComment$21182 = -20				; size = 4
_comment$21178 = -16					; size = 4
__$EHRec$ = -12						; size = 12
_other$ = 8						; size = 4
??0Value@Json@@QAE@ABV01@@Z PROC			; Json::Value::Value, COMDAT
; _this$ = ecx

; 448  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0Value@Json@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 44					; 0000002cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _other$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	shl	ecx, 24					; 00000018H
	sar	ecx, 24					; 00000018H
	and	ecx, 255				; 000000ffH
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	and	eax, -256				; ffffff00H
	or	eax, ecx
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], 0

; 449  :    switch ( type_ )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	shl	ecx, 24					; 00000018H
	sar	ecx, 24					; 00000018H
	mov	DWORD PTR tv76[ebp], ecx
	cmp	DWORD PTR tv76[ebp], 7
	ja	$LN12@Value@2
	mov	edx, DWORD PTR tv76[ebp]
	jmp	DWORD PTR $LN23@Value@2[edx*4]
$LN11@Value@2:

; 450  :    {
; 451  :    case nullValue:
; 452  :    case intValue:
; 453  :    case uintValue:
; 454  :    case realValue:
; 455  :    case booleanValue:
; 456  :       value_ = other.value_;

	mov	eax, DWORD PTR _other$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx

; 457  :       break;

	jmp	$LN12@Value@2
$LN10@Value@2:

; 458  :    case stringValue:
; 459  :       if ( other.value_.string_ )

	mov	ecx, DWORD PTR _other$[ebp]
	cmp	DWORD PTR [ecx], 0
	je	SHORT $LN9@Value@2

; 460  :       {
; 461  :          value_.string_ = valueAllocator()->duplicateStringValue( other.value_.string_ );

	call	?valueAllocator@Json@@YAAAPAVValueAllocator@1@XZ ; Json::valueAllocator
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR tv82[ebp], edx
	push	-1
	mov	eax, DWORD PTR _other$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR tv82[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv82[ebp]
	mov	edx, DWORD PTR [eax+12]
	call	edx
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 462  :          allocated_ = true;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	or	eax, 256				; 00000100H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 463  :       }
; 464  :       else

	jmp	SHORT $LN8@Value@2
$LN9@Value@2:

; 465  :          value_.string_ = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], 0
$LN8@Value@2:

; 466  :       break;

	jmp	SHORT $LN12@Value@2
$LN7@Value@2:

; 467  : #ifndef JSON_VALUE_USE_INTERNAL_MAP
; 468  :    case arrayValue:
; 469  :    case objectValue:
; 470  :       value_.map_ = new ObjectValues( *other.value_.map_ );

	push	12					; 0000000cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T31119[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T31119[ebp], 0
	je	SHORT $LN16@Value@2
	mov	eax, DWORD PTR _other$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR $T31119[ebp]
	call	??0?$map@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@@std@@QAE@ABV01@@Z
	mov	DWORD PTR tv131[ebp], eax
	jmp	SHORT $LN17@Value@2
$LN16@Value@2:
	mov	DWORD PTR tv131[ebp], 0
$LN17@Value@2:
	mov	edx, DWORD PTR tv131[ebp]
	mov	DWORD PTR $T31118[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T31118[ebp]
	mov	DWORD PTR [eax], ecx
$LN12@Value@2:

; 471  :       break;
; 472  : #else
; 473  :    case arrayValue:
; 474  :       value_.array_ = arrayAllocator()->newArrayCopy( *other.value_.array_ );
; 475  :       break;
; 476  :    case objectValue:
; 477  :       value_.map_ = mapAllocator()->newMapCopy( *other.value_.map_ );
; 478  :       break;
; 479  : #endif
; 480  :    default:
; 481  :       JSON_ASSERT_UNREACHABLE;
; 482  :    }
; 483  :    if ( other.comments_ )

	mov	edx, DWORD PTR _other$[ebp]
	cmp	DWORD PTR [edx+12], 0
	je	$LN14@Value@2

; 484  :    {
; 485  :       comments_ = new CommentInfo[numberOfCommentPlacement];

	push	16					; 00000010H
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T31123[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T31123[ebp], 0
	je	SHORT $LN18@Value@2
	mov	eax, DWORD PTR $T31123[ebp]
	mov	DWORD PTR [eax], 3
	push	OFFSET ??1CommentInfo@Value@Json@@QAE@XZ ; Json::Value::CommentInfo::~CommentInfo
	push	OFFSET ??0CommentInfo@Value@Json@@QAE@XZ ; Json::Value::CommentInfo::CommentInfo
	push	3
	push	4
	mov	ecx, DWORD PTR $T31123[ebp]
	add	ecx, 4
	push	ecx
	call	??_L@YGXPAXIHP6EX0@Z1@Z
	mov	edx, DWORD PTR $T31123[ebp]
	add	edx, 4
	mov	DWORD PTR tv147[ebp], edx
	jmp	SHORT $LN19@Value@2
$LN18@Value@2:
	mov	DWORD PTR tv147[ebp], 0
$LN19@Value@2:
	mov	eax, DWORD PTR tv147[ebp]
	mov	DWORD PTR $T31122[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T31122[ebp]
	mov	DWORD PTR [ecx+12], edx

; 486  :       for ( int comment =0; comment < numberOfCommentPlacement; ++comment )

	mov	DWORD PTR _comment$21178[ebp], 0
	jmp	SHORT $LN4@Value@2
$LN3@Value@2:
	mov	eax, DWORD PTR _comment$21178[ebp]
	add	eax, 1
	mov	DWORD PTR _comment$21178[ebp], eax
$LN4@Value@2:
	cmp	DWORD PTR _comment$21178[ebp], 3
	jge	SHORT $LN14@Value@2

; 487  :       {
; 488  :          const CommentInfo &otherComment = other.comments_[comment];

	mov	ecx, DWORD PTR _other$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	eax, DWORD PTR _comment$21178[ebp]
	lea	ecx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR _otherComment$21182[ebp], ecx

; 489  :          if ( otherComment.comment_ )

	mov	edx, DWORD PTR _otherComment$21182[ebp]
	cmp	DWORD PTR [edx], 0
	je	SHORT $LN1@Value@2

; 490  :             comments_[comment].setComment( otherComment.comment_ );

	mov	eax, DWORD PTR _otherComment$21182[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR _comment$21178[ebp]
	lea	ecx, DWORD PTR [eax+ecx*4]
	call	?setComment@CommentInfo@Value@Json@@QAEXPBD@Z ; Json::Value::CommentInfo::setComment
$LN1@Value@2:

; 491  :       }

	jmp	SHORT $LN3@Value@2
$LN14@Value@2:

; 492  :    }
; 493  : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
$LN23@Value@2:
	DD	$LN11@Value@2
	DD	$LN11@Value@2
	DD	$LN11@Value@2
	DD	$LN11@Value@2
	DD	$LN10@Value@2
	DD	$LN11@Value@2
	DD	$LN7@Value@2
	DD	$LN7@Value@2
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0Value@Json@@QAE@ABV01@@Z$0:
	mov	eax, DWORD PTR $T31119[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$??0Value@Json@@QAE@ABV01@@Z$1:
	mov	eax, DWORD PTR $T31123[ebp]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	pop	ecx
	ret	0
__ehhandler$??0Value@Json@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-48]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0Value@Json@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0Value@Json@@QAE@ABV01@@Z ENDP			; Json::Value::Value
PUBLIC	??0?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE@ABV01@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >
; Function compile flags: /Odtp
;	COMDAT ??0?$map@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0?$map@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@@std@@QAE@ABV01@@Z PROC ; std::map<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > >::map<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE@ABV01@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$map@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@@std@@QAE@ABV01@@Z ENDP ; std::map<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > >::map<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > >
_TEXT	ENDS
PUBLIC	??_ECommentInfo@Value@Json@@QAEPAXI@Z		; Json::Value::CommentInfo::`vector deleting destructor'
EXTRN	??_M@YGXPAXIHP6EX0@Z@Z:PROC			; `eh vector destructor iterator'
; Function compile flags: /Odtp
;	COMDAT ??_ECommentInfo@Value@Json@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_ECommentInfo@Value@Json@@QAEPAXI@Z PROC		; Json::Value::CommentInfo::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 2
	je	SHORT $LN3@vector
	push	OFFSET ??1CommentInfo@Value@Json@@QAE@XZ ; Json::Value::CommentInfo::~CommentInfo
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx-4]
	push	edx
	push	4
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN2@vector
	mov	edx, DWORD PTR _this$[ebp]
	sub	edx, 4
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN2@vector:
	mov	eax, DWORD PTR _this$[ebp]
	sub	eax, 4
	jmp	SHORT $LN4@vector
$LN3@vector:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CommentInfo@Value@Json@@QAE@XZ	; Json::Value::CommentInfo::~CommentInfo
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@vector
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@vector:
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector:
	mov	esp, ebp
	pop	ebp
	ret	4
??_ECommentInfo@Value@Json@@QAEPAXI@Z ENDP		; Json::Value::CommentInfo::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	??_G?$map@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@@std@@QAEPAXI@Z ; std::map<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > >::`scalar deleting destructor'
; Function compile flags: /Odtp
;	COMDAT ??1Value@Json@@QAE@XZ
_TEXT	SEGMENT
tv94 = -36						; size = 4
tv83 = -32						; size = 4
tv75 = -28						; size = 4
tv67 = -24						; size = 4
_this$ = -20						; size = 4
$T31147 = -16						; size = 4
$T31146 = -12						; size = 4
$T31143 = -8						; size = 4
$T31142 = -4						; size = 4
??1Value@Json@@QAE@XZ PROC				; Json::Value::~Value, COMDAT
; _this$ = ecx

; 497  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	DWORD PTR _this$[ebp], ecx

; 498  :    switch ( type_ )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	shl	ecx, 24					; 00000018H
	sar	ecx, 24					; 00000018H
	mov	DWORD PTR tv67[ebp], ecx
	cmp	DWORD PTR tv67[ebp], 4
	je	SHORT $LN5@Value@3
	cmp	DWORD PTR tv67[ebp], 5
	jle	SHORT $LN7@Value@3
	cmp	DWORD PTR tv67[ebp], 7
	jle	SHORT $LN3@Value@3
	jmp	SHORT $LN7@Value@3

; 499  :    {
; 500  :    case nullValue:
; 501  :    case intValue:
; 502  :    case uintValue:
; 503  :    case realValue:
; 504  :    case booleanValue:
; 505  :       break;

	jmp	SHORT $LN7@Value@3
$LN5@Value@3:

; 506  :    case stringValue:
; 507  :       if ( allocated_ )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	shl	eax, 23					; 00000017H
	sar	eax, 31					; 0000001fH
	je	SHORT $LN4@Value@3

; 508  :          valueAllocator()->releaseStringValue( value_.string_ );

	call	?valueAllocator@Json@@YAAAPAVValueAllocator@1@XZ ; Json::valueAllocator
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv75[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR tv75[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv75[ebp]
	mov	eax, DWORD PTR [edx+16]
	call	eax
$LN4@Value@3:

; 509  :       break;

	jmp	SHORT $LN7@Value@3
$LN3@Value@3:

; 510  : #ifndef JSON_VALUE_USE_INTERNAL_MAP
; 511  :    case arrayValue:
; 512  :    case objectValue:
; 513  :       delete value_.map_;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T31143[ebp], edx
	mov	eax, DWORD PTR $T31143[ebp]
	mov	DWORD PTR $T31142[ebp], eax
	cmp	DWORD PTR $T31142[ebp], 0
	je	SHORT $LN11@Value@3
	push	1
	mov	ecx, DWORD PTR $T31142[ebp]
	call	??_G?$map@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@@std@@QAEPAXI@Z
	mov	DWORD PTR tv83[ebp], eax
	jmp	SHORT $LN7@Value@3
$LN11@Value@3:
	mov	DWORD PTR tv83[ebp], 0
$LN7@Value@3:

; 514  :       break;
; 515  : #else
; 516  :    case arrayValue:
; 517  :       arrayAllocator()->destructArray( value_.array_ );
; 518  :       break;
; 519  :    case objectValue:
; 520  :       mapAllocator()->destructMap( value_.map_ );
; 521  :       break;
; 522  : #endif
; 523  :    default:
; 524  :       JSON_ASSERT_UNREACHABLE;
; 525  :    }
; 526  : 
; 527  :    if ( comments_ )

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+12], 0
	je	SHORT $LN9@Value@3

; 528  :       delete[] comments_;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR $T31147[ebp], eax
	mov	ecx, DWORD PTR $T31147[ebp]
	mov	DWORD PTR $T31146[ebp], ecx
	cmp	DWORD PTR $T31146[ebp], 0
	je	SHORT $LN13@Value@3
	push	3
	mov	ecx, DWORD PTR $T31146[ebp]
	call	??_ECommentInfo@Value@Json@@QAEPAXI@Z
	mov	DWORD PTR tv94[ebp], eax
	jmp	SHORT $LN9@Value@3
$LN13@Value@3:
	mov	DWORD PTR tv94[ebp], 0
$LN9@Value@3:

; 529  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??1Value@Json@@QAE@XZ ENDP				; Json::Value::~Value
_TEXT	ENDS
PUBLIC	??1?$map@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@@std@@QAE@XZ ; std::map<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > >::~map<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > >
; Function compile flags: /Odtp
;	COMDAT ??_G?$map@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@@std@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G?$map@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@@std@@QAEPAXI@Z PROC ; std::map<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > >::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$map@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@@std@@QAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@4
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@4:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_G?$map@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@@std@@QAEPAXI@Z ENDP ; std::map<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > >::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??1?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::~_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >
; Function compile flags: /Odtp
;	COMDAT ??1?$map@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$map@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@@std@@QAE@XZ PROC ; std::map<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > >::~map<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::~_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$map@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@@std@@QAE@XZ ENDP ; std::map<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > >::~map<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > >
_TEXT	ENDS
PUBLIC	?swap@Value@Json@@QAEXAAV12@@Z			; Json::Value::swap
PUBLIC	??4Value@Json@@QAEAAV01@ABV01@@Z		; Json::Value::operator=
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??4Value@Json@@QAEAAV01@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??4Value@Json@@QAEAAV01@ABV01@@Z$0
__ehfuncinfo$??4Value@Json@@QAEAAV01@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??4Value@Json@@QAEAAV01@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??4Value@Json@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -36						; size = 4
$T31157 = -32						; size = 4
_temp$ = -28						; size = 16
__$EHRec$ = -12						; size = 12
_other$ = 8						; size = 4
??4Value@Json@@QAEAAV01@ABV01@@Z PROC			; Json::Value::operator=, COMDAT
; _this$ = ecx

; 533  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??4Value@Json@@QAEAAV01@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 24					; 00000018H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 534  :    Value temp( other );

	mov	eax, DWORD PTR _other$[ebp]
	push	eax
	lea	ecx, DWORD PTR _temp$[ebp]
	call	??0Value@Json@@QAE@ABV01@@Z		; Json::Value::Value
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 535  :    swap( temp );

	lea	ecx, DWORD PTR _temp$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?swap@Value@Json@@QAEXAAV12@@Z		; Json::Value::swap

; 536  :    return *this;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR $T31157[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _temp$[ebp]
	call	??1Value@Json@@QAE@XZ			; Json::Value::~Value
	mov	eax, DWORD PTR $T31157[ebp]

; 537  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??4Value@Json@@QAEAAV01@ABV01@@Z$0:
	lea	ecx, DWORD PTR _temp$[ebp]
	jmp	??1Value@Json@@QAE@XZ			; Json::Value::~Value
__ehhandler$??4Value@Json@@QAEAAV01@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-28]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??4Value@Json@@QAEAAV01@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??4Value@Json@@QAEAAV01@ABV01@@Z ENDP			; Json::Value::operator=
PUBLIC	??$swap@TValueHolder@Value@Json@@@std@@YAXAATValueHolder@Value@Json@@0@Z ; std::swap<Json::Value::ValueHolder>
; Function compile flags: /Odtp
;	COMDAT ?swap@Value@Json@@QAEXAAV12@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
_temp2$ = -8						; size = 4
_temp$ = -4						; size = 4
_other$ = 8						; size = 4
?swap@Value@Json@@QAEXAAV12@@Z PROC			; Json::Value::swap, COMDAT
; _this$ = ecx

; 541  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 542  :    ValueType temp = type_;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	shl	ecx, 24					; 00000018H
	sar	ecx, 24					; 00000018H
	mov	DWORD PTR _temp$[ebp], ecx

; 543  :    type_ = other.type_;

	mov	edx, DWORD PTR _other$[ebp]
	mov	eax, DWORD PTR [edx+8]
	shl	eax, 24					; 00000018H
	sar	eax, 24					; 00000018H
	and	eax, 255				; 000000ffH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	and	edx, -256				; ffffff00H
	or	edx, eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], edx

; 544  :    other.type_ = temp;

	mov	ecx, DWORD PTR _temp$[ebp]
	and	ecx, 255				; 000000ffH
	mov	edx, DWORD PTR _other$[ebp]
	mov	eax, DWORD PTR [edx+8]
	and	eax, -256				; ffffff00H
	or	eax, ecx
	mov	ecx, DWORD PTR _other$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 545  :    std::swap( value_, other.value_ );

	mov	edx, DWORD PTR _other$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??$swap@TValueHolder@Value@Json@@@std@@YAXAATValueHolder@Value@Json@@0@Z ; std::swap<Json::Value::ValueHolder>
	add	esp, 8

; 546  :    int temp2 = allocated_;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	shl	edx, 23					; 00000017H
	sar	edx, 31					; 0000001fH
	mov	DWORD PTR _temp2$[ebp], edx

; 547  :    allocated_ = other.allocated_;

	mov	eax, DWORD PTR _other$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	shl	ecx, 23					; 00000017H
	sar	ecx, 31					; 0000001fH
	and	ecx, 1
	shl	ecx, 8
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	and	eax, -257				; fffffeffH
	or	eax, ecx
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 548  :    other.allocated_ = temp2;

	mov	edx, DWORD PTR _temp2$[ebp]
	and	edx, 1
	shl	edx, 8
	mov	eax, DWORD PTR _other$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	and	ecx, -257				; fffffeffH
	or	ecx, edx
	mov	edx, DWORD PTR _other$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 549  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?swap@Value@Json@@QAEXAAV12@@Z ENDP			; Json::Value::swap
_TEXT	ENDS
PUBLIC	?type@Value@Json@@QBE?AW4ValueType@2@XZ		; Json::Value::type
; Function compile flags: /Odtp
;	COMDAT ?type@Value@Json@@QBE?AW4ValueType@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?type@Value@Json@@QBE?AW4ValueType@2@XZ PROC		; Json::Value::type, COMDAT
; _this$ = ecx

; 553  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 554  :    return type_;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]
	shl	eax, 24					; 00000018H
	sar	eax, 24					; 00000018H

; 555  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?type@Value@Json@@QBE?AW4ValueType@2@XZ ENDP		; Json::Value::type
_TEXT	ENDS
PUBLIC	?compare@Value@Json@@QAEHABV12@@Z		; Json::Value::compare
; Function compile flags: /Odtp
;	COMDAT ?compare@Value@Json@@QAEHABV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_other$ = 8						; size = 4
?compare@Value@Json@@QAEHABV12@@Z PROC			; Json::Value::compare, COMDAT
; _this$ = ecx

; 560  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 561  :    /*
; 562  :    int typeDelta = other.type_ - type_;
; 563  :    switch ( type_ )
; 564  :    {
; 565  :    case nullValue:
; 566  : 
; 567  :       return other.type_ == type_;
; 568  :    case intValue:
; 569  :       if ( other.type_.isNumeric()
; 570  :    case uintValue:
; 571  :    case realValue:
; 572  :    case booleanValue:
; 573  :       break;
; 574  :    case stringValue,
; 575  :       break;
; 576  :    case arrayValue:
; 577  :       delete value_.array_;
; 578  :       break;
; 579  :    case objectValue:
; 580  :       delete value_.map_;
; 581  :    default:
; 582  :       JSON_ASSERT_UNREACHABLE;
; 583  :    }
; 584  :    */
; 585  :    return 0;  // unreachable

	xor	eax, eax

; 586  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?compare@Value@Json@@QAEHABV12@@Z ENDP			; Json::Value::compare
_TEXT	ENDS
PUBLIC	??$?MV?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@YA_NABV?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@0@Z ; std::operator<<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >
PUBLIC	?size@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::size
PUBLIC	??MValue@Json@@QBE_NABV01@@Z			; Json::Value::operator<
; Function compile flags: /Odtp
;	COMDAT ??MValue@Json@@QBE_NABV01@@Z
_TEXT	SEGMENT
tv133 = -68						; size = 4
tv129 = -64						; size = 4
tv218 = -60						; size = 4
tv213 = -54						; size = 1
tv206 = -53						; size = 1
tv200 = -52						; size = 4
tv202 = -48						; size = 4
tv85 = -44						; size = 4
tv82 = -40						; size = 4
tv173 = -36						; size = 4
tv172 = -32						; size = 4
tv79 = -28						; size = 4
tv160 = -24						; size = 4
tv159 = -20						; size = 4
tv77 = -16						; size = 4
_this$ = -12						; size = 4
_delta$21259 = -8					; size = 4
_typeDelta$ = -4					; size = 4
_other$ = 8						; size = 4
??MValue@Json@@QBE_NABV01@@Z PROC			; Json::Value::operator<, COMDAT
; _this$ = ecx

; 590  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 591  :    int typeDelta = type_ - other.type_;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	shl	ecx, 24					; 00000018H
	sar	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _other$[ebp]
	mov	eax, DWORD PTR [edx+8]
	shl	eax, 24					; 00000018H
	sar	eax, 24					; 00000018H
	sub	ecx, eax
	mov	DWORD PTR _typeDelta$[ebp], ecx

; 592  :    if ( typeDelta )

	je	SHORT $LN12@operator@3

; 593  :       return typeDelta < 0 ? true : false;

	cmp	DWORD PTR _typeDelta$[ebp], 0
	setl	al
	jmp	$LN13@operator@3
$LN12@operator@3:

; 594  :    switch ( type_ )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	shl	edx, 24					; 00000018H
	sar	edx, 24					; 00000018H
	mov	DWORD PTR tv77[ebp], edx
	cmp	DWORD PTR tv77[ebp], 7
	ja	$LN1@operator@3
	mov	eax, DWORD PTR tv77[ebp]
	jmp	DWORD PTR $LN31@operator@3[eax*4]
$LN9@operator@3:

; 595  :    {
; 596  :    case nullValue:
; 597  :       return false;

	xor	al, al
	jmp	$LN13@operator@3
$LN8@operator@3:

; 598  :    case intValue:
; 599  :       return value_.int_ < other.value_.int_;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _other$[ebp]
	mov	DWORD PTR tv159[ebp], ecx
	mov	DWORD PTR tv160[ebp], edx
	mov	eax, DWORD PTR tv159[ebp]
	mov	ecx, DWORD PTR tv160[ebp]
	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [ecx+4]
	jg	SHORT $LN15@operator@3
	jl	SHORT $LN25@operator@3
	mov	eax, DWORD PTR tv159[ebp]
	mov	ecx, DWORD PTR tv160[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx]
	jae	SHORT $LN15@operator@3
$LN25@operator@3:
	mov	DWORD PTR tv79[ebp], 1
	jmp	SHORT $LN16@operator@3
$LN15@operator@3:
	mov	DWORD PTR tv79[ebp], 0
$LN16@operator@3:
	mov	al, BYTE PTR tv79[ebp]
	jmp	$LN13@operator@3
$LN7@operator@3:

; 600  :    case uintValue:
; 601  :       return value_.uint_ < other.value_.uint_;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _other$[ebp]
	mov	DWORD PTR tv172[ebp], eax
	mov	DWORD PTR tv173[ebp], ecx
	mov	edx, DWORD PTR tv172[ebp]
	mov	eax, DWORD PTR tv173[ebp]
	mov	ecx, DWORD PTR [edx+4]
	cmp	ecx, DWORD PTR [eax+4]
	ja	SHORT $LN17@operator@3
	jb	SHORT $LN26@operator@3
	mov	edx, DWORD PTR tv172[ebp]
	mov	eax, DWORD PTR tv173[ebp]
	mov	ecx, DWORD PTR [edx]
	cmp	ecx, DWORD PTR [eax]
	jae	SHORT $LN17@operator@3
$LN26@operator@3:
	mov	DWORD PTR tv82[ebp], 1
	jmp	SHORT $LN18@operator@3
$LN17@operator@3:
	mov	DWORD PTR tv82[ebp], 0
$LN18@operator@3:
	mov	al, BYTE PTR tv82[ebp]
	jmp	$LN13@operator@3
$LN6@operator@3:

; 602  :    case realValue:
; 603  :       return value_.real_ < other.value_.real_;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _other$[ebp]
	fld	QWORD PTR [eax]
	fcomp	QWORD PTR [edx]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN19@operator@3
	mov	DWORD PTR tv85[ebp], 1
	jmp	SHORT $LN20@operator@3
$LN19@operator@3:
	mov	DWORD PTR tv85[ebp], 0
$LN20@operator@3:
	mov	al, BYTE PTR tv85[ebp]
	jmp	$LN13@operator@3
$LN5@operator@3:

; 604  :    case booleanValue:
; 605  :       return value_.bool_ < other.value_.bool_;

	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx]
	mov	eax, DWORD PTR _other$[ebp]
	movzx	ecx, BYTE PTR [eax]
	xor	eax, eax
	cmp	edx, ecx
	setl	al
	jmp	$LN13@operator@3
$LN4@operator@3:

; 606  :    case stringValue:
; 607  :       return ( value_.string_ == 0  &&  other.value_.string_ )
; 608  :              || ( other.value_.string_  
; 609  :                   &&  value_.string_  
; 610  :                   && strcmp( value_.string_, other.value_.string_ ) < 0 );

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $LN21@operator@3
	mov	eax, DWORD PTR _other$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN23@operator@3
$LN21@operator@3:
	mov	ecx, DWORD PTR _other$[ebp]
	cmp	DWORD PTR [ecx], 0
	je	SHORT $LN22@operator@3
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx], 0
	je	SHORT $LN22@operator@3
	mov	eax, DWORD PTR _other$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv202[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR tv200[ebp], eax
$LL27@operator@3:
	mov	ecx, DWORD PTR tv200[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR tv206[ebp], dl
	mov	eax, DWORD PTR tv202[ebp]
	cmp	dl, BYTE PTR [eax]
	jne	SHORT $LN28@operator@3
	cmp	BYTE PTR tv206[ebp], 0
	je	SHORT $LN29@operator@3
	mov	ecx, DWORD PTR tv200[ebp]
	mov	dl, BYTE PTR [ecx+1]
	mov	BYTE PTR tv213[ebp], dl
	mov	eax, DWORD PTR tv202[ebp]
	cmp	dl, BYTE PTR [eax+1]
	jne	SHORT $LN28@operator@3
	add	DWORD PTR tv200[ebp], 2
	add	DWORD PTR tv202[ebp], 2
	cmp	BYTE PTR tv213[ebp], 0
	jne	SHORT $LL27@operator@3
$LN29@operator@3:
	mov	DWORD PTR tv218[ebp], 0
	jmp	SHORT $LN30@operator@3
$LN28@operator@3:
	sbb	ecx, ecx
	sbb	ecx, -1
	mov	DWORD PTR tv218[ebp], ecx
$LN30@operator@3:
	mov	edx, DWORD PTR tv218[ebp]
	mov	DWORD PTR tv129[ebp], edx
	cmp	DWORD PTR tv129[ebp], 0
	jl	SHORT $LN23@operator@3
$LN22@operator@3:
	mov	DWORD PTR tv133[ebp], 0
	jmp	SHORT $LN24@operator@3
$LN23@operator@3:
	mov	DWORD PTR tv133[ebp], 1
$LN24@operator@3:
	mov	al, BYTE PTR tv133[ebp]
	jmp	SHORT $LN13@operator@3
$LN3@operator@3:

; 611  : #ifndef JSON_VALUE_USE_INTERNAL_MAP
; 612  :    case arrayValue:
; 613  :    case objectValue:
; 614  :       {
; 615  :          int delta = int( value_.map_->size() - other.value_.map_->size() );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?size@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::size
	mov	esi, eax
	mov	ecx, DWORD PTR _other$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?size@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::size
	sub	esi, eax
	mov	DWORD PTR _delta$21259[ebp], esi

; 616  :          if ( delta )

	je	SHORT $LN2@operator@3

; 617  :             return delta < 0;

	xor	eax, eax
	cmp	DWORD PTR _delta$21259[ebp], 0
	setl	al
	jmp	SHORT $LN13@operator@3
$LN2@operator@3:

; 618  :          return (*value_.map_) < (*other.value_.map_);

	mov	edx, DWORD PTR _other$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	??$?MV?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@YA_NABV?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@0@Z ; std::operator<<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >
	add	esp, 8
	jmp	SHORT $LN13@operator@3
$LN1@operator@3:

; 619  :       }
; 620  : #else
; 621  :    case arrayValue:
; 622  :       return value_.array_->compare( *(other.value_.array_) ) < 0;
; 623  :    case objectValue:
; 624  :       return value_.map_->compare( *(other.value_.map_) ) < 0;
; 625  : #endif
; 626  :    default:
; 627  :       JSON_ASSERT_UNREACHABLE;
; 628  :    }
; 629  :    return 0;  // unreachable

	xor	al, al
$LN13@operator@3:

; 630  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	3
$LN31@operator@3:
	DD	$LN9@operator@3
	DD	$LN8@operator@3
	DD	$LN7@operator@3
	DD	$LN6@operator@3
	DD	$LN4@operator@3
	DD	$LN5@operator@3
	DD	$LN3@operator@3
	DD	$LN3@operator@3
??MValue@Json@@QBE_NABV01@@Z ENDP			; Json::Value::operator<
_TEXT	ENDS
PUBLIC	??OValue@Json@@QBE_NABV01@@Z			; Json::Value::operator>
PUBLIC	??NValue@Json@@QBE_NABV01@@Z			; Json::Value::operator<=
; Function compile flags: /Odtp
;	COMDAT ??NValue@Json@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_other$ = 8						; size = 4
??NValue@Json@@QBE_NABV01@@Z PROC			; Json::Value::operator<=, COMDAT
; _this$ = ecx

; 634  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 635  :    return !(other > *this);

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _other$[ebp]
	call	??OValue@Json@@QBE_NABV01@@Z		; Json::Value::operator>
	movzx	eax, al
	neg	eax
	sbb	eax, eax
	add	eax, 1

; 636  : }

	mov	esp, ebp
	pop	ebp
	ret	4
??NValue@Json@@QBE_NABV01@@Z ENDP			; Json::Value::operator<=
_TEXT	ENDS
PUBLIC	??PValue@Json@@QBE_NABV01@@Z			; Json::Value::operator>=
; Function compile flags: /Odtp
;	COMDAT ??PValue@Json@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_other$ = 8						; size = 4
??PValue@Json@@QBE_NABV01@@Z PROC			; Json::Value::operator>=, COMDAT
; _this$ = ecx

; 640  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 641  :    return !(*this < other);

	mov	eax, DWORD PTR _other$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??MValue@Json@@QBE_NABV01@@Z		; Json::Value::operator<
	movzx	eax, al
	neg	eax
	sbb	eax, eax
	add	eax, 1

; 642  : }

	mov	esp, ebp
	pop	ebp
	ret	4
??PValue@Json@@QBE_NABV01@@Z ENDP			; Json::Value::operator>=
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??OValue@Json@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_other$ = 8						; size = 4
??OValue@Json@@QBE_NABV01@@Z PROC			; Json::Value::operator>, COMDAT
; _this$ = ecx

; 646  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 647  :    return other < *this;

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _other$[ebp]
	call	??MValue@Json@@QBE_NABV01@@Z		; Json::Value::operator<

; 648  : }

	mov	esp, ebp
	pop	ebp
	ret	4
??OValue@Json@@QBE_NABV01@@Z ENDP			; Json::Value::operator>
_TEXT	ENDS
PUBLIC	??$?8V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@YA_NABV?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@0@Z ; std::operator==<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >
PUBLIC	??8Value@Json@@QBE_NABV01@@Z			; Json::Value::operator==
; Function compile flags: /Odtp
;	COMDAT ??8Value@Json@@QBE_NABV01@@Z
_TEXT	SEGMENT
tv141 = -68						; size = 4
tv129 = -64						; size = 4
tv93 = -60						; size = 4
tv213 = -56						; size = 4
tv208 = -50						; size = 1
tv201 = -49						; size = 1
tv195 = -48						; size = 4
tv197 = -44						; size = 4
tv82 = -40						; size = 4
tv79 = -36						; size = 4
tv168 = -32						; size = 4
tv167 = -28						; size = 4
tv76 = -24						; size = 4
tv156 = -20						; size = 4
tv155 = -16						; size = 4
tv74 = -12						; size = 4
_this$ = -8						; size = 4
_temp$ = -4						; size = 4
_other$ = 8						; size = 4
??8Value@Json@@QBE_NABV01@@Z PROC			; Json::Value::operator==, COMDAT
; _this$ = ecx

; 652  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 653  :    //if ( type_ != other.type_ )
; 654  :    // GCC 2.95.3 says:
; 655  :    // attempt to take address of bit-field structure member `Json::Value::type_'
; 656  :    // Beats me, but a temp solves the problem.
; 657  :    int temp = other.type_;

	mov	eax, DWORD PTR _other$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	shl	ecx, 24					; 00000018H
	sar	ecx, 24					; 00000018H
	mov	DWORD PTR _temp$[ebp], ecx

; 658  :    if ( type_ != temp )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	shl	eax, 24					; 00000018H
	sar	eax, 24					; 00000018H
	cmp	eax, DWORD PTR _temp$[ebp]
	je	SHORT $LN11@operator@4

; 659  :       return false;

	xor	al, al
	jmp	$LN12@operator@4
$LN11@operator@4:

; 660  :    switch ( type_ )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	shl	edx, 24					; 00000018H
	sar	edx, 24					; 00000018H
	mov	DWORD PTR tv74[ebp], edx
	cmp	DWORD PTR tv74[ebp], 7
	ja	$LN1@operator@4
	mov	eax, DWORD PTR tv74[ebp]
	jmp	DWORD PTR $LN29@operator@4[eax*4]
$LN8@operator@4:

; 661  :    {
; 662  :    case nullValue:
; 663  :       return true;

	mov	al, 1
	jmp	$LN12@operator@4
$LN7@operator@4:

; 664  :    case intValue:
; 665  :       return value_.int_ == other.value_.int_;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _other$[ebp]
	mov	DWORD PTR tv155[ebp], ecx
	mov	DWORD PTR tv156[ebp], edx
	mov	eax, DWORD PTR tv155[ebp]
	mov	ecx, DWORD PTR tv156[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx]
	jne	SHORT $LN14@operator@4
	mov	eax, DWORD PTR tv155[ebp]
	mov	ecx, DWORD PTR tv156[ebp]
	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [ecx+4]
	jne	SHORT $LN14@operator@4
	mov	DWORD PTR tv76[ebp], 1
	jmp	SHORT $LN15@operator@4
$LN14@operator@4:
	mov	DWORD PTR tv76[ebp], 0
$LN15@operator@4:
	mov	al, BYTE PTR tv76[ebp]
	jmp	$LN12@operator@4
$LN6@operator@4:

; 666  :    case uintValue:
; 667  :       return value_.uint_ == other.value_.uint_;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _other$[ebp]
	mov	DWORD PTR tv167[ebp], eax
	mov	DWORD PTR tv168[ebp], ecx
	mov	edx, DWORD PTR tv167[ebp]
	mov	eax, DWORD PTR tv168[ebp]
	mov	ecx, DWORD PTR [edx]
	cmp	ecx, DWORD PTR [eax]
	jne	SHORT $LN16@operator@4
	mov	edx, DWORD PTR tv167[ebp]
	mov	eax, DWORD PTR tv168[ebp]
	mov	ecx, DWORD PTR [edx+4]
	cmp	ecx, DWORD PTR [eax+4]
	jne	SHORT $LN16@operator@4
	mov	DWORD PTR tv79[ebp], 1
	jmp	SHORT $LN17@operator@4
$LN16@operator@4:
	mov	DWORD PTR tv79[ebp], 0
$LN17@operator@4:
	mov	al, BYTE PTR tv79[ebp]
	jmp	$LN12@operator@4
$LN5@operator@4:

; 668  :    case realValue:
; 669  :       return value_.real_ == other.value_.real_;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _other$[ebp]
	fld	QWORD PTR [eax]
	fcomp	QWORD PTR [edx]
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $LN18@operator@4
	mov	DWORD PTR tv82[ebp], 1
	jmp	SHORT $LN19@operator@4
$LN18@operator@4:
	mov	DWORD PTR tv82[ebp], 0
$LN19@operator@4:
	mov	al, BYTE PTR tv82[ebp]
	jmp	$LN12@operator@4
$LN4@operator@4:

; 670  :    case booleanValue:
; 671  :       return value_.bool_ == other.value_.bool_;

	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx]
	mov	eax, DWORD PTR _other$[ebp]
	movzx	ecx, BYTE PTR [eax]
	xor	eax, eax
	cmp	edx, ecx
	sete	al
	jmp	$LN12@operator@4
$LN3@operator@4:

; 672  :    case stringValue:
; 673  :       return ( value_.string_ == other.value_.string_ )
; 674  :              || ( other.value_.string_  
; 675  :                   &&  value_.string_  
; 676  :                   && strcmp( value_.string_, other.value_.string_ ) == 0 );

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _other$[ebp]
	mov	ecx, DWORD PTR [edx]
	cmp	ecx, DWORD PTR [eax]
	je	SHORT $LN21@operator@4
	mov	edx, DWORD PTR _other$[ebp]
	cmp	DWORD PTR [edx], 0
	je	SHORT $LN20@operator@4
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN20@operator@4
	mov	ecx, DWORD PTR _other$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR tv197[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv195[ebp], ecx
$LL25@operator@4:
	mov	edx, DWORD PTR tv195[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR tv201[ebp], al
	mov	ecx, DWORD PTR tv197[ebp]
	cmp	al, BYTE PTR [ecx]
	jne	SHORT $LN26@operator@4
	cmp	BYTE PTR tv201[ebp], 0
	je	SHORT $LN27@operator@4
	mov	edx, DWORD PTR tv195[ebp]
	mov	al, BYTE PTR [edx+1]
	mov	BYTE PTR tv208[ebp], al
	mov	ecx, DWORD PTR tv197[ebp]
	cmp	al, BYTE PTR [ecx+1]
	jne	SHORT $LN26@operator@4
	add	DWORD PTR tv195[ebp], 2
	add	DWORD PTR tv197[ebp], 2
	cmp	BYTE PTR tv208[ebp], 0
	jne	SHORT $LL25@operator@4
$LN27@operator@4:
	mov	DWORD PTR tv213[ebp], 0
	jmp	SHORT $LN28@operator@4
$LN26@operator@4:
	sbb	edx, edx
	sbb	edx, -1
	mov	DWORD PTR tv213[ebp], edx
$LN28@operator@4:
	mov	eax, DWORD PTR tv213[ebp]
	mov	DWORD PTR tv93[ebp], eax
	cmp	DWORD PTR tv93[ebp], 0
	je	SHORT $LN21@operator@4
$LN20@operator@4:
	mov	DWORD PTR tv129[ebp], 0
	jmp	SHORT $LN22@operator@4
$LN21@operator@4:
	mov	DWORD PTR tv129[ebp], 1
$LN22@operator@4:
	mov	al, BYTE PTR tv129[ebp]
	jmp	SHORT $LN12@operator@4
$LN2@operator@4:

; 677  : #ifndef JSON_VALUE_USE_INTERNAL_MAP
; 678  :    case arrayValue:
; 679  :    case objectValue:
; 680  :       return value_.map_->size() == other.value_.map_->size()
; 681  :              && (*value_.map_) == (*other.value_.map_);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?size@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::size
	mov	esi, eax
	mov	edx, DWORD PTR _other$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?size@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::size
	cmp	esi, eax
	jne	SHORT $LN23@operator@4
	mov	eax, DWORD PTR _other$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	??$?8V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@YA_NABV?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@0@Z ; std::operator==<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN23@operator@4
	mov	DWORD PTR tv141[ebp], 1
	jmp	SHORT $LN24@operator@4
$LN23@operator@4:
	mov	DWORD PTR tv141[ebp], 0
$LN24@operator@4:
	mov	al, BYTE PTR tv141[ebp]
	jmp	SHORT $LN12@operator@4
$LN1@operator@4:

; 682  : #else
; 683  :    case arrayValue:
; 684  :       return value_.array_->compare( *(other.value_.array_) ) == 0;
; 685  :    case objectValue:
; 686  :       return value_.map_->compare( *(other.value_.map_) ) == 0;
; 687  : #endif
; 688  :    default:
; 689  :       JSON_ASSERT_UNREACHABLE;
; 690  :    }
; 691  :    return 0;  // unreachable

	xor	al, al
$LN12@operator@4:

; 692  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	3
$LN29@operator@4:
	DD	$LN8@operator@4
	DD	$LN7@operator@4
	DD	$LN6@operator@4
	DD	$LN5@operator@4
	DD	$LN3@operator@4
	DD	$LN4@operator@4
	DD	$LN2@operator@4
	DD	$LN2@operator@4
??8Value@Json@@QBE_NABV01@@Z ENDP			; Json::Value::operator==
_TEXT	ENDS
PUBLIC	??9Value@Json@@QBE_NABV01@@Z			; Json::Value::operator!=
; Function compile flags: /Odtp
;	COMDAT ??9Value@Json@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_other$ = 8						; size = 4
??9Value@Json@@QBE_NABV01@@Z PROC			; Json::Value::operator!=, COMDAT
; _this$ = ecx

; 696  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 697  :    return !( *this == other );

	mov	eax, DWORD PTR _other$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8Value@Json@@QBE_NABV01@@Z		; Json::Value::operator==
	movzx	eax, al
	neg	eax
	sbb	eax, eax
	add	eax, 1

; 698  : }

	mov	esp, ebp
	pop	ebp
	ret	4
??9Value@Json@@QBE_NABV01@@Z ENDP			; Json::Value::operator!=
_TEXT	ENDS
PUBLIC	?asCString@Value@Json@@QBEPBDXZ			; Json::Value::asCString
; Function compile flags: /Odtp
;	COMDAT ?asCString@Value@Json@@QBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?asCString@Value@Json@@QBEPBDXZ PROC			; Json::Value::asCString, COMDAT
; _this$ = ecx

; 702  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 703  :    JSON_ASSERT( type_ == stringValue );
; 704  :    return value_.string_;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 705  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?asCString@Value@Json@@QBEPBDXZ ENDP			; Json::Value::asCString
_TEXT	ENDS
PUBLIC	??_C@_0CC@BNBMBIGA@Type?5is?5not?5convertible?5to?5strin@ ; `string'
PUBLIC	??_C@_05LAPONLG@false?$AA@			; `string'
PUBLIC	??_C@_04LOAJBDKD@true?$AA@			; `string'
PUBLIC	?asString@Value@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ; Json::Value::asString
;	COMDAT ??_C@_0CC@BNBMBIGA@Type?5is?5not?5convertible?5to?5strin@
CONST	SEGMENT
??_C@_0CC@BNBMBIGA@Type?5is?5not?5convertible?5to?5strin@ DB 'Type is not'
	DB	' convertible to string', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05LAPONLG@false?$AA@
CONST	SEGMENT
??_C@_05LAPONLG@false?$AA@ DB 'false', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04LOAJBDKD@true?$AA@
CONST	SEGMENT
??_C@_04LOAJBDKD@true?$AA@ DB 'true', 00H		; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?asString@Value@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?asString@Value@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ$1
__ehfuncinfo$?asString@Value@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?asString@Value@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?asString@Value@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
_TEXT	SEGMENT
tv82 = -100						; size = 4
tv75 = -96						; size = 4
tv67 = -92						; size = 4
_this$ = -88						; size = 4
$T31227 = -84						; size = 4
$T31225 = -80						; size = 28
$T31224 = -52						; size = 40
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
?asString@Value@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ PROC ; Json::Value::asString, COMDAT
; _this$ = ecx

; 710  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?asString@Value@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 88					; 00000058H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T31227[ebp], 0

; 711  :    switch ( type_ )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	shl	ecx, 24					; 00000018H
	sar	ecx, 24					; 00000018H
	mov	DWORD PTR tv67[ebp], ecx
	cmp	DWORD PTR tv67[ebp], 7
	ja	$LN7@asString
	mov	edx, DWORD PTR tv67[ebp]
	jmp	DWORD PTR $LN19@asString[edx*4]
$LN6@asString:

; 712  :    {
; 713  :    case nullValue:
; 714  :       return "";

	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	eax, DWORD PTR $T31227[ebp]
	or	eax, 1
	mov	DWORD PTR $T31227[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN10@asString
$LN5@asString:

; 715  :    case stringValue:
; 716  :       return value_.string_ ? value_.string_ : "";

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx], 0
	je	SHORT $LN11@asString
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR tv75[ebp], eax
	jmp	SHORT $LN12@asString
$LN11@asString:
	mov	DWORD PTR tv75[ebp], OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN12@asString:
	mov	ecx, DWORD PTR tv75[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	edx, DWORD PTR $T31227[ebp]
	or	edx, 1
	mov	DWORD PTR $T31227[ebp], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN10@asString
$LN4@asString:

; 717  :    case booleanValue:
; 718  :       return value_.bool_ ? "true" : "false";

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN13@asString
	mov	DWORD PTR tv82[ebp], OFFSET ??_C@_04LOAJBDKD@true?$AA@
	jmp	SHORT $LN14@asString
$LN13@asString:
	mov	DWORD PTR tv82[ebp], OFFSET ??_C@_05LAPONLG@false?$AA@
$LN14@asString:
	mov	edx, DWORD PTR tv82[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	eax, DWORD PTR $T31227[ebp]
	or	eax, 1
	mov	DWORD PTR $T31227[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN10@asString
$LN3@asString:

; 719  :    case intValue:
; 720  :    case uintValue:
; 721  :    case realValue:
; 722  :    case arrayValue:
; 723  :    case objectValue:
; 724  :       JSON_ASSERT_MESSAGE( false, "Type is not convertible to string" );

	mov	ecx, 1
	test	ecx, ecx
	je	SHORT $LN7@asString
	push	OFFSET ??_C@_0CC@BNBMBIGA@Type?5is?5not?5convertible?5to?5strin@
	lea	ecx, DWORD PTR $T31225[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	edx, DWORD PTR $T31225[ebp]
	push	edx
	lea	ecx, DWORD PTR $T31224[ebp]
	call	??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::runtime_error::runtime_error
	push	OFFSET __TI2?AVruntime_error@std@@
	lea	eax, DWORD PTR $T31224[ebp]
	push	eax
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T31225[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN7@asString:

; 725  :    default:
; 726  :       JSON_ASSERT_UNREACHABLE;
; 727  :    }
; 728  :    return ""; // unreachable

	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	ecx, DWORD PTR $T31227[ebp]
	or	ecx, 1
	mov	DWORD PTR $T31227[ebp], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN10@asString:

; 729  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
$LN19@asString:
	DD	$LN6@asString
	DD	$LN3@asString
	DD	$LN3@asString
	DD	$LN3@asString
	DD	$LN5@asString
	DD	$LN4@asString
	DD	$LN3@asString
	DD	$LN3@asString
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?asString@Value@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ$1:
	lea	ecx, DWORD PTR $T31225[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?asString@Value@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-92]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?asString@Value@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?asString@Value@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ENDP ; Json::Value::asString
PUBLIC	??_C@_0BP@KDDCHLKA@Type?5is?5not?5convertible?5to?5int?$AA@ ; `string'
PUBLIC	??_C@_0CB@PBEICPFN@Real?5out?5of?5signed?5integer?5range@ ; `string'
PUBLIC	__real@41dfffffffc00000
PUBLIC	__real@c1e0000000000000
PUBLIC	??_C@_0CE@MKMAPPKF@integer?5out?5of?5signed?5integer?5ra@ ; `string'
PUBLIC	?asInt@Value@Json@@QBEHXZ			; Json::Value::asInt
EXTRN	__ftol2_sse:PROC
;	COMDAT ??_C@_0BP@KDDCHLKA@Type?5is?5not?5convertible?5to?5int?$AA@
CONST	SEGMENT
??_C@_0BP@KDDCHLKA@Type?5is?5not?5convertible?5to?5int?$AA@ DB 'Type is n'
	DB	'ot convertible to int', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@PBEICPFN@Real?5out?5of?5signed?5integer?5range@
CONST	SEGMENT
??_C@_0CB@PBEICPFN@Real?5out?5of?5signed?5integer?5range@ DB 'Real out of'
	DB	' signed integer range', 00H			; `string'
CONST	ENDS
;	COMDAT __real@41dfffffffc00000
CONST	SEGMENT
__real@41dfffffffc00000 DQ 041dfffffffc00000r	; 2.14748e+009
CONST	ENDS
;	COMDAT __real@c1e0000000000000
CONST	SEGMENT
__real@c1e0000000000000 DQ 0c1e0000000000000r	; -2.14748e+009
CONST	ENDS
;	COMDAT ??_C@_0CE@MKMAPPKF@integer?5out?5of?5signed?5integer?5ra@
CONST	SEGMENT
??_C@_0CE@MKMAPPKF@integer?5out?5of?5signed?5integer?5ra@ DB 'integer out'
	DB	' of signed integer range', 00H		; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?asInt@Value@Json@@QBEHXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?asInt@Value@Json@@QBEHXZ$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?asInt@Value@Json@@QBEHXZ$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?asInt@Value@Json@@QBEHXZ$2
__ehfuncinfo$?asInt@Value@Json@@QBEHXZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?asInt@Value@Json@@QBEHXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?asInt@Value@Json@@QBEHXZ
_TEXT	SEGMENT
tv142 = -228						; size = 4
tv67 = -224						; size = 4
_this$ = -220						; size = 4
$T31244 = -216						; size = 28
$T31243 = -188						; size = 40
$T31242 = -148						; size = 28
$T31241 = -120						; size = 40
$T31240 = -80						; size = 28
$T31239 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?asInt@Value@Json@@QBEHXZ PROC				; Json::Value::asInt, COMDAT
; _this$ = ecx

; 741  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?asInt@Value@Json@@QBEHXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 216				; 000000d8H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 742  :    switch ( type_ )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	shl	ecx, 24					; 00000018H
	sar	ecx, 24					; 00000018H
	mov	DWORD PTR tv67[ebp], ecx
	cmp	DWORD PTR tv67[ebp], 7
	ja	$LN2@asInt
	mov	edx, DWORD PTR tv67[ebp]
	jmp	DWORD PTR $LN21@asInt[edx*4]
$LN11@asInt:

; 743  :    {
; 744  :    case nullValue:
; 745  :       return 0;

	xor	eax, eax
	jmp	$LN14@asInt
$LN10@asInt:

; 746  :    case intValue:
; 747  : 	   return static_cast<Value::Int>(value_.int_);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]
	jmp	$LN14@asInt
$LN9@asInt:

; 748  :    case uintValue:
; 749  :       JSON_ASSERT_MESSAGE( value_.uint_ < (unsigned)maxInt, "integer out of signed integer range" );

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv142[ebp], ecx
	mov	edx, DWORD PTR tv142[ebp]
	cmp	DWORD PTR [edx+4], 0
	ja	SHORT $LN19@asInt
	mov	eax, DWORD PTR tv142[ebp]
	cmp	DWORD PTR [eax], 2147483647		; 7fffffffH
	jb	SHORT $LN8@asInt
$LN19@asInt:
	push	OFFSET ??_C@_0CE@MKMAPPKF@integer?5out?5of?5signed?5integer?5ra@
	lea	ecx, DWORD PTR $T31240[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T31240[ebp]
	push	ecx
	lea	ecx, DWORD PTR $T31239[ebp]
	call	??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::runtime_error::runtime_error
	push	OFFSET __TI2?AVruntime_error@std@@
	lea	edx, DWORD PTR $T31239[ebp]
	push	edx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T31240[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN8@asInt:

; 750  :       return static_cast<Value::Int>(value_.uint_);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]
	jmp	$LN14@asInt
$LN7@asInt:

; 751  :    case realValue:
; 752  :       JSON_ASSERT_MESSAGE( value_.real_ >= minInt  &&  value_.real_ <= maxInt, "Real out of signed integer range" );

	mov	ecx, DWORD PTR _this$[ebp]
	fld	QWORD PTR __real@c1e0000000000000
	fcomp	QWORD PTR [ecx]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jp	SHORT $LN5@asInt
	mov	edx, DWORD PTR _this$[ebp]
	fld	QWORD PTR __real@41dfffffffc00000
	fcomp	QWORD PTR [edx]
	fnstsw	ax
	test	ah, 1
	je	SHORT $LN6@asInt
$LN5@asInt:
	push	OFFSET ??_C@_0CB@PBEICPFN@Real?5out?5of?5signed?5integer?5range@
	lea	ecx, DWORD PTR $T31242[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	lea	eax, DWORD PTR $T31242[ebp]
	push	eax
	lea	ecx, DWORD PTR $T31241[ebp]
	call	??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::runtime_error::runtime_error
	push	OFFSET __TI2?AVruntime_error@std@@
	lea	ecx, DWORD PTR $T31241[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T31242[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN6@asInt:

; 753  :       return Int( value_.real_ );

	mov	edx, DWORD PTR _this$[ebp]
	fld	QWORD PTR [edx]
	call	__ftol2_sse
	jmp	SHORT $LN14@asInt
$LN4@asInt:

; 754  :    case booleanValue:
; 755  :       return value_.bool_ ? 1 : 0;

	mov	eax, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [eax]
	neg	eax
	sbb	eax, eax
	neg	eax
	jmp	SHORT $LN14@asInt
$LN3@asInt:

; 756  :    case stringValue:
; 757  :    case arrayValue:
; 758  :    case objectValue:
; 759  :       JSON_ASSERT_MESSAGE( false, "Type is not convertible to int" );

	mov	ecx, 1
	test	ecx, ecx
	je	SHORT $LN2@asInt
	push	OFFSET ??_C@_0BP@KDDCHLKA@Type?5is?5not?5convertible?5to?5int?$AA@
	lea	ecx, DWORD PTR $T31244[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 2
	lea	edx, DWORD PTR $T31244[ebp]
	push	edx
	lea	ecx, DWORD PTR $T31243[ebp]
	call	??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::runtime_error::runtime_error
	push	OFFSET __TI2?AVruntime_error@std@@
	lea	eax, DWORD PTR $T31243[ebp]
	push	eax
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T31244[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@asInt:

; 760  :    default:
; 761  :       JSON_ASSERT_UNREACHABLE;
; 762  :    }
; 763  :    return 0; // unreachable;

	xor	eax, eax
$LN14@asInt:

; 764  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN21@asInt:
	DD	$LN11@asInt
	DD	$LN10@asInt
	DD	$LN9@asInt
	DD	$LN7@asInt
	DD	$LN3@asInt
	DD	$LN4@asInt
	DD	$LN3@asInt
	DD	$LN3@asInt
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?asInt@Value@Json@@QBEHXZ$0:
	lea	ecx, DWORD PTR $T31240[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?asInt@Value@Json@@QBEHXZ$1:
	lea	ecx, DWORD PTR $T31242[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?asInt@Value@Json@@QBEHXZ$2:
	lea	ecx, DWORD PTR $T31244[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?asInt@Value@Json@@QBEHXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?asInt@Value@Json@@QBEHXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?asInt@Value@Json@@QBEHXZ ENDP				; Json::Value::asInt
PUBLIC	??_C@_0CA@LEFAEJPN@Type?5is?5not?5convertible?5to?5uint?$AA@ ; `string'
PUBLIC	??_C@_0CD@PGCLDEBG@Real?5out?5of?5unsigned?5integer?5ran@ ; `string'
PUBLIC	__real@41efffffffe00000
PUBLIC	??_C@_0DK@NAHIGMFE@Negative?5integer?5can?5not?5be?5conv@ ; `string'
PUBLIC	?asUInt@Value@Json@@QBEIXZ			; Json::Value::asUInt
;	COMDAT ??_C@_0CA@LEFAEJPN@Type?5is?5not?5convertible?5to?5uint?$AA@
CONST	SEGMENT
??_C@_0CA@LEFAEJPN@Type?5is?5not?5convertible?5to?5uint?$AA@ DB 'Type is '
	DB	'not convertible to uint', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@PGCLDEBG@Real?5out?5of?5unsigned?5integer?5ran@
CONST	SEGMENT
??_C@_0CD@PGCLDEBG@Real?5out?5of?5unsigned?5integer?5ran@ DB 'Real out of'
	DB	' unsigned integer range', 00H		; `string'
CONST	ENDS
;	COMDAT __real@41efffffffe00000
CONST	SEGMENT
__real@41efffffffe00000 DQ 041efffffffe00000r	; 4.29497e+009
CONST	ENDS
;	COMDAT ??_C@_0DK@NAHIGMFE@Negative?5integer?5can?5not?5be?5conv@
CONST	SEGMENT
??_C@_0DK@NAHIGMFE@Negative?5integer?5can?5not?5be?5conv@ DB 'Negative in'
	DB	'teger can not be converted to unsigned integer', 00H ; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?asUInt@Value@Json@@QBEIXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?asUInt@Value@Json@@QBEIXZ$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?asUInt@Value@Json@@QBEIXZ$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?asUInt@Value@Json@@QBEIXZ$2
__ehfuncinfo$?asUInt@Value@Json@@QBEIXZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?asUInt@Value@Json@@QBEIXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?asUInt@Value@Json@@QBEIXZ
_TEXT	SEGMENT
tv170 = -244						; size = 8
tv168 = -236						; size = 4
tv165 = -230						; size = 2
tv140 = -228						; size = 4
tv67 = -224						; size = 4
_this$ = -220						; size = 4
$T31268 = -216						; size = 28
$T31267 = -188						; size = 40
$T31266 = -148						; size = 28
$T31265 = -120						; size = 40
$T31264 = -80						; size = 28
$T31263 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?asUInt@Value@Json@@QBEIXZ PROC				; Json::Value::asUInt, COMDAT
; _this$ = ecx

; 768  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?asUInt@Value@Json@@QBEIXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 232				; 000000e8H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 769  :    switch ( type_ )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	shl	ecx, 24					; 00000018H
	sar	ecx, 24					; 00000018H
	mov	DWORD PTR tv67[ebp], ecx
	cmp	DWORD PTR tv67[ebp], 7
	ja	$LN2@asUInt
	mov	edx, DWORD PTR tv67[ebp]
	jmp	DWORD PTR $LN21@asUInt[edx*4]
$LN11@asUInt:

; 770  :    {
; 771  :    case nullValue:
; 772  :       return 0;

	xor	eax, eax
	jmp	$LN14@asUInt
$LN10@asUInt:

; 773  :    case intValue:
; 774  :       JSON_ASSERT_MESSAGE( value_.int_ >= 0, "Negative integer can not be converted to unsigned integer" );

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv140[ebp], eax
	mov	ecx, DWORD PTR tv140[ebp]
	cmp	DWORD PTR [ecx+4], 0
	jg	SHORT $LN9@asUInt
	jl	SHORT $LN19@asUInt
	mov	edx, DWORD PTR tv140[ebp]
	cmp	DWORD PTR [edx], 0
	jae	SHORT $LN9@asUInt
$LN19@asUInt:
	push	OFFSET ??_C@_0DK@NAHIGMFE@Negative?5integer?5can?5not?5be?5conv@
	lea	ecx, DWORD PTR $T31264[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR $T31264[ebp]
	push	eax
	lea	ecx, DWORD PTR $T31263[ebp]
	call	??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::runtime_error::runtime_error
	push	OFFSET __TI2?AVruntime_error@std@@
	lea	ecx, DWORD PTR $T31263[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T31264[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN9@asUInt:

; 775  :       return static_cast<Value::Int>(value_.int_);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	jmp	$LN14@asUInt
$LN8@asUInt:

; 776  :    case uintValue:
; 777  :       return static_cast<Value::Int>(value_.uint_);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]
	jmp	$LN14@asUInt
$LN7@asUInt:

; 778  :    case realValue:
; 779  :       JSON_ASSERT_MESSAGE( value_.real_ >= 0  &&  value_.real_ <= maxUInt,  "Real out of unsigned integer range" );

	mov	ecx, DWORD PTR _this$[ebp]
	fldz
	fcomp	QWORD PTR [ecx]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jp	SHORT $LN5@asUInt
	mov	edx, DWORD PTR _this$[ebp]
	fld	QWORD PTR __real@41efffffffe00000
	fcomp	QWORD PTR [edx]
	fnstsw	ax
	test	ah, 1
	je	SHORT $LN6@asUInt
$LN5@asUInt:
	push	OFFSET ??_C@_0CD@PGCLDEBG@Real?5out?5of?5unsigned?5integer?5ran@
	lea	ecx, DWORD PTR $T31266[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	lea	eax, DWORD PTR $T31266[ebp]
	push	eax
	lea	ecx, DWORD PTR $T31265[ebp]
	call	??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::runtime_error::runtime_error
	push	OFFSET __TI2?AVruntime_error@std@@
	lea	ecx, DWORD PTR $T31265[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T31266[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN6@asUInt:

; 780  :       return UInt( value_.real_ );

	mov	edx, DWORD PTR _this$[ebp]
	fld	QWORD PTR [edx]
	fnstcw	WORD PTR tv165[ebp]
	movzx	eax, WORD PTR tv165[ebp]
	or	eax, 3072				; 00000c00H
	mov	DWORD PTR tv168[ebp], eax
	fldcw	WORD PTR tv168[ebp]
	fistp	QWORD PTR tv170[ebp]
	fldcw	WORD PTR tv165[ebp]
	mov	eax, DWORD PTR tv170[ebp]
	jmp	SHORT $LN14@asUInt
$LN4@asUInt:

; 781  :    case booleanValue:
; 782  :       return value_.bool_ ? 1 : 0;

	mov	eax, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [eax]
	neg	eax
	sbb	eax, eax
	neg	eax
	jmp	SHORT $LN14@asUInt
$LN3@asUInt:

; 783  :    case stringValue:
; 784  :    case arrayValue:
; 785  :    case objectValue:
; 786  :       JSON_ASSERT_MESSAGE( false, "Type is not convertible to uint" );

	mov	ecx, 1
	test	ecx, ecx
	je	SHORT $LN2@asUInt
	push	OFFSET ??_C@_0CA@LEFAEJPN@Type?5is?5not?5convertible?5to?5uint?$AA@
	lea	ecx, DWORD PTR $T31268[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 2
	lea	edx, DWORD PTR $T31268[ebp]
	push	edx
	lea	ecx, DWORD PTR $T31267[ebp]
	call	??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::runtime_error::runtime_error
	push	OFFSET __TI2?AVruntime_error@std@@
	lea	eax, DWORD PTR $T31267[ebp]
	push	eax
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T31268[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@asUInt:

; 787  :    default:
; 788  :       JSON_ASSERT_UNREACHABLE;
; 789  :    }
; 790  :    return 0; // unreachable;

	xor	eax, eax
$LN14@asUInt:

; 791  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN21@asUInt:
	DD	$LN11@asUInt
	DD	$LN10@asUInt
	DD	$LN8@asUInt
	DD	$LN7@asUInt
	DD	$LN3@asUInt
	DD	$LN4@asUInt
	DD	$LN3@asUInt
	DD	$LN3@asUInt
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?asUInt@Value@Json@@QBEIXZ$0:
	lea	ecx, DWORD PTR $T31264[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?asUInt@Value@Json@@QBEIXZ$1:
	lea	ecx, DWORD PTR $T31266[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?asUInt@Value@Json@@QBEIXZ$2:
	lea	ecx, DWORD PTR $T31268[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?asUInt@Value@Json@@QBEIXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-236]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?asUInt@Value@Json@@QBEIXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?asUInt@Value@Json@@QBEIXZ ENDP				; Json::Value::asUInt
PUBLIC	?asInt64@Value@Json@@QBE_JXZ			; Json::Value::asInt64
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?asInt64@Value@Json@@QBE_JXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?asInt64@Value@Json@@QBE_JXZ$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?asInt64@Value@Json@@QBE_JXZ$1
__ehfuncinfo$?asInt64@Value@Json@@QBE_JXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?asInt64@Value@Json@@QBE_JXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?asInt64@Value@Json@@QBE_JXZ
_TEXT	SEGMENT
tv158 = -172						; size = 8
tv156 = -164						; size = 4
tv153 = -158						; size = 2
tv67 = -156						; size = 4
_this$ = -152						; size = 4
$T31287 = -148						; size = 28
$T31286 = -120						; size = 40
$T31285 = -80						; size = 28
$T31284 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?asInt64@Value@Json@@QBE_JXZ PROC			; Json::Value::asInt64, COMDAT
; _this$ = ecx

; 794  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?asInt64@Value@Json@@QBE_JXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 160				; 000000a0H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 795  : 	switch ( type_ )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	shl	ecx, 24					; 00000018H
	sar	ecx, 24					; 00000018H
	mov	DWORD PTR tv67[ebp], ecx
	cmp	DWORD PTR tv67[ebp], 7
	ja	$LN2@asInt64
	mov	edx, DWORD PTR tv67[ebp]
	jmp	DWORD PTR $LN18@asInt64[edx*4]
$LN10@asInt64:

; 796  : 	{
; 797  : 	case nullValue:
; 798  : 		return 0;

	xor	eax, eax
	xor	edx, edx
	jmp	$LN13@asInt64
$LN9@asInt64:

; 799  : 	case intValue:
; 800  : 		return (value_.int_);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [ecx+4]
	jmp	$LN13@asInt64
$LN8@asInt64:

; 801  : 	case uintValue:
; 802  : 		return (value_.uint_);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	edx, DWORD PTR [edx+4]
	jmp	$LN13@asInt64
$LN7@asInt64:

; 803  : 	case realValue:
; 804  : 		JSON_ASSERT_MESSAGE( value_.real_ >= 0  &&  value_.real_ <= maxUInt,  "Real out of unsigned integer range" );

	mov	eax, DWORD PTR _this$[ebp]
	fldz
	fcomp	QWORD PTR [eax]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jp	SHORT $LN5@asInt64
	mov	ecx, DWORD PTR _this$[ebp]
	fld	QWORD PTR __real@41efffffffe00000
	fcomp	QWORD PTR [ecx]
	fnstsw	ax
	test	ah, 1
	je	SHORT $LN6@asInt64
$LN5@asInt64:
	push	OFFSET ??_C@_0CD@PGCLDEBG@Real?5out?5of?5unsigned?5integer?5ran@
	lea	ecx, DWORD PTR $T31285[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	edx, DWORD PTR $T31285[ebp]
	push	edx
	lea	ecx, DWORD PTR $T31284[ebp]
	call	??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::runtime_error::runtime_error
	push	OFFSET __TI2?AVruntime_error@std@@
	lea	eax, DWORD PTR $T31284[ebp]
	push	eax
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T31285[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN6@asInt64:

; 805  : 		return UInt( value_.real_ );

	mov	ecx, DWORD PTR _this$[ebp]
	fld	QWORD PTR [ecx]
	fnstcw	WORD PTR tv153[ebp]
	movzx	eax, WORD PTR tv153[ebp]
	or	eax, 3072				; 00000c00H
	mov	DWORD PTR tv156[ebp], eax
	fldcw	WORD PTR tv156[ebp]
	fistp	QWORD PTR tv158[ebp]
	fldcw	WORD PTR tv153[ebp]
	mov	eax, DWORD PTR tv158[ebp]
	xor	edx, edx
	jmp	SHORT $LN13@asInt64
$LN4@asInt64:

; 806  : 	case booleanValue:
; 807  : 		return value_.bool_ ? 1 : 0;

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx]
	neg	eax
	sbb	eax, eax
	neg	eax
	cdq
	jmp	SHORT $LN13@asInt64
$LN3@asInt64:

; 808  : 	case stringValue:
; 809  : 	case arrayValue:
; 810  : 	case objectValue:
; 811  : 		JSON_ASSERT_MESSAGE( false, "Type is not convertible to uint" );

	mov	eax, 1
	test	eax, eax
	je	SHORT $LN2@asInt64
	push	OFFSET ??_C@_0CA@LEFAEJPN@Type?5is?5not?5convertible?5to?5uint?$AA@
	lea	ecx, DWORD PTR $T31287[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR $T31287[ebp]
	push	ecx
	lea	ecx, DWORD PTR $T31286[ebp]
	call	??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::runtime_error::runtime_error
	push	OFFSET __TI2?AVruntime_error@std@@
	lea	edx, DWORD PTR $T31286[ebp]
	push	edx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T31287[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@asInt64:

; 812  : 	default:
; 813  : 		JSON_ASSERT_UNREACHABLE;
; 814  : 	}
; 815  : 	return 0; // unreachable;

	xor	eax, eax
	xor	edx, edx
$LN13@asInt64:

; 816  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN18@asInt64:
	DD	$LN10@asInt64
	DD	$LN9@asInt64
	DD	$LN8@asInt64
	DD	$LN7@asInt64
	DD	$LN3@asInt64
	DD	$LN4@asInt64
	DD	$LN3@asInt64
	DD	$LN3@asInt64
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?asInt64@Value@Json@@QBE_JXZ$0:
	lea	ecx, DWORD PTR $T31285[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?asInt64@Value@Json@@QBE_JXZ$1:
	lea	ecx, DWORD PTR $T31287[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?asInt64@Value@Json@@QBE_JXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-164]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?asInt64@Value@Json@@QBE_JXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?asInt64@Value@Json@@QBE_JXZ ENDP			; Json::Value::asInt64
PUBLIC	?asUInt64@Value@Json@@QBE_KXZ			; Json::Value::asUInt64
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?asUInt64@Value@Json@@QBE_KXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?asUInt64@Value@Json@@QBE_KXZ$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?asUInt64@Value@Json@@QBE_KXZ$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?asUInt64@Value@Json@@QBE_KXZ$2
__ehfuncinfo$?asUInt64@Value@Json@@QBE_KXZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?asUInt64@Value@Json@@QBE_KXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?asUInt64@Value@Json@@QBE_KXZ
_TEXT	SEGMENT
tv175 = -244						; size = 8
tv173 = -236						; size = 4
tv170 = -230						; size = 2
tv141 = -228						; size = 4
tv67 = -224						; size = 4
_this$ = -220						; size = 4
$T31304 = -216						; size = 28
$T31303 = -188						; size = 40
$T31302 = -148						; size = 28
$T31301 = -120						; size = 40
$T31300 = -80						; size = 28
$T31299 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?asUInt64@Value@Json@@QBE_KXZ PROC			; Json::Value::asUInt64, COMDAT
; _this$ = ecx

; 819  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?asUInt64@Value@Json@@QBE_KXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 232				; 000000e8H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 820  : 	switch ( type_ )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	shl	ecx, 24					; 00000018H
	sar	ecx, 24					; 00000018H
	mov	DWORD PTR tv67[ebp], ecx
	cmp	DWORD PTR tv67[ebp], 7
	ja	$LN2@asUInt64
	mov	edx, DWORD PTR tv67[ebp]
	jmp	DWORD PTR $LN21@asUInt64[edx*4]
$LN11@asUInt64:

; 821  : 	{
; 822  : 	case nullValue:
; 823  : 		return 0;

	xor	eax, eax
	xor	edx, edx
	jmp	$LN14@asUInt64
$LN10@asUInt64:

; 824  : 	case intValue:
; 825  : 		JSON_ASSERT_MESSAGE( value_.int_ >= 0, "Negative integer can not be converted to unsigned integer" );

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv141[ebp], eax
	mov	ecx, DWORD PTR tv141[ebp]
	cmp	DWORD PTR [ecx+4], 0
	jg	SHORT $LN9@asUInt64
	jl	SHORT $LN19@asUInt64
	mov	edx, DWORD PTR tv141[ebp]
	cmp	DWORD PTR [edx], 0
	jae	SHORT $LN9@asUInt64
$LN19@asUInt64:
	push	OFFSET ??_C@_0DK@NAHIGMFE@Negative?5integer?5can?5not?5be?5conv@
	lea	ecx, DWORD PTR $T31300[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR $T31300[ebp]
	push	eax
	lea	ecx, DWORD PTR $T31299[ebp]
	call	??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::runtime_error::runtime_error
	push	OFFSET __TI2?AVruntime_error@std@@
	lea	ecx, DWORD PTR $T31299[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T31300[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN9@asUInt64:

; 826  : 		return (value_.int_);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	edx, DWORD PTR [edx+4]
	jmp	$LN14@asUInt64
$LN8@asUInt64:

; 827  : 	case uintValue:
; 828  : 		return (value_.uint_);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [ecx+4]
	jmp	$LN14@asUInt64
$LN7@asUInt64:

; 829  : 	case realValue:
; 830  : 		JSON_ASSERT_MESSAGE( value_.real_ >= 0  &&  value_.real_ <= maxUInt,  "Real out of unsigned integer range" );

	mov	edx, DWORD PTR _this$[ebp]
	fldz
	fcomp	QWORD PTR [edx]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jp	SHORT $LN5@asUInt64
	mov	eax, DWORD PTR _this$[ebp]
	fld	QWORD PTR __real@41efffffffe00000
	fcomp	QWORD PTR [eax]
	fnstsw	ax
	test	ah, 1
	je	SHORT $LN6@asUInt64
$LN5@asUInt64:
	push	OFFSET ??_C@_0CD@PGCLDEBG@Real?5out?5of?5unsigned?5integer?5ran@
	lea	ecx, DWORD PTR $T31302[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR $T31302[ebp]
	push	ecx
	lea	ecx, DWORD PTR $T31301[ebp]
	call	??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::runtime_error::runtime_error
	push	OFFSET __TI2?AVruntime_error@std@@
	lea	edx, DWORD PTR $T31301[ebp]
	push	edx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T31302[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN6@asUInt64:

; 831  : 		return UInt( value_.real_ );

	mov	eax, DWORD PTR _this$[ebp]
	fld	QWORD PTR [eax]
	fnstcw	WORD PTR tv170[ebp]
	movzx	eax, WORD PTR tv170[ebp]
	or	eax, 3072				; 00000c00H
	mov	DWORD PTR tv173[ebp], eax
	fldcw	WORD PTR tv173[ebp]
	fistp	QWORD PTR tv175[ebp]
	fldcw	WORD PTR tv170[ebp]
	mov	eax, DWORD PTR tv175[ebp]
	xor	edx, edx
	jmp	SHORT $LN14@asUInt64
$LN4@asUInt64:

; 832  : 	case booleanValue:
; 833  : 		return value_.bool_ ? 1 : 0;

	mov	ecx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [ecx]
	neg	eax
	sbb	eax, eax
	neg	eax
	cdq
	jmp	SHORT $LN14@asUInt64
$LN3@asUInt64:

; 834  : 	case stringValue:
; 835  : 	case arrayValue:
; 836  : 	case objectValue:
; 837  : 		JSON_ASSERT_MESSAGE( false, "Type is not convertible to uint" );

	mov	edx, 1
	test	edx, edx
	je	SHORT $LN2@asUInt64
	push	OFFSET ??_C@_0CA@LEFAEJPN@Type?5is?5not?5convertible?5to?5uint?$AA@
	lea	ecx, DWORD PTR $T31304[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 2
	lea	eax, DWORD PTR $T31304[ebp]
	push	eax
	lea	ecx, DWORD PTR $T31303[ebp]
	call	??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::runtime_error::runtime_error
	push	OFFSET __TI2?AVruntime_error@std@@
	lea	ecx, DWORD PTR $T31303[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T31304[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@asUInt64:

; 838  : 	default:
; 839  : 		JSON_ASSERT_UNREACHABLE;
; 840  : 	}
; 841  : 	return 0; // unreachable;

	xor	eax, eax
	xor	edx, edx
$LN14@asUInt64:

; 842  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN21@asUInt64:
	DD	$LN11@asUInt64
	DD	$LN10@asUInt64
	DD	$LN8@asUInt64
	DD	$LN7@asUInt64
	DD	$LN3@asUInt64
	DD	$LN4@asUInt64
	DD	$LN3@asUInt64
	DD	$LN3@asUInt64
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?asUInt64@Value@Json@@QBE_KXZ$0:
	lea	ecx, DWORD PTR $T31300[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?asUInt64@Value@Json@@QBE_KXZ$1:
	lea	ecx, DWORD PTR $T31302[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?asUInt64@Value@Json@@QBE_KXZ$2:
	lea	ecx, DWORD PTR $T31304[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?asUInt64@Value@Json@@QBE_KXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-236]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?asUInt64@Value@Json@@QBE_KXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?asUInt64@Value@Json@@QBE_KXZ ENDP			; Json::Value::asUInt64
PUBLIC	??_C@_0CC@ICOHKFIF@Type?5is?5not?5convertible?5to?5doubl@ ; `string'
PUBLIC	__real@3ff0000000000000
PUBLIC	?asDouble@Value@Json@@QBENXZ			; Json::Value::asDouble
;	COMDAT ??_C@_0CC@ICOHKFIF@Type?5is?5not?5convertible?5to?5doubl@
CONST	SEGMENT
??_C@_0CC@ICOHKFIF@Type?5is?5not?5convertible?5to?5doubl@ DB 'Type is not'
	DB	' convertible to double', 00H		; `string'
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?asDouble@Value@Json@@QBENXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?asDouble@Value@Json@@QBENXZ$0
__ehfuncinfo$?asDouble@Value@Json@@QBENXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?asDouble@Value@Json@@QBENXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?asDouble@Value@Json@@QBENXZ
_TEXT	SEGMENT
tv74 = -104						; size = 8
tv93 = -96						; size = 4
tv90 = -92						; size = 4
tv67 = -88						; size = 4
_this$ = -84						; size = 4
$T31321 = -80						; size = 28
$T31320 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?asDouble@Value@Json@@QBENXZ PROC			; Json::Value::asDouble, COMDAT
; _this$ = ecx

; 846  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?asDouble@Value@Json@@QBENXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 92					; 0000005cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 847  :    switch ( type_ )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	shl	ecx, 24					; 00000018H
	sar	ecx, 24					; 00000018H
	mov	DWORD PTR tv67[ebp], ecx
	cmp	DWORD PTR tv67[ebp], 7
	ja	$LN2@asDouble
	mov	edx, DWORD PTR tv67[ebp]
	jmp	DWORD PTR $LN17@asDouble[edx*4]
$LN8@asDouble:

; 848  :    {
; 849  :    case nullValue:
; 850  :       return 0.0;

	fldz
	jmp	$LN11@asDouble
$LN7@asDouble:

; 851  :    case intValue:
; 852  :       return static_cast<Value::Int>(value_.int_);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv90[ebp], ecx
	fild	DWORD PTR tv90[ebp]
	jmp	SHORT $LN11@asDouble
$LN6@asDouble:

; 853  :    case uintValue:
; 854  :       return static_cast<Value::Int>(value_.uint_);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR tv93[ebp], eax
	fild	DWORD PTR tv93[ebp]
	jmp	SHORT $LN11@asDouble
$LN5@asDouble:

; 855  :    case realValue:
; 856  :       return value_.real_;

	mov	ecx, DWORD PTR _this$[ebp]
	fld	QWORD PTR [ecx]
	jmp	SHORT $LN11@asDouble
$LN4@asDouble:

; 857  :    case booleanValue:
; 858  :       return value_.bool_ ? 1.0 : 0.0;

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx]
	test	eax, eax
	je	SHORT $LN13@asDouble
	fld1
	fstp	QWORD PTR tv74[ebp]
	jmp	SHORT $LN14@asDouble
$LN13@asDouble:
	fldz
	fstp	QWORD PTR tv74[ebp]
$LN14@asDouble:
	fld	QWORD PTR tv74[ebp]
	jmp	SHORT $LN11@asDouble
$LN3@asDouble:

; 859  :    case stringValue:
; 860  :    case arrayValue:
; 861  :    case objectValue:
; 862  :       JSON_ASSERT_MESSAGE( false, "Type is not convertible to double" );

	mov	ecx, 1
	test	ecx, ecx
	je	SHORT $LN2@asDouble
	push	OFFSET ??_C@_0CC@ICOHKFIF@Type?5is?5not?5convertible?5to?5doubl@
	lea	ecx, DWORD PTR $T31321[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	edx, DWORD PTR $T31321[ebp]
	push	edx
	lea	ecx, DWORD PTR $T31320[ebp]
	call	??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::runtime_error::runtime_error
	push	OFFSET __TI2?AVruntime_error@std@@
	lea	eax, DWORD PTR $T31320[ebp]
	push	eax
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T31321[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@asDouble:

; 863  :    default:
; 864  :       JSON_ASSERT_UNREACHABLE;
; 865  :    }
; 866  :    return 0; // unreachable;

	fldz
$LN11@asDouble:

; 867  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN17@asDouble:
	DD	$LN8@asDouble
	DD	$LN7@asDouble
	DD	$LN6@asDouble
	DD	$LN5@asDouble
	DD	$LN3@asDouble
	DD	$LN4@asDouble
	DD	$LN3@asDouble
	DD	$LN3@asDouble
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?asDouble@Value@Json@@QBENXZ$0:
	lea	ecx, DWORD PTR $T31321[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?asDouble@Value@Json@@QBENXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-96]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?asDouble@Value@Json@@QBENXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?asDouble@Value@Json@@QBENXZ ENDP			; Json::Value::asDouble
PUBLIC	?asBool@Value@Json@@QBE_NXZ			; Json::Value::asBool
; Function compile flags: /Odtp
;	COMDAT ?asBool@Value@Json@@QBE_NXZ
_TEXT	SEGMENT
tv78 = -24						; size = 4
tv72 = -20						; size = 4
tv69 = -16						; size = 4
tv91 = -12						; size = 4
tv67 = -8						; size = 4
_this$ = -4						; size = 4
?asBool@Value@Json@@QBE_NXZ PROC			; Json::Value::asBool, COMDAT
; _this$ = ecx

; 871  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 872  :    switch ( type_ )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	shl	ecx, 24					; 00000018H
	sar	ecx, 24					; 00000018H
	mov	DWORD PTR tv67[ebp], ecx
	cmp	DWORD PTR tv67[ebp], 7
	ja	$LN1@asBool
	mov	edx, DWORD PTR tv67[ebp]
	jmp	DWORD PTR $LN18@asBool[edx*4]
$LN7@asBool:

; 873  :    {
; 874  :    case nullValue:
; 875  :       return false;

	xor	al, al
	jmp	$LN10@asBool
$LN6@asBool:

; 876  :    case intValue:
; 877  :    case uintValue:
; 878  :       return value_.int_ != 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv91[ebp], eax
	mov	ecx, DWORD PTR tv91[ebp]
	mov	edx, DWORD PTR tv91[ebp]
	mov	eax, DWORD PTR [ecx]
	or	eax, DWORD PTR [edx+4]
	je	SHORT $LN12@asBool
	mov	DWORD PTR tv69[ebp], 1
	jmp	SHORT $LN13@asBool
$LN12@asBool:
	mov	DWORD PTR tv69[ebp], 0
$LN13@asBool:
	mov	al, BYTE PTR tv69[ebp]
	jmp	SHORT $LN10@asBool
$LN5@asBool:

; 879  :    case realValue:
; 880  :       return value_.real_ != 0.0;

	mov	ecx, DWORD PTR _this$[ebp]
	fldz
	fcomp	QWORD PTR [ecx]
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	SHORT $LN14@asBool
	mov	DWORD PTR tv72[ebp], 1
	jmp	SHORT $LN15@asBool
$LN14@asBool:
	mov	DWORD PTR tv72[ebp], 0
$LN15@asBool:
	mov	al, BYTE PTR tv72[ebp]
	jmp	SHORT $LN10@asBool
$LN4@asBool:

; 881  :    case booleanValue:
; 882  :       return value_.bool_;

	mov	edx, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edx]
	jmp	SHORT $LN10@asBool
$LN3@asBool:

; 883  :    case stringValue:
; 884  :       return value_.string_  &&  value_.string_[0] != 0;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN16@asBool
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	je	SHORT $LN16@asBool
	mov	DWORD PTR tv78[ebp], 1
	jmp	SHORT $LN17@asBool
$LN16@asBool:
	mov	DWORD PTR tv78[ebp], 0
$LN17@asBool:
	mov	al, BYTE PTR tv78[ebp]
	jmp	SHORT $LN10@asBool
$LN2@asBool:

; 885  :    case arrayValue:
; 886  :    case objectValue:
; 887  :       return value_.map_->size() != 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?size@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::size
	neg	eax
	sbb	eax, eax
	neg	eax
	jmp	SHORT $LN10@asBool
$LN1@asBool:

; 888  :    default:
; 889  :       JSON_ASSERT_UNREACHABLE;
; 890  :    }
; 891  :    return false; // unreachable;

	xor	al, al
$LN10@asBool:

; 892  : }

	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN18@asBool:
	DD	$LN7@asBool
	DD	$LN6@asBool
	DD	$LN6@asBool
	DD	$LN5@asBool
	DD	$LN3@asBool
	DD	$LN4@asBool
	DD	$LN2@asBool
	DD	$LN2@asBool
?asBool@Value@Json@@QBE_NXZ ENDP			; Json::Value::asBool
_TEXT	ENDS
PUBLIC	?isConvertibleTo@Value@Json@@QBE_NW4ValueType@2@@Z ; Json::Value::isConvertibleTo
; Function compile flags: /Odtp
;	COMDAT ?isConvertibleTo@Value@Json@@QBE_NW4ValueType@2@@Z
_TEXT	SEGMENT
tv163 = -52						; size = 4
tv156 = -48						; size = 4
tv149 = -44						; size = 4
tv141 = -40						; size = 4
tv131 = -36						; size = 4
tv86 = -32						; size = 4
tv192 = -28						; size = 4
tv185 = -24						; size = 4
tv76 = -20						; size = 4
tv178 = -16						; size = 4
tv171 = -12						; size = 4
tv67 = -8						; size = 4
_this$ = -4						; size = 4
_other$ = 8						; size = 4
?isConvertibleTo@Value@Json@@QBE_NW4ValueType@2@@Z PROC	; Json::Value::isConvertibleTo, COMDAT
; _this$ = ecx

; 897  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H
	mov	DWORD PTR _this$[ebp], ecx

; 898  :    switch ( type_ )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	shl	ecx, 24					; 00000018H
	sar	ecx, 24					; 00000018H
	mov	DWORD PTR tv67[ebp], ecx
	cmp	DWORD PTR tv67[ebp], 7
	ja	$LN1@isConverti
	mov	edx, DWORD PTR tv67[ebp]
	jmp	DWORD PTR $LN42@isConverti[edx*4]
$LN9@isConverti:

; 899  :    {
; 900  :    case nullValue:
; 901  :       return true;

	mov	al, 1
	jmp	$LN12@isConverti
$LN8@isConverti:

; 902  :    case intValue:
; 903  :       return ( other == nullValue  &&  value_.int_ == 0 )
; 904  :              || other == intValue
; 905  :              || ( other == uintValue  && value_.int_ >= 0 )
; 906  :              || other == realValue
; 907  :              || other == stringValue
; 908  :              || other == booleanValue;

	cmp	DWORD PTR _other$[ebp], 0
	jne	SHORT $LN14@isConverti
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv171[ebp], eax
	mov	ecx, DWORD PTR tv171[ebp]
	mov	edx, DWORD PTR tv171[ebp]
	mov	eax, DWORD PTR [ecx]
	or	eax, DWORD PTR [edx+4]
	je	SHORT $LN15@isConverti
$LN14@isConverti:
	cmp	DWORD PTR _other$[ebp], 1
	je	SHORT $LN15@isConverti
	cmp	DWORD PTR _other$[ebp], 2
	jne	SHORT $LN40@isConverti
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv178[ebp], ecx
	mov	edx, DWORD PTR tv178[ebp]
	cmp	DWORD PTR [edx+4], 0
	jg	SHORT $LN15@isConverti
	jl	SHORT $LN40@isConverti
	mov	eax, DWORD PTR tv178[ebp]
	cmp	DWORD PTR [eax], 0
	jae	SHORT $LN15@isConverti
$LN40@isConverti:
	cmp	DWORD PTR _other$[ebp], 3
	je	SHORT $LN15@isConverti
	cmp	DWORD PTR _other$[ebp], 4
	je	SHORT $LN15@isConverti
	cmp	DWORD PTR _other$[ebp], 5
	je	SHORT $LN15@isConverti
	mov	DWORD PTR tv76[ebp], 0
	jmp	SHORT $LN17@isConverti
$LN15@isConverti:
	mov	DWORD PTR tv76[ebp], 1
$LN17@isConverti:
	mov	al, BYTE PTR tv76[ebp]
	jmp	$LN12@isConverti
$LN7@isConverti:

; 909  :    case uintValue:
; 910  :       return ( other == nullValue  &&  value_.uint_ == 0 )
; 911  :              || ( other == intValue  && value_.uint_ <= (unsigned)maxInt )
; 912  :              || other == uintValue
; 913  :              || other == realValue
; 914  :              || other == stringValue
; 915  :              || other == booleanValue;

	cmp	DWORD PTR _other$[ebp], 0
	jne	SHORT $LN18@isConverti
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv185[ebp], ecx
	mov	edx, DWORD PTR tv185[ebp]
	mov	eax, DWORD PTR tv185[ebp]
	mov	ecx, DWORD PTR [edx]
	or	ecx, DWORD PTR [eax+4]
	je	SHORT $LN20@isConverti
$LN18@isConverti:
	cmp	DWORD PTR _other$[ebp], 1
	jne	SHORT $LN41@isConverti
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR tv192[ebp], edx
	mov	eax, DWORD PTR tv192[ebp]
	cmp	DWORD PTR [eax+4], 0
	ja	SHORT $LN41@isConverti
	mov	ecx, DWORD PTR tv192[ebp]
	cmp	DWORD PTR [ecx], 2147483647		; 7fffffffH
	jbe	SHORT $LN20@isConverti
$LN41@isConverti:
	cmp	DWORD PTR _other$[ebp], 2
	je	SHORT $LN20@isConverti
	cmp	DWORD PTR _other$[ebp], 3
	je	SHORT $LN20@isConverti
	cmp	DWORD PTR _other$[ebp], 4
	je	SHORT $LN20@isConverti
	cmp	DWORD PTR _other$[ebp], 5
	je	SHORT $LN20@isConverti
	mov	DWORD PTR tv86[ebp], 0
	jmp	SHORT $LN21@isConverti
$LN20@isConverti:
	mov	DWORD PTR tv86[ebp], 1
$LN21@isConverti:
	mov	al, BYTE PTR tv86[ebp]
	jmp	$LN12@isConverti
$LN6@isConverti:

; 916  :    case realValue:
; 917  :       return ( other == nullValue  &&  value_.real_ == 0.0 )
; 918  :              || ( other == intValue  &&  value_.real_ >= minInt  &&  value_.real_ <= maxInt )
; 919  :              || ( other == uintValue  &&  value_.real_ >= 0  &&  value_.real_ <= maxUInt )
; 920  :              || other == realValue
; 921  :              || other == stringValue
; 922  :              || other == booleanValue;

	cmp	DWORD PTR _other$[ebp], 0
	jne	SHORT $LN22@isConverti
	mov	edx, DWORD PTR _this$[ebp]
	fldz
	fcomp	QWORD PTR [edx]
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	SHORT $LN24@isConverti
$LN22@isConverti:
	cmp	DWORD PTR _other$[ebp], 1
	jne	SHORT $LN23@isConverti
	mov	eax, DWORD PTR _this$[ebp]
	fld	QWORD PTR __real@c1e0000000000000
	fcomp	QWORD PTR [eax]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jp	SHORT $LN23@isConverti
	mov	ecx, DWORD PTR _this$[ebp]
	fld	QWORD PTR __real@41dfffffffc00000
	fcomp	QWORD PTR [ecx]
	fnstsw	ax
	test	ah, 1
	je	SHORT $LN24@isConverti
$LN23@isConverti:
	cmp	DWORD PTR _other$[ebp], 2
	jne	SHORT $LN25@isConverti
	mov	edx, DWORD PTR _this$[ebp]
	fldz
	fcomp	QWORD PTR [edx]
	fnstsw	ax
	test	ah, 65					; 00000041H
	jp	SHORT $LN25@isConverti
	mov	eax, DWORD PTR _this$[ebp]
	fld	QWORD PTR __real@41efffffffe00000
	fcomp	QWORD PTR [eax]
	fnstsw	ax
	test	ah, 1
	je	SHORT $LN24@isConverti
$LN25@isConverti:
	cmp	DWORD PTR _other$[ebp], 3
	je	SHORT $LN24@isConverti
	cmp	DWORD PTR _other$[ebp], 4
	je	SHORT $LN24@isConverti
	cmp	DWORD PTR _other$[ebp], 5
	je	SHORT $LN24@isConverti
	mov	DWORD PTR tv131[ebp], 0
	jmp	SHORT $LN26@isConverti
$LN24@isConverti:
	mov	DWORD PTR tv131[ebp], 1
$LN26@isConverti:
	mov	al, BYTE PTR tv131[ebp]
	jmp	$LN12@isConverti
$LN5@isConverti:

; 923  :    case booleanValue:
; 924  :       return ( other == nullValue  &&  value_.bool_ == false )
; 925  :              || other == intValue
; 926  :              || other == uintValue
; 927  :              || other == realValue
; 928  :              || other == stringValue
; 929  :              || other == booleanValue;

	cmp	DWORD PTR _other$[ebp], 0
	jne	SHORT $LN27@isConverti
	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	SHORT $LN28@isConverti
$LN27@isConverti:
	cmp	DWORD PTR _other$[ebp], 1
	je	SHORT $LN28@isConverti
	cmp	DWORD PTR _other$[ebp], 2
	je	SHORT $LN28@isConverti
	cmp	DWORD PTR _other$[ebp], 3
	je	SHORT $LN28@isConverti
	cmp	DWORD PTR _other$[ebp], 4
	je	SHORT $LN28@isConverti
	cmp	DWORD PTR _other$[ebp], 5
	je	SHORT $LN28@isConverti
	mov	DWORD PTR tv141[ebp], 0
	jmp	SHORT $LN29@isConverti
$LN28@isConverti:
	mov	DWORD PTR tv141[ebp], 1
$LN29@isConverti:
	mov	al, BYTE PTR tv141[ebp]
	jmp	$LN12@isConverti
$LN4@isConverti:

; 930  :    case stringValue:
; 931  :       return other == stringValue
; 932  :              || ( other == nullValue  &&  (!value_.string_  ||  value_.string_[0] == 0) );

	cmp	DWORD PTR _other$[ebp], 4
	je	SHORT $LN32@isConverti
	cmp	DWORD PTR _other$[ebp], 0
	jne	SHORT $LN31@isConverti
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN32@isConverti
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	je	SHORT $LN32@isConverti
$LN31@isConverti:
	mov	DWORD PTR tv149[ebp], 0
	jmp	SHORT $LN33@isConverti
$LN32@isConverti:
	mov	DWORD PTR tv149[ebp], 1
$LN33@isConverti:
	mov	al, BYTE PTR tv149[ebp]
	jmp	SHORT $LN12@isConverti
$LN3@isConverti:

; 933  :    case arrayValue:
; 934  :       return other == arrayValue
; 935  :              ||  ( other == nullValue  &&  value_.map_->size() == 0 );

	cmp	DWORD PTR _other$[ebp], 6
	je	SHORT $LN35@isConverti
	cmp	DWORD PTR _other$[ebp], 0
	jne	SHORT $LN34@isConverti
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?size@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::size
	test	eax, eax
	je	SHORT $LN35@isConverti
$LN34@isConverti:
	mov	DWORD PTR tv156[ebp], 0
	jmp	SHORT $LN36@isConverti
$LN35@isConverti:
	mov	DWORD PTR tv156[ebp], 1
$LN36@isConverti:
	mov	al, BYTE PTR tv156[ebp]
	jmp	SHORT $LN12@isConverti
$LN2@isConverti:

; 936  :    case objectValue:
; 937  :       return other == objectValue
; 938  :              ||  ( other == nullValue  &&  value_.map_->size() == 0 );

	cmp	DWORD PTR _other$[ebp], 7
	je	SHORT $LN38@isConverti
	cmp	DWORD PTR _other$[ebp], 0
	jne	SHORT $LN37@isConverti
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?size@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::size
	test	eax, eax
	je	SHORT $LN38@isConverti
$LN37@isConverti:
	mov	DWORD PTR tv163[ebp], 0
	jmp	SHORT $LN39@isConverti
$LN38@isConverti:
	mov	DWORD PTR tv163[ebp], 1
$LN39@isConverti:
	mov	al, BYTE PTR tv163[ebp]
	jmp	SHORT $LN12@isConverti
$LN1@isConverti:

; 939  :    default:
; 940  :       JSON_ASSERT_UNREACHABLE;
; 941  :    }
; 942  :    return false; // unreachable;

	xor	al, al
$LN12@isConverti:

; 943  : }

	mov	esp, ebp
	pop	ebp
	ret	4
	npad	1
$LN42@isConverti:
	DD	$LN9@isConverti
	DD	$LN8@isConverti
	DD	$LN7@isConverti
	DD	$LN6@isConverti
	DD	$LN4@isConverti
	DD	$LN5@isConverti
	DD	$LN3@isConverti
	DD	$LN2@isConverti
?isConvertibleTo@Value@Json@@QBE_NW4ValueType@2@@Z ENDP	; Json::Value::isConvertibleTo
_TEXT	ENDS
PUBLIC	??Dconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBEABU?$pair@$$CBVCZString@Value@Json@@V23@@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator::operator*
PUBLIC	??Fconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator::operator--
PUBLIC	?end@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::end
PUBLIC	?empty@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBE_NXZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::empty
PUBLIC	?size@Value@Json@@QBEIXZ			; Json::Value::size
; Function compile flags: /Odtp
;	COMDAT ?size@Value@Json@@QBEIXZ
_TEXT	SEGMENT
tv67 = -24						; size = 4
_this$ = -20						; size = 4
$T31374 = -16						; size = 8
_itLast$21520 = -8					; size = 8
?size@Value@Json@@QBEIXZ PROC				; Json::Value::size, COMDAT
; _this$ = ecx

; 949  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 950  :    switch ( type_ )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	shl	ecx, 24					; 00000018H
	sar	ecx, 24					; 00000018H
	mov	DWORD PTR tv67[ebp], ecx
	cmp	DWORD PTR tv67[ebp], 7
	ja	SHORT $LN6@size
	mov	edx, DWORD PTR tv67[ebp]
	jmp	DWORD PTR $LN10@size[edx*4]
$LN5@size:

; 951  :    {
; 952  :    case nullValue:
; 953  :    case intValue:
; 954  :    case uintValue:
; 955  :    case realValue:
; 956  :    case booleanValue:
; 957  :    case stringValue:
; 958  :       return 0;

	xor	eax, eax
	jmp	SHORT $LN8@size
$LN4@size:

; 959  : #ifndef JSON_VALUE_USE_INTERNAL_MAP
; 960  :    case arrayValue:  // size of the array is highest index + 1
; 961  :       if ( !value_.map_->empty() )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?empty@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBE_NXZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::empty
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN3@size

; 962  :       {
; 963  :          ObjectValues::const_iterator itLast = value_.map_->end();

	lea	edx, DWORD PTR $T31374[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?end@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::end
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _itLast$21520[ebp], ecx
	mov	DWORD PTR _itLast$21520[ebp+4], edx

; 964  :          --itLast;

	lea	ecx, DWORD PTR _itLast$21520[ebp]
	call	??Fconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator::operator--

; 965  :          return (*itLast).first.index()+1;

	lea	ecx, DWORD PTR _itLast$21520[ebp]
	call	??Dconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBEABU?$pair@$$CBVCZString@Value@Json@@V23@@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator::operator*
	mov	ecx, eax
	call	?index@CZString@Value@Json@@QBEHXZ	; Json::Value::CZString::index
	add	eax, 1
	jmp	SHORT $LN8@size
$LN3@size:

; 966  :       }
; 967  :       return 0;

	xor	eax, eax
	jmp	SHORT $LN8@size
$LN2@size:

; 968  :    case objectValue:
; 969  :       return Int( value_.map_->size() );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?size@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::size
	jmp	SHORT $LN8@size
$LN6@size:

; 970  : #else
; 971  :    case arrayValue:
; 972  :       return Int( value_.array_->size() );
; 973  :    case objectValue:
; 974  :       return Int( value_.map_->size() );
; 975  : #endif
; 976  :    default:
; 977  :       JSON_ASSERT_UNREACHABLE;
; 978  :    }
; 979  :    return 0; // unreachable;

	xor	eax, eax
$LN8@size:

; 980  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN10@size:
	DD	$LN5@size
	DD	$LN5@size
	DD	$LN5@size
	DD	$LN5@size
	DD	$LN5@size
	DD	$LN5@size
	DD	$LN4@size
	DD	$LN2@size
?size@Value@Json@@QBEIXZ ENDP				; Json::Value::size
_TEXT	ENDS
PUBLIC	?isObject@Value@Json@@QBE_NXZ			; Json::Value::isObject
PUBLIC	?isArray@Value@Json@@QBE_NXZ			; Json::Value::isArray
PUBLIC	?isNull@Value@Json@@QBE_NXZ			; Json::Value::isNull
PUBLIC	?empty@Value@Json@@QBE_NXZ			; Json::Value::empty
; Function compile flags: /Odtp
;	COMDAT ?empty@Value@Json@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?empty@Value@Json@@QBE_NXZ PROC				; Json::Value::empty, COMDAT
; _this$ = ecx

; 985  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 986  :    if ( isNull() || isArray() || isObject() )

	mov	ecx, DWORD PTR _this$[ebp]
	call	?isNull@Value@Json@@QBE_NXZ		; Json::Value::isNull
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN2@empty
	mov	ecx, DWORD PTR _this$[ebp]
	call	?isArray@Value@Json@@QBE_NXZ		; Json::Value::isArray
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN2@empty
	mov	ecx, DWORD PTR _this$[ebp]
	call	?isObject@Value@Json@@QBE_NXZ		; Json::Value::isObject
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN3@empty
$LN2@empty:

; 987  :       return size() == 0u;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@Value@Json@@QBEIXZ		; Json::Value::size
	neg	eax
	sbb	eax, eax
	add	eax, 1
	jmp	SHORT $LN4@empty

; 988  :    else

	jmp	SHORT $LN4@empty
$LN3@empty:

; 989  :       return false;

	xor	al, al
$LN4@empty:

; 990  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?empty@Value@Json@@QBE_NXZ ENDP				; Json::Value::empty
_TEXT	ENDS
PUBLIC	??7Value@Json@@QBE_NXZ				; Json::Value::operator!
; Function compile flags: /Odtp
;	COMDAT ??7Value@Json@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??7Value@Json@@QBE_NXZ PROC				; Json::Value::operator!, COMDAT
; _this$ = ecx

; 995  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 996  :    return isNull();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?isNull@Value@Json@@QBE_NXZ		; Json::Value::isNull

; 997  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??7Value@Json@@QBE_NXZ ENDP				; Json::Value::operator!
_TEXT	ENDS
PUBLIC	?clear@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::clear
PUBLIC	?clear@Value@Json@@QAEXXZ			; Json::Value::clear
; Function compile flags: /Odtp
;	COMDAT ?clear@Value@Json@@QAEXXZ
_TEXT	SEGMENT
tv67 = -8						; size = 4
_this$ = -4						; size = 4
?clear@Value@Json@@QAEXXZ PROC				; Json::Value::clear, COMDAT
; _this$ = ecx

; 1002 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1003 :    JSON_ASSERT( type_ == nullValue  ||  type_ == arrayValue  || type_ == objectValue );
; 1004 : 
; 1005 :    switch ( type_ )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	shl	ecx, 24					; 00000018H
	sar	ecx, 24					; 00000018H
	mov	DWORD PTR tv67[ebp], ecx
	cmp	DWORD PTR tv67[ebp], 6
	jl	SHORT $LN5@clear
	cmp	DWORD PTR tv67[ebp], 7
	jle	SHORT $LN2@clear
	jmp	SHORT $LN5@clear
$LN2@clear:

; 1006 :    {
; 1007 : #ifndef JSON_VALUE_USE_INTERNAL_MAP
; 1008 :    case arrayValue:
; 1009 :    case objectValue:
; 1010 :       value_.map_->clear();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?clear@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::clear
$LN5@clear:

; 1011 :       break;
; 1012 : #else
; 1013 :    case arrayValue:
; 1014 :       value_.array_->clear();
; 1015 :       break;
; 1016 :    case objectValue:
; 1017 :       value_.map_->clear();
; 1018 :       break;
; 1019 : #endif
; 1020 :    default:
; 1021 :       break;
; 1022 :    }
; 1023 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?clear@Value@Json@@QAEXXZ ENDP				; Json::Value::clear
_TEXT	ENDS
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAEIABVCZString@Value@Json@@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::erase
PUBLIC	??AValue@Json@@QAEAAV01@I@Z			; Json::Value::operator[]
PUBLIC	?resize@Value@Json@@QAEXI@Z			; Json::Value::resize
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?resize@Value@Json@@QAEXI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?resize@Value@Json@@QAEXI@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?resize@Value@Json@@QAEXI@Z$1
__ehfuncinfo$?resize@Value@Json@@QAEXI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?resize@Value@Json@@QAEXI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?resize@Value@Json@@QAEXI@Z
_TEXT	SEGMENT
tv92 = -56						; size = 4
tv94 = -52						; size = 4
_this$ = -48						; size = 4
$T31385 = -44						; size = 8
$T31384 = -36						; size = 16
_index$21556 = -20					; size = 4
_oldSize$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_newSize$ = 8						; size = 4
?resize@Value@Json@@QAEXI@Z PROC			; Json::Value::resize, COMDAT
; _this$ = ecx

; 1027 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?resize@Value@Json@@QAEXI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 44					; 0000002cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1028 :    JSON_ASSERT( type_ == nullValue  ||  type_ == arrayValue );
; 1029 :    if ( type_ == nullValue )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	shl	ecx, 24					; 00000018H
	sar	ecx, 24					; 00000018H
	jne	SHORT $LN8@resize

; 1030 :       *this = Value( arrayValue );

	push	6
	lea	ecx, DWORD PTR $T31384[ebp]
	call	??0Value@Json@@QAE@W4ValueType@1@@Z	; Json::Value::Value
	mov	DWORD PTR tv94[ebp], eax
	mov	edx, DWORD PTR tv94[ebp]
	mov	DWORD PTR tv92[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR tv92[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4Value@Json@@QAEAAV01@ABV01@@Z	; Json::Value::operator=
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T31384[ebp]
	call	??1Value@Json@@QAE@XZ			; Json::Value::~Value
$LN8@resize:

; 1031 : #ifndef JSON_VALUE_USE_INTERNAL_MAP
; 1032 :    UInt oldSize = size();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@Value@Json@@QBEIXZ		; Json::Value::size
	mov	DWORD PTR _oldSize$[ebp], eax

; 1033 :    if ( newSize == 0 )

	cmp	DWORD PTR _newSize$[ebp], 0
	jne	SHORT $LN7@resize

; 1034 :       clear();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?clear@Value@Json@@QAEXXZ		; Json::Value::clear
	jmp	SHORT $LN9@resize
$LN7@resize:

; 1035 :    else if ( newSize > oldSize )

	mov	ecx, DWORD PTR _newSize$[ebp]
	cmp	ecx, DWORD PTR _oldSize$[ebp]
	jbe	SHORT $LN5@resize

; 1036 :       (*this)[ newSize - 1 ];

	mov	edx, DWORD PTR _newSize$[ebp]
	sub	edx, 1
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??AValue@Json@@QAEAAV01@I@Z		; Json::Value::operator[]

; 1037 :    else

	jmp	SHORT $LN9@resize
$LN5@resize:

; 1038 :    {
; 1039 :       for ( UInt index = newSize; index < oldSize; ++index )

	mov	eax, DWORD PTR _newSize$[ebp]
	mov	DWORD PTR _index$21556[ebp], eax
	jmp	SHORT $LN3@resize
$LN2@resize:
	mov	ecx, DWORD PTR _index$21556[ebp]
	add	ecx, 1
	mov	DWORD PTR _index$21556[ebp], ecx
$LN3@resize:
	mov	edx, DWORD PTR _index$21556[ebp]
	cmp	edx, DWORD PTR _oldSize$[ebp]
	jae	SHORT $LN9@resize

; 1040 :          value_.map_->erase( index );

	mov	eax, DWORD PTR _index$21556[ebp]
	push	eax
	lea	ecx, DWORD PTR $T31385[ebp]
	call	??0CZString@Value@Json@@QAE@H@Z		; Json::Value::CZString::CZString
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR $T31385[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?erase@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAEIABVCZString@Value@Json@@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::erase
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T31385[ebp]
	call	??1CZString@Value@Json@@QAE@XZ		; Json::Value::CZString::~CZString
	jmp	SHORT $LN2@resize
$LN9@resize:

; 1041 :       assert( size() == newSize );
; 1042 :    }
; 1043 : #else
; 1044 :    value_.array_->resize( newSize );
; 1045 : #endif
; 1046 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?resize@Value@Json@@QAEXI@Z$0:
	lea	ecx, DWORD PTR $T31384[ebp]
	jmp	??1Value@Json@@QAE@XZ			; Json::Value::~Value
__unwindfunclet$?resize@Value@Json@@QAEXI@Z$1:
	lea	ecx, DWORD PTR $T31385[ebp]
	jmp	??1CZString@Value@Json@@QAE@XZ		; Json::Value::CZString::~CZString
__ehhandler$?resize@Value@Json@@QAEXI@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-48]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?resize@Value@Json@@QAEXI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?resize@Value@Json@@QAEXI@Z ENDP			; Json::Value::resize
PUBLIC	??1?$pair@$$CBVCZString@Value@Json@@V23@@std@@QAE@XZ ; std::pair<Json::Value::CZString const ,Json::Value>::~pair<Json::Value::CZString const ,Json::Value>
PUBLIC	?insert@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@V312@ABU?$pair@$$CBVCZString@Value@Json@@V23@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::insert
PUBLIC	??0?$pair@$$CBVCZString@Value@Json@@V23@@std@@QAE@ABVCZString@Value@Json@@ABV34@@Z ; std::pair<Json::Value::CZString const ,Json::Value>::pair<Json::Value::CZString const ,Json::Value>
PUBLIC	?lower_bound@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@ABVCZString@Value@Json@@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::lower_bound
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??AValue@Json@@QAEAAV01@I@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??AValue@Json@@QAEAAV01@I@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??AValue@Json@@QAEAAV01@I@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??AValue@Json@@QAEAAV01@I@Z$2
__ehfuncinfo$??AValue@Json@@QAEAAV01@I@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??AValue@Json@@QAEAAV01@I@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??AValue@Json@@QAEAAV01@I@Z
_TEXT	SEGMENT
tv147 = -104						; size = 4
tv153 = -100						; size = 4
_this$ = -96						; size = 4
$T31400 = -92						; size = 4
$T31399 = -88						; size = 8
$T31398 = -80						; size = 4
$T31397 = -76						; size = 8
$T31396 = -68						; size = 16
_key$ = -52						; size = 8
_defaultValue$ = -44					; size = 24
_it$ = -20						; size = 8
__$EHRec$ = -12						; size = 12
_index$ = 8						; size = 4
??AValue@Json@@QAEAAV01@I@Z PROC			; Json::Value::operator[], COMDAT
; _this$ = ecx

; 1051 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??AValue@Json@@QAEAAV01@I@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 92					; 0000005cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1052 :    JSON_ASSERT( type_ == nullValue  ||  type_ == arrayValue );
; 1053 :    if ( type_ == nullValue )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	shl	ecx, 24					; 00000018H
	sar	ecx, 24					; 00000018H
	jne	SHORT $LN2@operator@5

; 1054 :       *this = Value( arrayValue );

	push	6
	lea	ecx, DWORD PTR $T31396[ebp]
	call	??0Value@Json@@QAE@W4ValueType@1@@Z	; Json::Value::Value
	mov	DWORD PTR tv153[ebp], eax
	mov	edx, DWORD PTR tv153[ebp]
	mov	DWORD PTR tv147[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR tv147[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4Value@Json@@QAEAAV01@ABV01@@Z	; Json::Value::operator=
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T31396[ebp]
	call	??1Value@Json@@QAE@XZ			; Json::Value::~Value
$LN2@operator@5:

; 1055 : #ifndef JSON_VALUE_USE_INTERNAL_MAP
; 1056 :    CZString key( index );

	mov	ecx, DWORD PTR _index$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _key$[ebp]
	call	??0CZString@Value@Json@@QAE@H@Z		; Json::Value::CZString::CZString
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 1057 :    ObjectValues::iterator it = value_.map_->lower_bound( key );

	lea	edx, DWORD PTR _key$[ebp]
	push	edx
	lea	eax, DWORD PTR _it$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?lower_bound@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@ABVCZString@Value@Json@@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::lower_bound

; 1058 :    if ( it != value_.map_->end()  &&  (*it).first == key )

	lea	edx, DWORD PTR $T31397[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?end@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::end
	push	eax
	lea	ecx, DWORD PTR _it$[ebp]
	call	??9const_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator::operator!=
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@operator@5
	lea	edx, DWORD PTR _key$[ebp]
	push	edx
	lea	ecx, DWORD PTR _it$[ebp]
	call	??Diterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBEAAU?$pair@$$CBVCZString@Value@Json@@V23@@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::iterator::operator*
	mov	ecx, eax
	call	??8CZString@Value@Json@@QBE_NABV012@@Z	; Json::Value::CZString::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@operator@5

; 1059 :       return (*it).second;

	lea	ecx, DWORD PTR _it$[ebp]
	call	??Diterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBEAAU?$pair@$$CBVCZString@Value@Json@@V23@@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::iterator::operator*
	add	eax, 8
	mov	DWORD PTR $T31398[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _key$[ebp]
	call	??1CZString@Value@Json@@QAE@XZ		; Json::Value::CZString::~CZString
	mov	eax, DWORD PTR $T31398[ebp]
	jmp	SHORT $LN3@operator@5
$LN1@operator@5:

; 1060 : 
; 1061 :    ObjectValues::value_type defaultValue( key, null );

	push	OFFSET ?null@Value@Json@@2V12@B		; Json::Value::null
	lea	ecx, DWORD PTR _key$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _defaultValue$[ebp]
	call	??0?$pair@$$CBVCZString@Value@Json@@V23@@std@@QAE@ABVCZString@Value@Json@@ABV34@@Z ; std::pair<Json::Value::CZString const ,Json::Value>::pair<Json::Value::CZString const ,Json::Value>
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 1062 :    it = value_.map_->insert( it, defaultValue );

	lea	edx, DWORD PTR _defaultValue$[ebp]
	push	edx
	mov	eax, DWORD PTR _it$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _it$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T31399[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?insert@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@V312@ABU?$pair@$$CBVCZString@Value@Json@@V23@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::insert
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _it$[ebp], ecx
	mov	DWORD PTR _it$[ebp+4], edx

; 1063 :    return (*it).second;

	lea	ecx, DWORD PTR _it$[ebp]
	call	??Diterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBEAAU?$pair@$$CBVCZString@Value@Json@@V23@@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::iterator::operator*
	add	eax, 8
	mov	DWORD PTR $T31400[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _defaultValue$[ebp]
	call	??1?$pair@$$CBVCZString@Value@Json@@V23@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _key$[ebp]
	call	??1CZString@Value@Json@@QAE@XZ		; Json::Value::CZString::~CZString
	mov	eax, DWORD PTR $T31400[ebp]
$LN3@operator@5:

; 1064 : #else
; 1065 :    return value_.array_->resolveReference( index );
; 1066 : #endif
; 1067 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??AValue@Json@@QAEAAV01@I@Z$0:
	lea	ecx, DWORD PTR $T31396[ebp]
	jmp	??1Value@Json@@QAE@XZ			; Json::Value::~Value
__unwindfunclet$??AValue@Json@@QAEAAV01@I@Z$1:
	lea	ecx, DWORD PTR _key$[ebp]
	jmp	??1CZString@Value@Json@@QAE@XZ		; Json::Value::CZString::~CZString
__unwindfunclet$??AValue@Json@@QAEAAV01@I@Z$2:
	lea	ecx, DWORD PTR _defaultValue$[ebp]
	jmp	??1?$pair@$$CBVCZString@Value@Json@@V23@@std@@QAE@XZ
__ehhandler$??AValue@Json@@QAEAAV01@I@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-96]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??AValue@Json@@QAEAAV01@I@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??AValue@Json@@QAEAAV01@I@Z ENDP			; Json::Value::operator[]
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$pair@$$CBVCZString@Value@Json@@V23@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$pair@$$CBVCZString@Value@Json@@V23@@std@@QAE@XZ$0
__ehfuncinfo$??1?$pair@$$CBVCZString@Value@Json@@V23@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$pair@$$CBVCZString@Value@Json@@V23@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$pair@$$CBVCZString@Value@Json@@V23@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$pair@$$CBVCZString@Value@Json@@V23@@std@@QAE@XZ PROC ; std::pair<Json::Value::CZString const ,Json::Value>::~pair<Json::Value::CZString const ,Json::Value>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$pair@$$CBVCZString@Value@Json@@V23@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??1Value@Json@@QAE@XZ			; Json::Value::~Value
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1CZString@Value@Json@@QAE@XZ		; Json::Value::CZString::~CZString
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$pair@$$CBVCZString@Value@Json@@V23@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1CZString@Value@Json@@QAE@XZ		; Json::Value::CZString::~CZString
__ehhandler$??1?$pair@$$CBVCZString@Value@Json@@V23@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$pair@$$CBVCZString@Value@Json@@V23@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$pair@$$CBVCZString@Value@Json@@V23@@std@@QAE@XZ ENDP ; std::pair<Json::Value::CZString const ,Json::Value>::~pair<Json::Value::CZString const ,Json::Value>
PUBLIC	?find@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@ABVCZString@Value@Json@@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::find
PUBLIC	??AValue@Json@@QBEABV01@I@Z			; Json::Value::operator[]
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??AValue@Json@@QBEABV01@I@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??AValue@Json@@QBEABV01@I@Z$0
__ehfuncinfo$??AValue@Json@@QBEABV01@I@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??AValue@Json@@QBEABV01@I@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??AValue@Json@@QBEABV01@I@Z
_TEXT	SEGMENT
_this$ = -56						; size = 4
$T31425 = -52						; size = 4
$T31424 = -48						; size = 4
$T31423 = -44						; size = 8
$T31422 = -36						; size = 8
_key$ = -28						; size = 8
_it$ = -20						; size = 8
__$EHRec$ = -12						; size = 12
_index$ = 8						; size = 4
??AValue@Json@@QBEABV01@I@Z PROC			; Json::Value::operator[], COMDAT
; _this$ = ecx

; 1072 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??AValue@Json@@QBEABV01@I@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 44					; 0000002cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1073 :    JSON_ASSERT( type_ == nullValue  ||  type_ == arrayValue );
; 1074 :    if ( type_ == nullValue )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	shl	ecx, 24					; 00000018H
	sar	ecx, 24					; 00000018H
	jne	SHORT $LN2@operator@6

; 1075 :       return null;

	mov	eax, OFFSET ?null@Value@Json@@2V12@B	; Json::Value::null
	jmp	$LN3@operator@6
$LN2@operator@6:

; 1076 : #ifndef JSON_VALUE_USE_INTERNAL_MAP
; 1077 :    CZString key( index );

	mov	edx, DWORD PTR _index$[ebp]
	push	edx
	lea	ecx, DWORD PTR _key$[ebp]
	call	??0CZString@Value@Json@@QAE@H@Z		; Json::Value::CZString::CZString
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1078 :    ObjectValues::const_iterator it = value_.map_->find( key );

	lea	eax, DWORD PTR _key$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T31422[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?find@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@ABVCZString@Value@Json@@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::find
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _it$[ebp], ecx
	mov	DWORD PTR _it$[ebp+4], edx

; 1079 :    if ( it == value_.map_->end() )

	lea	eax, DWORD PTR $T31423[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?end@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::end
	push	eax
	lea	ecx, DWORD PTR _it$[ebp]
	call	??8const_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator::operator==
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN1@operator@6

; 1080 :       return null;

	mov	DWORD PTR $T31424[ebp], OFFSET ?null@Value@Json@@2V12@B ; Json::Value::null
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _key$[ebp]
	call	??1CZString@Value@Json@@QAE@XZ		; Json::Value::CZString::~CZString
	mov	eax, DWORD PTR $T31424[ebp]
	jmp	SHORT $LN3@operator@6
$LN1@operator@6:

; 1081 :    return (*it).second;

	lea	ecx, DWORD PTR _it$[ebp]
	call	??Dconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBEABU?$pair@$$CBVCZString@Value@Json@@V23@@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator::operator*
	add	eax, 8
	mov	DWORD PTR $T31425[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _key$[ebp]
	call	??1CZString@Value@Json@@QAE@XZ		; Json::Value::CZString::~CZString
	mov	eax, DWORD PTR $T31425[ebp]
$LN3@operator@6:

; 1082 : #else
; 1083 :    Value *value = value_.array_->find( index );
; 1084 :    return value ? *value : null;
; 1085 : #endif
; 1086 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??AValue@Json@@QBEABV01@I@Z$0:
	lea	ecx, DWORD PTR _key$[ebp]
	jmp	??1CZString@Value@Json@@QAE@XZ		; Json::Value::CZString::~CZString
__ehhandler$??AValue@Json@@QBEABV01@I@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-48]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??AValue@Json@@QBEABV01@I@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??AValue@Json@@QBEABV01@I@Z ENDP			; Json::Value::operator[]
PUBLIC	?resolveReference@Value@Json@@AAEAAV12@PBD_N@Z	; Json::Value::resolveReference
PUBLIC	??AValue@Json@@QAEAAV01@PBD@Z			; Json::Value::operator[]
; Function compile flags: /Odtp
;	COMDAT ??AValue@Json@@QAEAAV01@PBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_key$ = 8						; size = 4
??AValue@Json@@QAEAAV01@PBD@Z PROC			; Json::Value::operator[], COMDAT
; _this$ = ecx

; 1091 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1092 :    return resolveReference( key, false );

	push	0
	mov	eax, DWORD PTR _key$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?resolveReference@Value@Json@@AAEAAV12@PBD_N@Z ; Json::Value::resolveReference

; 1093 : }

	mov	esp, ebp
	pop	ebp
	ret	4
??AValue@Json@@QAEAAV01@PBD@Z ENDP			; Json::Value::operator[]
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?resolveReference@Value@Json@@AAEAAV12@PBD_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?resolveReference@Value@Json@@AAEAAV12@PBD_N@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?resolveReference@Value@Json@@AAEAAV12@PBD_N@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?resolveReference@Value@Json@@AAEAAV12@PBD_N@Z$2
__ehfuncinfo$?resolveReference@Value@Json@@AAEAAV12@PBD_N@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?resolveReference@Value@Json@@AAEAAV12@PBD_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?resolveReference@Value@Json@@AAEAAV12@PBD_N@Z
_TEXT	SEGMENT
tv151 = -112						; size = 4
tv157 = -108						; size = 4
_this$ = -104						; size = 4
$T31441 = -100						; size = 4
$T31440 = -96						; size = 8
$T31439 = -88						; size = 4
$T31438 = -84						; size = 8
$T31437 = -76						; size = 16
_actualKey$ = -60					; size = 8
_defaultValue$ = -52					; size = 24
_value$ = -24						; size = 4
_it$ = -20						; size = 8
__$EHRec$ = -12						; size = 12
_key$ = 8						; size = 4
_isStatic$ = 12						; size = 1
?resolveReference@Value@Json@@AAEAAV12@PBD_N@Z PROC	; Json::Value::resolveReference, COMDAT
; _this$ = ecx

; 1099 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?resolveReference@Value@Json@@AAEAAV12@PBD_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 100				; 00000064H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1100 :    JSON_ASSERT( type_ == nullValue  ||  type_ == objectValue );
; 1101 :    if ( type_ == nullValue )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	shl	ecx, 24					; 00000018H
	sar	ecx, 24					; 00000018H
	jne	SHORT $LN2@resolveRef

; 1102 :       *this = Value( objectValue );

	push	7
	lea	ecx, DWORD PTR $T31437[ebp]
	call	??0Value@Json@@QAE@W4ValueType@1@@Z	; Json::Value::Value
	mov	DWORD PTR tv157[ebp], eax
	mov	edx, DWORD PTR tv157[ebp]
	mov	DWORD PTR tv151[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR tv151[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4Value@Json@@QAEAAV01@ABV01@@Z	; Json::Value::operator=
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T31437[ebp]
	call	??1Value@Json@@QAE@XZ			; Json::Value::~Value
$LN2@resolveRef:

; 1103 : #ifndef JSON_VALUE_USE_INTERNAL_MAP
; 1104 :    CZString actualKey( key, isStatic ? CZString::noDuplication 
; 1105 :                                      : CZString::duplicateOnCopy );

	movzx	ecx, BYTE PTR _isStatic$[ebp]
	neg	ecx
	sbb	ecx, ecx
	and	ecx, -2					; fffffffeH
	add	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _key$[ebp]
	push	edx
	lea	ecx, DWORD PTR _actualKey$[ebp]
	call	??0CZString@Value@Json@@QAE@PBDW4DuplicationPolicy@012@@Z ; Json::Value::CZString::CZString
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 1106 :    ObjectValues::iterator it = value_.map_->lower_bound( actualKey );

	lea	eax, DWORD PTR _actualKey$[ebp]
	push	eax
	lea	ecx, DWORD PTR _it$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?lower_bound@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@ABVCZString@Value@Json@@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::lower_bound

; 1107 :    if ( it != value_.map_->end()  &&  (*it).first == actualKey )

	lea	eax, DWORD PTR $T31438[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?end@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::end
	push	eax
	lea	ecx, DWORD PTR _it$[ebp]
	call	??9const_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator::operator!=
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN1@resolveRef
	lea	eax, DWORD PTR _actualKey$[ebp]
	push	eax
	lea	ecx, DWORD PTR _it$[ebp]
	call	??Diterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBEAAU?$pair@$$CBVCZString@Value@Json@@V23@@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::iterator::operator*
	mov	ecx, eax
	call	??8CZString@Value@Json@@QBE_NABV012@@Z	; Json::Value::CZString::operator==
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@resolveRef

; 1108 :       return (*it).second;

	lea	ecx, DWORD PTR _it$[ebp]
	call	??Diterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBEAAU?$pair@$$CBVCZString@Value@Json@@V23@@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::iterator::operator*
	add	eax, 8
	mov	DWORD PTR $T31439[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _actualKey$[ebp]
	call	??1CZString@Value@Json@@QAE@XZ		; Json::Value::CZString::~CZString
	mov	eax, DWORD PTR $T31439[ebp]
	jmp	SHORT $LN3@resolveRef
$LN1@resolveRef:

; 1109 : 
; 1110 :    ObjectValues::value_type defaultValue( actualKey, null );

	push	OFFSET ?null@Value@Json@@2V12@B		; Json::Value::null
	lea	edx, DWORD PTR _actualKey$[ebp]
	push	edx
	lea	ecx, DWORD PTR _defaultValue$[ebp]
	call	??0?$pair@$$CBVCZString@Value@Json@@V23@@std@@QAE@ABVCZString@Value@Json@@ABV34@@Z ; std::pair<Json::Value::CZString const ,Json::Value>::pair<Json::Value::CZString const ,Json::Value>
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 1111 :    it = value_.map_->insert( it, defaultValue );

	lea	eax, DWORD PTR _defaultValue$[ebp]
	push	eax
	mov	ecx, DWORD PTR _it$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR _it$[ebp]
	push	edx
	lea	eax, DWORD PTR $T31440[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?insert@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@V312@ABU?$pair@$$CBVCZString@Value@Json@@V23@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::insert
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR _it$[ebp], edx
	mov	DWORD PTR _it$[ebp+4], eax

; 1112 :    Value &value = (*it).second;

	lea	ecx, DWORD PTR _it$[ebp]
	call	??Diterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBEAAU?$pair@$$CBVCZString@Value@Json@@V23@@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::iterator::operator*
	add	eax, 8
	mov	DWORD PTR _value$[ebp], eax

; 1113 :    return value;

	mov	ecx, DWORD PTR _value$[ebp]
	mov	DWORD PTR $T31441[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _defaultValue$[ebp]
	call	??1?$pair@$$CBVCZString@Value@Json@@V23@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _actualKey$[ebp]
	call	??1CZString@Value@Json@@QAE@XZ		; Json::Value::CZString::~CZString
	mov	eax, DWORD PTR $T31441[ebp]
$LN3@resolveRef:

; 1114 : #else
; 1115 :    return value_.map_->resolveReference( key, isStatic );
; 1116 : #endif
; 1117 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?resolveReference@Value@Json@@AAEAAV12@PBD_N@Z$0:
	lea	ecx, DWORD PTR $T31437[ebp]
	jmp	??1Value@Json@@QAE@XZ			; Json::Value::~Value
__unwindfunclet$?resolveReference@Value@Json@@AAEAAV12@PBD_N@Z$1:
	lea	ecx, DWORD PTR _actualKey$[ebp]
	jmp	??1CZString@Value@Json@@QAE@XZ		; Json::Value::CZString::~CZString
__unwindfunclet$?resolveReference@Value@Json@@AAEAAV12@PBD_N@Z$2:
	lea	ecx, DWORD PTR _defaultValue$[ebp]
	jmp	??1?$pair@$$CBVCZString@Value@Json@@V23@@std@@QAE@XZ
__ehhandler$?resolveReference@Value@Json@@AAEAAV12@PBD_N@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-104]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?resolveReference@Value@Json@@AAEAAV12@PBD_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?resolveReference@Value@Json@@AAEAAV12@PBD_N@Z ENDP	; Json::Value::resolveReference
PUBLIC	?get@Value@Json@@QBE?AV12@IABV12@@Z		; Json::Value::get
; Function compile flags: /Odtp
;	COMDAT ?get@Value@Json@@QBE?AV12@IABV12@@Z
_TEXT	SEGMENT
tv70 = -20						; size = 4
_this$ = -16						; size = 4
$T31457 = -12						; size = 4
$T31453 = -8						; size = 4
_value$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_index$ = 12						; size = 4
_defaultValue$ = 16					; size = 4
?get@Value@Json@@QBE?AV12@IABV12@@Z PROC		; Json::Value::get, COMDAT
; _this$ = ecx

; 1123 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T31457[ebp], 0

; 1124 :    const Value *value = &((*this)[index]);

	mov	eax, DWORD PTR _index$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??AValue@Json@@QBEABV01@I@Z		; Json::Value::operator[]
	mov	DWORD PTR _value$[ebp], eax

; 1125 :    return value == &null ? defaultValue : *value;

	cmp	DWORD PTR _value$[ebp], OFFSET ?null@Value@Json@@2V12@B ; Json::Value::null
	jne	SHORT $LN3@get
	mov	ecx, DWORD PTR _defaultValue$[ebp]
	mov	DWORD PTR tv70[ebp], ecx
	jmp	SHORT $LN4@get
$LN3@get:
	mov	edx, DWORD PTR _value$[ebp]
	mov	DWORD PTR tv70[ebp], edx
$LN4@get:
	mov	eax, DWORD PTR tv70[ebp]
	mov	DWORD PTR $T31453[ebp], eax
	mov	ecx, DWORD PTR $T31453[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Value@Json@@QAE@ABV01@@Z		; Json::Value::Value
	mov	edx, DWORD PTR $T31457[ebp]
	or	edx, 1
	mov	DWORD PTR $T31457[ebp], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1126 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?get@Value@Json@@QBE?AV12@IABV12@@Z ENDP		; Json::Value::get
_TEXT	ENDS
PUBLIC	?isValidIndex@Value@Json@@QBE_NI@Z		; Json::Value::isValidIndex
; Function compile flags: /Odtp
;	COMDAT ?isValidIndex@Value@Json@@QBE_NI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_index$ = 8						; size = 4
?isValidIndex@Value@Json@@QBE_NI@Z PROC			; Json::Value::isValidIndex, COMDAT
; _this$ = ecx

; 1131 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1132 :    return index < size();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@Value@Json@@QBEIXZ		; Json::Value::size
	cmp	DWORD PTR _index$[ebp], eax
	sbb	eax, eax
	neg	eax

; 1133 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?isValidIndex@Value@Json@@QBE_NI@Z ENDP			; Json::Value::isValidIndex
_TEXT	ENDS
PUBLIC	??AValue@Json@@QBEABV01@PBD@Z			; Json::Value::operator[]
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??AValue@Json@@QBEABV01@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??AValue@Json@@QBEABV01@PBD@Z$0
__ehfuncinfo$??AValue@Json@@QBEABV01@PBD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??AValue@Json@@QBEABV01@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??AValue@Json@@QBEABV01@PBD@Z
_TEXT	SEGMENT
_this$ = -56						; size = 4
$T31466 = -52						; size = 4
$T31465 = -48						; size = 4
$T31464 = -44						; size = 8
$T31463 = -36						; size = 8
_actualKey$ = -28					; size = 8
_it$ = -20						; size = 8
__$EHRec$ = -12						; size = 12
_key$ = 8						; size = 4
??AValue@Json@@QBEABV01@PBD@Z PROC			; Json::Value::operator[], COMDAT
; _this$ = ecx

; 1139 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??AValue@Json@@QBEABV01@PBD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 44					; 0000002cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1140 :    JSON_ASSERT( type_ == nullValue  ||  type_ == objectValue );
; 1141 :    if ( type_ == nullValue )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	shl	ecx, 24					; 00000018H
	sar	ecx, 24					; 00000018H
	jne	SHORT $LN2@operator@7

; 1142 :       return null;

	mov	eax, OFFSET ?null@Value@Json@@2V12@B	; Json::Value::null
	jmp	$LN3@operator@7
$LN2@operator@7:

; 1143 : #ifndef JSON_VALUE_USE_INTERNAL_MAP
; 1144 :    CZString actualKey( key, CZString::noDuplication );

	push	0
	mov	edx, DWORD PTR _key$[ebp]
	push	edx
	lea	ecx, DWORD PTR _actualKey$[ebp]
	call	??0CZString@Value@Json@@QAE@PBDW4DuplicationPolicy@012@@Z ; Json::Value::CZString::CZString
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1145 :    ObjectValues::const_iterator it = value_.map_->find( actualKey );

	lea	eax, DWORD PTR _actualKey$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T31463[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?find@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@ABVCZString@Value@Json@@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::find
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _it$[ebp], ecx
	mov	DWORD PTR _it$[ebp+4], edx

; 1146 :    if ( it == value_.map_->end() )

	lea	eax, DWORD PTR $T31464[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?end@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::end
	push	eax
	lea	ecx, DWORD PTR _it$[ebp]
	call	??8const_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator::operator==
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN1@operator@7

; 1147 :       return null;

	mov	DWORD PTR $T31465[ebp], OFFSET ?null@Value@Json@@2V12@B ; Json::Value::null
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _actualKey$[ebp]
	call	??1CZString@Value@Json@@QAE@XZ		; Json::Value::CZString::~CZString
	mov	eax, DWORD PTR $T31465[ebp]
	jmp	SHORT $LN3@operator@7
$LN1@operator@7:

; 1148 :    return (*it).second;

	lea	ecx, DWORD PTR _it$[ebp]
	call	??Dconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBEABU?$pair@$$CBVCZString@Value@Json@@V23@@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator::operator*
	add	eax, 8
	mov	DWORD PTR $T31466[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _actualKey$[ebp]
	call	??1CZString@Value@Json@@QAE@XZ		; Json::Value::CZString::~CZString
	mov	eax, DWORD PTR $T31466[ebp]
$LN3@operator@7:

; 1149 : #else
; 1150 :    const Value *value = value_.map_->find( key );
; 1151 :    return value ? *value : null;
; 1152 : #endif
; 1153 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??AValue@Json@@QBEABV01@PBD@Z$0:
	lea	ecx, DWORD PTR _actualKey$[ebp]
	jmp	??1CZString@Value@Json@@QAE@XZ		; Json::Value::CZString::~CZString
__ehhandler$??AValue@Json@@QBEABV01@PBD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-48]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??AValue@Json@@QBEABV01@PBD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??AValue@Json@@QBEABV01@PBD@Z ENDP			; Json::Value::operator[]
PUBLIC	??AValue@Json@@QAEAAV01@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::Value::operator[]
; Function compile flags: /Odtp
;	COMDAT ??AValue@Json@@QAEAAV01@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_key$ = 8						; size = 4
??AValue@Json@@QAEAAV01@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; Json::Value::operator[], COMDAT
; _this$ = ecx

; 1158 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1159 :    return (*this)[ key.c_str() ];

	mov	ecx, DWORD PTR _key$[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??AValue@Json@@QAEAAV01@PBD@Z		; Json::Value::operator[]

; 1160 : }

	mov	esp, ebp
	pop	ebp
	ret	4
??AValue@Json@@QAEAAV01@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; Json::Value::operator[]
_TEXT	ENDS
PUBLIC	??AValue@Json@@QBEABV01@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::Value::operator[]
; Function compile flags: /Odtp
;	COMDAT ??AValue@Json@@QBEABV01@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_key$ = 8						; size = 4
??AValue@Json@@QBEABV01@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; Json::Value::operator[], COMDAT
; _this$ = ecx

; 1165 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1166 :    return (*this)[ key.c_str() ];

	mov	ecx, DWORD PTR _key$[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??AValue@Json@@QBEABV01@PBD@Z		; Json::Value::operator[]

; 1167 : }

	mov	esp, ebp
	pop	ebp
	ret	4
??AValue@Json@@QBEABV01@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; Json::Value::operator[]
_TEXT	ENDS
PUBLIC	??BStaticString@Json@@QBEPBDXZ			; Json::StaticString::operator char const *
PUBLIC	??AValue@Json@@QAEAAV01@ABVStaticString@1@@Z	; Json::Value::operator[]
; Function compile flags: /Odtp
;	COMDAT ??AValue@Json@@QAEAAV01@ABVStaticString@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_key$ = 8						; size = 4
??AValue@Json@@QAEAAV01@ABVStaticString@1@@Z PROC	; Json::Value::operator[], COMDAT
; _this$ = ecx

; 1171 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1172 :    return resolveReference( key, true );

	push	1
	mov	ecx, DWORD PTR _key$[ebp]
	call	??BStaticString@Json@@QBEPBDXZ		; Json::StaticString::operator char const *
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?resolveReference@Value@Json@@AAEAAV12@PBD_N@Z ; Json::Value::resolveReference

; 1173 : }

	mov	esp, ebp
	pop	ebp
	ret	4
??AValue@Json@@QAEAAV01@ABVStaticString@1@@Z ENDP	; Json::Value::operator[]
; Function compile flags: /Odtp
; File d:\git_zqprojs\zqproj\generic\cdmifuse\jsoncpp-src-0.5.0\include\json\value.h
_TEXT	ENDS
;	COMDAT ??BStaticString@Json@@QBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??BStaticString@Json@@QBEPBDXZ PROC			; Json::StaticString::operator char const *, COMDAT
; _this$ = ecx

; 71   :       {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 72   :          return str_;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 73   :       }

	mov	esp, ebp
	pop	ebp
	ret	0
??BStaticString@Json@@QBEPBDXZ ENDP			; Json::StaticString::operator char const *
_TEXT	ENDS
PUBLIC	?append@Value@Json@@QAEAAV12@ABV12@@Z		; Json::Value::append
; Function compile flags: /Odtp
; File d:\git_zqprojs\zqproj\generic\cdmifuse\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp
;	COMDAT ?append@Value@Json@@QAEAAV12@ABV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_value$ = 8						; size = 4
?append@Value@Json@@QAEAAV12@ABV12@@Z PROC		; Json::Value::append, COMDAT
; _this$ = ecx

; 1194 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1195 :    return (*this)[size()] = value;

	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@Value@Json@@QBEIXZ		; Json::Value::size
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??AValue@Json@@QAEAAV01@I@Z		; Json::Value::operator[]
	mov	ecx, eax
	call	??4Value@Json@@QAEAAV01@ABV01@@Z	; Json::Value::operator=

; 1196 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?append@Value@Json@@QAEAAV12@ABV12@@Z ENDP		; Json::Value::append
_TEXT	ENDS
PUBLIC	?get@Value@Json@@QBE?AV12@PBDABV12@@Z		; Json::Value::get
; Function compile flags: /Odtp
;	COMDAT ?get@Value@Json@@QBE?AV12@PBDABV12@@Z
_TEXT	SEGMENT
tv70 = -20						; size = 4
_this$ = -16						; size = 4
$T31490 = -12						; size = 4
$T31486 = -8						; size = 4
_value$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_key$ = 12						; size = 4
_defaultValue$ = 16					; size = 4
?get@Value@Json@@QBE?AV12@PBDABV12@@Z PROC		; Json::Value::get, COMDAT
; _this$ = ecx

; 1202 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T31490[ebp], 0

; 1203 :    const Value *value = &((*this)[key]);

	mov	eax, DWORD PTR _key$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??AValue@Json@@QBEABV01@PBD@Z		; Json::Value::operator[]
	mov	DWORD PTR _value$[ebp], eax

; 1204 :    return value == &null ? defaultValue : *value;

	cmp	DWORD PTR _value$[ebp], OFFSET ?null@Value@Json@@2V12@B ; Json::Value::null
	jne	SHORT $LN3@get@2
	mov	ecx, DWORD PTR _defaultValue$[ebp]
	mov	DWORD PTR tv70[ebp], ecx
	jmp	SHORT $LN4@get@2
$LN3@get@2:
	mov	edx, DWORD PTR _value$[ebp]
	mov	DWORD PTR tv70[ebp], edx
$LN4@get@2:
	mov	eax, DWORD PTR tv70[ebp]
	mov	DWORD PTR $T31486[ebp], eax
	mov	ecx, DWORD PTR $T31486[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Value@Json@@QAE@ABV01@@Z		; Json::Value::Value
	mov	edx, DWORD PTR $T31490[ebp]
	or	edx, 1
	mov	DWORD PTR $T31490[ebp], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1205 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?get@Value@Json@@QBE?AV12@PBDABV12@@Z ENDP		; Json::Value::get
_TEXT	ENDS
PUBLIC	?get@Value@Json@@QBE?AV12@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV12@@Z ; Json::Value::get
; Function compile flags: /Odtp
;	COMDAT ?get@Value@Json@@QBE?AV12@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV12@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T31495 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_key$ = 12						; size = 4
_defaultValue$ = 16					; size = 4
?get@Value@Json@@QBE?AV12@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV12@@Z PROC ; Json::Value::get, COMDAT
; _this$ = ecx

; 1211 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T31495[ebp], 0

; 1212 :    return get( key.c_str(), defaultValue );

	mov	eax, DWORD PTR _defaultValue$[ebp]
	push	eax
	mov	ecx, DWORD PTR _key$[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?get@Value@Json@@QBE?AV12@PBDABV12@@Z	; Json::Value::get
	mov	edx, DWORD PTR $T31495[ebp]
	or	edx, 1
	mov	DWORD PTR $T31495[ebp], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1213 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?get@Value@Json@@QBE?AV12@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV12@@Z ENDP ; Json::Value::get
_TEXT	ENDS
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@V312@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::erase
PUBLIC	?removeMember@Value@Json@@QAE?AV12@PBD@Z	; Json::Value::removeMember
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?removeMember@Value@Json@@QAE?AV12@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?removeMember@Value@Json@@QAE?AV12@PBD@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?removeMember@Value@Json@@QAE?AV12@PBD@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?removeMember@Value@Json@@QAE?AV12@PBD@Z$2
__ehfuncinfo$?removeMember@Value@Json@@QAE?AV12@PBD@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?removeMember@Value@Json@@QAE?AV12@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?removeMember@Value@Json@@QAE?AV12@PBD@Z
_TEXT	SEGMENT
_this$ = -68						; size = 4
$T31502 = -64						; size = 4
$T31500 = -60						; size = 8
$T31499 = -52						; size = 8
_actualKey$ = -44					; size = 8
_it$ = -36						; size = 8
_old$ = -28						; size = 16
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_key$ = 12						; size = 4
?removeMember@Value@Json@@QAE?AV12@PBD@Z PROC		; Json::Value::removeMember, COMDAT
; _this$ = ecx

; 1217 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?removeMember@Value@Json@@QAE?AV12@PBD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 56					; 00000038H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T31502[ebp], 0

; 1218 :    JSON_ASSERT( type_ == nullValue  ||  type_ == objectValue );
; 1219 :    if ( type_ == nullValue )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	shl	ecx, 24					; 00000018H
	sar	ecx, 24					; 00000018H
	jne	SHORT $LN2@removeMemb

; 1220 :       return null;

	push	OFFSET ?null@Value@Json@@2V12@B		; Json::Value::null
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Value@Json@@QAE@ABV01@@Z		; Json::Value::Value
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR $T31502[ebp]
	or	edx, 1
	mov	DWORD PTR $T31502[ebp], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN3@removeMemb
$LN2@removeMemb:

; 1221 : #ifndef JSON_VALUE_USE_INTERNAL_MAP
; 1222 :    CZString actualKey( key, CZString::noDuplication );

	push	0
	mov	eax, DWORD PTR _key$[ebp]
	push	eax
	lea	ecx, DWORD PTR _actualKey$[ebp]
	call	??0CZString@Value@Json@@QAE@PBDW4DuplicationPolicy@012@@Z ; Json::Value::CZString::CZString
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 1223 :    ObjectValues::iterator it = value_.map_->find( actualKey );

	lea	ecx, DWORD PTR _actualKey$[ebp]
	push	ecx
	lea	edx, DWORD PTR _it$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?find@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@ABVCZString@Value@Json@@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::find

; 1224 :    if ( it == value_.map_->end() )

	lea	ecx, DWORD PTR $T31499[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?end@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::end
	push	eax
	lea	ecx, DWORD PTR _it$[ebp]
	call	??8const_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@removeMemb

; 1225 :       return null;

	push	OFFSET ?null@Value@Json@@2V12@B		; Json::Value::null
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Value@Json@@QAE@ABV01@@Z		; Json::Value::Value
	mov	ecx, DWORD PTR $T31502[ebp]
	or	ecx, 1
	mov	DWORD PTR $T31502[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _actualKey$[ebp]
	call	??1CZString@Value@Json@@QAE@XZ		; Json::Value::CZString::~CZString
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN3@removeMemb
$LN1@removeMemb:

; 1226 :    Value old(it->second);

	lea	ecx, DWORD PTR _it$[ebp]
	call	??Citerator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBEPAU?$pair@$$CBVCZString@Value@Json@@V23@@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::iterator::operator->
	add	eax, 8
	push	eax
	lea	ecx, DWORD PTR _old$[ebp]
	call	??0Value@Json@@QAE@ABV01@@Z		; Json::Value::Value
	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 1227 :    value_.map_->erase(it);

	mov	edx, DWORD PTR _it$[ebp+4]
	push	edx
	mov	eax, DWORD PTR _it$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T31500[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?erase@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@V312@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::erase

; 1228 :    return old;

	lea	eax, DWORD PTR _old$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Value@Json@@QAE@ABV01@@Z		; Json::Value::Value
	mov	ecx, DWORD PTR $T31502[ebp]
	or	ecx, 1
	mov	DWORD PTR $T31502[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _old$[ebp]
	call	??1Value@Json@@QAE@XZ			; Json::Value::~Value
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _actualKey$[ebp]
	call	??1CZString@Value@Json@@QAE@XZ		; Json::Value::CZString::~CZString
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN3@removeMemb:

; 1229 : #else
; 1230 :    Value *value = value_.map_->find( key );
; 1231 :    if (value){
; 1232 :       Value old(*value);
; 1233 :       value_.map_.remove( key );
; 1234 :       return old;
; 1235 :    } else {
; 1236 :       return null;
; 1237 :    }
; 1238 : #endif
; 1239 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?removeMember@Value@Json@@QAE?AV12@PBD@Z$0:
	mov	eax, DWORD PTR $T31502[ebp]
	and	eax, 1
	je	$LN6@removeMemb
	and	DWORD PTR $T31502[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	??1Value@Json@@QAE@XZ			; Json::Value::~Value
$LN6@removeMemb:
	ret	0
__unwindfunclet$?removeMember@Value@Json@@QAE?AV12@PBD@Z$1:
	lea	ecx, DWORD PTR _actualKey$[ebp]
	jmp	??1CZString@Value@Json@@QAE@XZ		; Json::Value::CZString::~CZString
__unwindfunclet$?removeMember@Value@Json@@QAE?AV12@PBD@Z$2:
	lea	ecx, DWORD PTR _old$[ebp]
	jmp	??1Value@Json@@QAE@XZ			; Json::Value::~Value
__ehhandler$?removeMember@Value@Json@@QAE?AV12@PBD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-60]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?removeMember@Value@Json@@QAE?AV12@PBD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?removeMember@Value@Json@@QAE?AV12@PBD@Z ENDP		; Json::Value::removeMember
PUBLIC	?removeMember@Value@Json@@QAE?AV12@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::Value::removeMember
; Function compile flags: /Odtp
;	COMDAT ?removeMember@Value@Json@@QAE?AV12@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T31515 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_key$ = 12						; size = 4
?removeMember@Value@Json@@QAE?AV12@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; Json::Value::removeMember, COMDAT
; _this$ = ecx

; 1243 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T31515[ebp], 0

; 1244 :    return removeMember( key.c_str() );

	mov	ecx, DWORD PTR _key$[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?removeMember@Value@Json@@QAE?AV12@PBD@Z ; Json::Value::removeMember
	mov	ecx, DWORD PTR $T31515[ebp]
	or	ecx, 1
	mov	DWORD PTR $T31515[ebp], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1245 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?removeMember@Value@Json@@QAE?AV12@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; Json::Value::removeMember
_TEXT	ENDS
PUBLIC	?isMember@Value@Json@@QBE_NPBD@Z		; Json::Value::isMember
; Function compile flags: /Odtp
;	COMDAT ?isMember@Value@Json@@QBE_NPBD@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_value$ = -4						; size = 4
_key$ = 8						; size = 4
?isMember@Value@Json@@QBE_NPBD@Z PROC			; Json::Value::isMember, COMDAT
; _this$ = ecx

; 1258 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1259 :    if (type_ != objectValue)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	shl	ecx, 24					; 00000018H
	sar	ecx, 24					; 00000018H
	cmp	ecx, 7
	je	SHORT $LN1@isMember

; 1260 : 	   return false;

	xor	al, al
	jmp	SHORT $LN2@isMember
$LN1@isMember:

; 1261 : 
; 1262 :    const Value *value = &((*this)[key]);

	mov	edx, DWORD PTR _key$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??AValue@Json@@QBEABV01@PBD@Z		; Json::Value::operator[]
	mov	DWORD PTR _value$[ebp], eax

; 1263 :    return value != &null;

	xor	eax, eax
	cmp	DWORD PTR _value$[ebp], OFFSET ?null@Value@Json@@2V12@B ; Json::Value::null
	setne	al
$LN2@isMember:

; 1264 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?isMember@Value@Json@@QBE_NPBD@Z ENDP			; Json::Value::isMember
_TEXT	ENDS
PUBLIC	?isMember@Value@Json@@QBE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::Value::isMember
; Function compile flags: /Odtp
;	COMDAT ?isMember@Value@Json@@QBE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_key$ = 8						; size = 4
?isMember@Value@Json@@QBE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; Json::Value::isMember, COMDAT
; _this$ = ecx

; 1269 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1270 :    return isMember( key.c_str() );

	mov	ecx, DWORD PTR _key$[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?isMember@Value@Json@@QBE_NPBD@Z	; Json::Value::isMember

; 1271 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?isMember@Value@Json@@QBE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; Json::Value::isMember
_TEXT	ENDS
PUBLIC	??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@ABV01@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::push_back
PUBLIC	??Econst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator::operator++
PUBLIC	?begin@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::begin
PUBLIC	?reserve@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXI@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::reserve
PUBLIC	??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	?getMemberNames@Value@Json@@QBE?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@XZ ; Json::Value::getMemberNames
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?getMemberNames@Value@Json@@QBE?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?getMemberNames@Value@Json@@QBE?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?getMemberNames@Value@Json@@QBE?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$?getMemberNames@Value@Json@@QBE?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@XZ$2
__ehfuncinfo$?getMemberNames@Value@Json@@QBE?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@XZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?getMemberNames@Value@Json@@QBE?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?getMemberNames@Value@Json@@QBE?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@XZ
_TEXT	SEGMENT
tv145 = -104						; size = 4
tv72 = -100						; size = 4
_this$ = -96						; size = 4
$T31527 = -92						; size = 4
$T31525 = -88						; size = 28
$T31524 = -60						; size = 8
$T31523 = -52						; size = 8
_members$ = -44						; size = 16
_itEnd$ = -28						; size = 8
_it$ = -20						; size = 8
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
?getMemberNames@Value@Json@@QBE?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@XZ PROC ; Json::Value::getMemberNames, COMDAT
; _this$ = ecx

; 1284 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?getMemberNames@Value@Json@@QBE?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 92					; 0000005cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T31527[ebp], 0

; 1285 :    JSON_ASSERT( type_ == nullValue  ||  type_ == objectValue );
; 1286 :    if ( type_ == nullValue )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	shl	ecx, 24					; 00000018H
	sar	ecx, 24					; 00000018H
	jne	SHORT $LN4@getMemberN

; 1287 :        return Value::Members();

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR $T31527[ebp]
	or	edx, 1
	mov	DWORD PTR $T31527[ebp], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN5@getMemberN
$LN4@getMemberN:

; 1288 :    Members members;

	lea	ecx, DWORD PTR _members$[ebp]
	call	??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 1289 :    members.reserve( value_.map_->size() );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?size@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::size
	push	eax
	lea	ecx, DWORD PTR _members$[ebp]
	call	?reserve@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXI@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::reserve

; 1290 : #ifndef JSON_VALUE_USE_INTERNAL_MAP
; 1291 :    ObjectValues::const_iterator it = value_.map_->begin();

	lea	ecx, DWORD PTR $T31523[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?begin@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::begin
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _it$[ebp], ecx
	mov	DWORD PTR _it$[ebp+4], edx

; 1292 :    ObjectValues::const_iterator itEnd = value_.map_->end();

	lea	eax, DWORD PTR $T31524[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?end@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::end
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR _itEnd$[ebp], edx
	mov	DWORD PTR _itEnd$[ebp+4], eax
	jmp	SHORT $LN3@getMemberN
$LN2@getMemberN:

; 1293 :    for ( ; it != itEnd; ++it )

	lea	ecx, DWORD PTR _it$[ebp]
	call	??Econst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator::operator++
$LN3@getMemberN:
	lea	ecx, DWORD PTR _itEnd$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _it$[ebp]
	call	??9const_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator::operator!=
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN1@getMemberN

; 1294 :       members.push_back( std::string( (*it).first.c_str() ) );

	lea	ecx, DWORD PTR _it$[ebp]
	call	??Dconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBEABU?$pair@$$CBVCZString@Value@Json@@V23@@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator::operator*
	mov	ecx, eax
	call	?c_str@CZString@Value@Json@@QBEPBDXZ	; Json::Value::CZString::c_str
	push	eax
	lea	ecx, DWORD PTR $T31525[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR tv72[ebp], eax
	mov	eax, DWORD PTR tv72[ebp]
	mov	DWORD PTR tv145[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	ecx, DWORD PTR tv145[ebp]
	push	ecx
	lea	ecx, DWORD PTR _members$[ebp]
	call	?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::push_back
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR $T31525[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	jmp	SHORT $LN2@getMemberN
$LN1@getMemberN:

; 1295 : #else
; 1296 :    ValueInternalMap::IteratorState it;
; 1297 :    ValueInternalMap::IteratorState itEnd;
; 1298 :    value_.map_->makeBeginIterator( it );
; 1299 :    value_.map_->makeEndIterator( itEnd );
; 1300 :    for ( ; !ValueInternalMap::equals( it, itEnd ); ValueInternalMap::increment(it) )
; 1301 :       members.push_back( std::string( ValueInternalMap::key( it ) ) );
; 1302 : #endif
; 1303 :    return members;

	lea	edx, DWORD PTR _members$[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@ABV01@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
	mov	eax, DWORD PTR $T31527[ebp]
	or	eax, 1
	mov	DWORD PTR $T31527[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _members$[ebp]
	call	??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN5@getMemberN:

; 1304 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?getMemberNames@Value@Json@@QBE?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@XZ$0:
	mov	eax, DWORD PTR $T31527[ebp]
	and	eax, 1
	je	$LN8@getMemberN
	and	DWORD PTR $T31527[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
$LN8@getMemberN:
	ret	0
__unwindfunclet$?getMemberNames@Value@Json@@QBE?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@XZ$1:
	lea	ecx, DWORD PTR _members$[ebp]
	jmp	??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
__unwindfunclet$?getMemberNames@Value@Json@@QBE?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@XZ$2:
	lea	ecx, DWORD PTR $T31525[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?getMemberNames@Value@Json@@QBE?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-96]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?getMemberNames@Value@Json@@QBE?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?getMemberNames@Value@Json@@QBE?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@XZ ENDP ; Json::Value::getMemberNames
; Function compile flags: /Odtp
;	COMDAT ?isNull@Value@Json@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?isNull@Value@Json@@QBE_NXZ PROC			; Json::Value::isNull, COMDAT
; _this$ = ecx

; 1334 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1335 :    return type_ == nullValue;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]
	shl	eax, 24					; 00000018H
	sar	eax, 24					; 00000018H
	neg	eax
	sbb	eax, eax
	add	eax, 1

; 1336 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?isNull@Value@Json@@QBE_NXZ ENDP			; Json::Value::isNull
_TEXT	ENDS
PUBLIC	?isBool@Value@Json@@QBE_NXZ			; Json::Value::isBool
; Function compile flags: /Odtp
;	COMDAT ?isBool@Value@Json@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?isBool@Value@Json@@QBE_NXZ PROC			; Json::Value::isBool, COMDAT
; _this$ = ecx

; 1341 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1342 :    return type_ == booleanValue;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	shl	ecx, 24					; 00000018H
	sar	ecx, 24					; 00000018H
	xor	eax, eax
	cmp	ecx, 5
	sete	al

; 1343 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?isBool@Value@Json@@QBE_NXZ ENDP			; Json::Value::isBool
_TEXT	ENDS
PUBLIC	?isInt@Value@Json@@QBE_NXZ			; Json::Value::isInt
; Function compile flags: /Odtp
;	COMDAT ?isInt@Value@Json@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?isInt@Value@Json@@QBE_NXZ PROC				; Json::Value::isInt, COMDAT
; _this$ = ecx

; 1348 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1349 :    return type_ == intValue;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]
	shl	eax, 24					; 00000018H
	sar	eax, 24					; 00000018H
	sub	eax, 1
	neg	eax
	sbb	eax, eax
	add	eax, 1

; 1350 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?isInt@Value@Json@@QBE_NXZ ENDP				; Json::Value::isInt
_TEXT	ENDS
PUBLIC	?isUInt@Value@Json@@QBE_NXZ			; Json::Value::isUInt
; Function compile flags: /Odtp
;	COMDAT ?isUInt@Value@Json@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?isUInt@Value@Json@@QBE_NXZ PROC			; Json::Value::isUInt, COMDAT
; _this$ = ecx

; 1355 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1356 :    return type_ == uintValue;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	shl	ecx, 24					; 00000018H
	sar	ecx, 24					; 00000018H
	xor	eax, eax
	cmp	ecx, 2
	sete	al

; 1357 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?isUInt@Value@Json@@QBE_NXZ ENDP			; Json::Value::isUInt
_TEXT	ENDS
PUBLIC	?isIntegral@Value@Json@@QBE_NXZ			; Json::Value::isIntegral
; Function compile flags: /Odtp
;	COMDAT ?isIntegral@Value@Json@@QBE_NXZ
_TEXT	SEGMENT
tv76 = -8						; size = 4
_this$ = -4						; size = 4
?isIntegral@Value@Json@@QBE_NXZ PROC			; Json::Value::isIntegral, COMDAT
; _this$ = ecx

; 1362 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1363 :    return type_ == intValue  
; 1364 :           ||  type_ == uintValue  
; 1365 :           ||  type_ == booleanValue;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	shl	ecx, 24					; 00000018H
	sar	ecx, 24					; 00000018H
	cmp	ecx, 1
	je	SHORT $LN3@isIntegral
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	shl	eax, 24					; 00000018H
	sar	eax, 24					; 00000018H
	cmp	eax, 2
	je	SHORT $LN3@isIntegral
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	shl	edx, 24					; 00000018H
	sar	edx, 24					; 00000018H
	cmp	edx, 5
	je	SHORT $LN3@isIntegral
	mov	DWORD PTR tv76[ebp], 0
	jmp	SHORT $LN4@isIntegral
$LN3@isIntegral:
	mov	DWORD PTR tv76[ebp], 1
$LN4@isIntegral:
	mov	al, BYTE PTR tv76[ebp]

; 1366 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?isIntegral@Value@Json@@QBE_NXZ ENDP			; Json::Value::isIntegral
_TEXT	ENDS
PUBLIC	?isDouble@Value@Json@@QBE_NXZ			; Json::Value::isDouble
; Function compile flags: /Odtp
;	COMDAT ?isDouble@Value@Json@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?isDouble@Value@Json@@QBE_NXZ PROC			; Json::Value::isDouble, COMDAT
; _this$ = ecx

; 1371 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1372 :    return type_ == realValue;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	shl	ecx, 24					; 00000018H
	sar	ecx, 24					; 00000018H
	xor	eax, eax
	cmp	ecx, 3
	sete	al

; 1373 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?isDouble@Value@Json@@QBE_NXZ ENDP			; Json::Value::isDouble
_TEXT	ENDS
PUBLIC	?isNumeric@Value@Json@@QBE_NXZ			; Json::Value::isNumeric
; Function compile flags: /Odtp
;	COMDAT ?isNumeric@Value@Json@@QBE_NXZ
_TEXT	SEGMENT
tv72 = -8						; size = 4
_this$ = -4						; size = 4
?isNumeric@Value@Json@@QBE_NXZ PROC			; Json::Value::isNumeric, COMDAT
; _this$ = ecx

; 1378 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1379 :    return isIntegral() || isDouble();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?isIntegral@Value@Json@@QBE_NXZ		; Json::Value::isIntegral
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@isNumeric
	mov	ecx, DWORD PTR _this$[ebp]
	call	?isDouble@Value@Json@@QBE_NXZ		; Json::Value::isDouble
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN3@isNumeric
	mov	DWORD PTR tv72[ebp], 0
	jmp	SHORT $LN4@isNumeric
$LN3@isNumeric:
	mov	DWORD PTR tv72[ebp], 1
$LN4@isNumeric:
	mov	al, BYTE PTR tv72[ebp]

; 1380 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?isNumeric@Value@Json@@QBE_NXZ ENDP			; Json::Value::isNumeric
_TEXT	ENDS
PUBLIC	?isString@Value@Json@@QBE_NXZ			; Json::Value::isString
; Function compile flags: /Odtp
;	COMDAT ?isString@Value@Json@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?isString@Value@Json@@QBE_NXZ PROC			; Json::Value::isString, COMDAT
; _this$ = ecx

; 1385 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1386 :    return type_ == stringValue;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	shl	ecx, 24					; 00000018H
	sar	ecx, 24					; 00000018H
	xor	eax, eax
	cmp	ecx, 4
	sete	al

; 1387 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?isString@Value@Json@@QBE_NXZ ENDP			; Json::Value::isString
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?isArray@Value@Json@@QBE_NXZ
_TEXT	SEGMENT
tv72 = -8						; size = 4
_this$ = -4						; size = 4
?isArray@Value@Json@@QBE_NXZ PROC			; Json::Value::isArray, COMDAT
; _this$ = ecx

; 1392 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1393 :    return type_ == nullValue  ||  type_ == arrayValue;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	shl	ecx, 24					; 00000018H
	sar	ecx, 24					; 00000018H
	je	SHORT $LN3@isArray
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	shl	eax, 24					; 00000018H
	sar	eax, 24					; 00000018H
	cmp	eax, 6
	je	SHORT $LN3@isArray
	mov	DWORD PTR tv72[ebp], 0
	jmp	SHORT $LN4@isArray
$LN3@isArray:
	mov	DWORD PTR tv72[ebp], 1
$LN4@isArray:
	mov	al, BYTE PTR tv72[ebp]

; 1394 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?isArray@Value@Json@@QBE_NXZ ENDP			; Json::Value::isArray
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?isObject@Value@Json@@QBE_NXZ
_TEXT	SEGMENT
tv72 = -8						; size = 4
_this$ = -4						; size = 4
?isObject@Value@Json@@QBE_NXZ PROC			; Json::Value::isObject, COMDAT
; _this$ = ecx

; 1399 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1400 :    return type_ == nullValue  ||  type_ == objectValue;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	shl	ecx, 24					; 00000018H
	sar	ecx, 24					; 00000018H
	je	SHORT $LN3@isObject
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	shl	eax, 24					; 00000018H
	sar	eax, 24					; 00000018H
	cmp	eax, 7
	je	SHORT $LN3@isObject
	mov	DWORD PTR tv72[ebp], 0
	jmp	SHORT $LN4@isObject
$LN3@isObject:
	mov	DWORD PTR tv72[ebp], 1
$LN4@isObject:
	mov	al, BYTE PTR tv72[ebp]

; 1401 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?isObject@Value@Json@@QBE_NXZ ENDP			; Json::Value::isObject
_TEXT	ENDS
PUBLIC	?setComment@Value@Json@@QAEXPBDW4CommentPlacement@2@@Z ; Json::Value::setComment
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?setComment@Value@Json@@QAEXPBDW4CommentPlacement@2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?setComment@Value@Json@@QAEXPBDW4CommentPlacement@2@@Z$0
__ehfuncinfo$?setComment@Value@Json@@QAEXPBDW4CommentPlacement@2@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?setComment@Value@Json@@QAEXPBDW4CommentPlacement@2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?setComment@Value@Json@@QAEXPBDW4CommentPlacement@2@@Z
_TEXT	SEGMENT
tv79 = -28						; size = 4
_this$ = -24						; size = 4
$T31568 = -20						; size = 4
$T31567 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_comment$ = 8						; size = 4
_placement$ = 12					; size = 4
?setComment@Value@Json@@QAEXPBDW4CommentPlacement@2@@Z PROC ; Json::Value::setComment, COMDAT
; _this$ = ecx

; 1407 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?setComment@Value@Json@@QAEXPBDW4CommentPlacement@2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1408 :    if ( !comments_ )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jne	SHORT $LN1@setComment@2

; 1409 :       comments_ = new CommentInfo[numberOfCommentPlacement];

	push	16					; 00000010H
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T31568[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T31568[ebp], 0
	je	SHORT $LN4@setComment@2
	mov	ecx, DWORD PTR $T31568[ebp]
	mov	DWORD PTR [ecx], 3
	push	OFFSET ??1CommentInfo@Value@Json@@QAE@XZ ; Json::Value::CommentInfo::~CommentInfo
	push	OFFSET ??0CommentInfo@Value@Json@@QAE@XZ ; Json::Value::CommentInfo::CommentInfo
	push	3
	push	4
	mov	edx, DWORD PTR $T31568[ebp]
	add	edx, 4
	push	edx
	call	??_L@YGXPAXIHP6EX0@Z1@Z
	mov	eax, DWORD PTR $T31568[ebp]
	add	eax, 4
	mov	DWORD PTR tv79[ebp], eax
	jmp	SHORT $LN5@setComment@2
$LN4@setComment@2:
	mov	DWORD PTR tv79[ebp], 0
$LN5@setComment@2:
	mov	ecx, DWORD PTR tv79[ebp]
	mov	DWORD PTR $T31567[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR $T31567[ebp]
	mov	DWORD PTR [edx+12], eax
$LN1@setComment@2:

; 1410 :    comments_[placement].setComment( comment );

	mov	ecx, DWORD PTR _comment$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR _placement$[ebp]
	lea	ecx, DWORD PTR [eax+ecx*4]
	call	?setComment@CommentInfo@Value@Json@@QAEXPBD@Z ; Json::Value::CommentInfo::setComment

; 1411 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?setComment@Value@Json@@QAEXPBDW4CommentPlacement@2@@Z$0:
	mov	eax, DWORD PTR $T31568[ebp]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	pop	ecx
	ret	0
__ehhandler$?setComment@Value@Json@@QAEXPBDW4CommentPlacement@2@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?setComment@Value@Json@@QAEXPBDW4CommentPlacement@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?setComment@Value@Json@@QAEXPBDW4CommentPlacement@2@@Z ENDP ; Json::Value::setComment
PUBLIC	?setComment@Value@Json@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4CommentPlacement@2@@Z ; Json::Value::setComment
; Function compile flags: /Odtp
;	COMDAT ?setComment@Value@Json@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4CommentPlacement@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_comment$ = 8						; size = 4
_placement$ = 12					; size = 4
?setComment@Value@Json@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4CommentPlacement@2@@Z PROC ; Json::Value::setComment, COMDAT
; _this$ = ecx

; 1417 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1418 :    setComment( comment.c_str(), placement );

	mov	eax, DWORD PTR _placement$[ebp]
	push	eax
	mov	ecx, DWORD PTR _comment$[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?setComment@Value@Json@@QAEXPBDW4CommentPlacement@2@@Z ; Json::Value::setComment

; 1419 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?setComment@Value@Json@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4CommentPlacement@2@@Z ENDP ; Json::Value::setComment
_TEXT	ENDS
PUBLIC	?hasComment@Value@Json@@QBE_NW4CommentPlacement@2@@Z ; Json::Value::hasComment
; Function compile flags: /Odtp
;	COMDAT ?hasComment@Value@Json@@QBE_NW4CommentPlacement@2@@Z
_TEXT	SEGMENT
tv70 = -8						; size = 4
_this$ = -4						; size = 4
_placement$ = 8						; size = 4
?hasComment@Value@Json@@QBE_NW4CommentPlacement@2@@Z PROC ; Json::Value::hasComment, COMDAT
; _this$ = ecx

; 1424 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1425 :    return comments_ != 0  &&  comments_[placement].comment_ != 0;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $LN3@hasComment
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	eax, DWORD PTR _placement$[ebp]
	cmp	DWORD PTR [edx+eax*4], 0
	je	SHORT $LN3@hasComment
	mov	DWORD PTR tv70[ebp], 1
	jmp	SHORT $LN4@hasComment
$LN3@hasComment:
	mov	DWORD PTR tv70[ebp], 0
$LN4@hasComment:
	mov	al, BYTE PTR tv70[ebp]

; 1426 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?hasComment@Value@Json@@QBE_NW4CommentPlacement@2@@Z ENDP ; Json::Value::hasComment
_TEXT	ENDS
PUBLIC	?getComment@Value@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4CommentPlacement@2@@Z ; Json::Value::getComment
; Function compile flags: /Odtp
;	COMDAT ?getComment@Value@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4CommentPlacement@2@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T31587 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_placement$ = 12					; size = 4
?getComment@Value@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4CommentPlacement@2@@Z PROC ; Json::Value::getComment, COMDAT
; _this$ = ecx

; 1430 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T31587[ebp], 0

; 1431 :    if ( hasComment(placement) )

	mov	eax, DWORD PTR _placement$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?hasComment@Value@Json@@QBE_NW4CommentPlacement@2@@Z ; Json::Value::hasComment
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@getComment

; 1432 :       return comments_[placement].comment_;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR _placement$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	eax, DWORD PTR $T31587[ebp]
	or	eax, 1
	mov	DWORD PTR $T31587[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN2@getComment
$LN1@getComment:

; 1433 :    return "";

	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	ecx, DWORD PTR $T31587[ebp]
	or	ecx, 1
	mov	DWORD PTR $T31587[ebp], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN2@getComment:

; 1434 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?getComment@Value@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4CommentPlacement@2@@Z ENDP ; Json::Value::getComment
_TEXT	ENDS
PUBLIC	??1StyledWriter@Json@@UAE@XZ			; Json::StyledWriter::~StyledWriter
PUBLIC	__$ArrayPad$
PUBLIC	?toStyledString@Value@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ; Json::Value::toStyledString
EXTRN	?write@StyledWriter@Json@@UAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVValue@2@@Z:PROC ; Json::StyledWriter::write
EXTRN	??0StyledWriter@Json@@QAE@XZ:PROC		; Json::StyledWriter::StyledWriter
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?toStyledString@Value@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?toStyledString@Value@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ$1
	DD	00H
	DD	FLAT:__unwindfunclet$?toStyledString@Value@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ$0
__ehfuncinfo$?toStyledString@Value@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?toStyledString@Value@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?toStyledString@Value@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
_TEXT	SEGMENT
_this$ = -116						; size = 4
$T31594 = -112						; size = 4
_writer$ = -108						; size = 88
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
?toStyledString@Value@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ PROC ; Json::Value::toStyledString, COMDAT
; _this$ = ecx

; 1439 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?toStyledString@Value@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 104				; 00000068H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T31594[ebp], 0

; 1440 :    StyledWriter writer;

	lea	ecx, DWORD PTR _writer$[ebp]
	call	??0StyledWriter@Json@@QAE@XZ		; Json::StyledWriter::StyledWriter
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 1441 :    return writer.write( *this );

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _writer$[ebp]
	call	?write@StyledWriter@Json@@UAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVValue@2@@Z ; Json::StyledWriter::write
	mov	edx, DWORD PTR $T31594[ebp]
	or	edx, 1
	mov	DWORD PTR $T31594[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _writer$[ebp]
	call	??1StyledWriter@Json@@UAE@XZ		; Json::StyledWriter::~StyledWriter
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1442 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?toStyledString@Value@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ$0:
	lea	ecx, DWORD PTR _writer$[ebp]
	jmp	??1StyledWriter@Json@@UAE@XZ		; Json::StyledWriter::~StyledWriter
__unwindfunclet$?toStyledString@Value@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ$1:
	mov	eax, DWORD PTR $T31594[ebp]
	and	eax, 1
	je	$LN5@toStyledSt
	and	DWORD PTR $T31594[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN5@toStyledSt:
	ret	0
__ehhandler$?toStyledString@Value@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-108]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?toStyledString@Value@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?toStyledString@Value@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ENDP ; Json::Value::toStyledString
PUBLIC	??_7StyledWriter@Json@@6B@			; Json::StyledWriter::`vftable'
PUBLIC	??_R4StyledWriter@Json@@6B@			; Json::StyledWriter::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVStyledWriter@Json@@@8			; Json::StyledWriter `RTTI Type Descriptor'
PUBLIC	??_R3StyledWriter@Json@@8			; Json::StyledWriter::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2StyledWriter@Json@@8			; Json::StyledWriter::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@StyledWriter@Json@@8		; Json::StyledWriter::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@Writer@Json@@8			; Json::Writer::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVWriter@Json@@@8				; Json::Writer `RTTI Type Descriptor'
PUBLIC	??_R3Writer@Json@@8				; Json::Writer::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2Writer@Json@@8				; Json::Writer::`RTTI Base Class Array'
EXTRN	??1Writer@Json@@UAE@XZ:PROC			; Json::Writer::~Writer
EXTRN	??_EStyledWriter@Json@@UAEPAXI@Z:PROC		; Json::StyledWriter::`vector deleting destructor'
;	COMDAT ??_R2Writer@Json@@8
; File d:\git_zqprojs\zqproj\generic\cdmifuse\jsoncpp-src-0.5.0\include\json\writer.h
rdata$r	SEGMENT
??_R2Writer@Json@@8 DD FLAT:??_R1A@?0A@EA@Writer@Json@@8 ; Json::Writer::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3Writer@Json@@8
rdata$r	SEGMENT
??_R3Writer@Json@@8 DD 00H				; Json::Writer::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2Writer@Json@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVWriter@Json@@@8
_DATA	SEGMENT
??_R0?AVWriter@Json@@@8 DD FLAT:??_7type_info@@6B@	; Json::Writer `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVWriter@Json@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@Writer@Json@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@Writer@Json@@8 DD FLAT:??_R0?AVWriter@Json@@@8 ; Json::Writer::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3Writer@Json@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@StyledWriter@Json@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@StyledWriter@Json@@8 DD FLAT:??_R0?AVStyledWriter@Json@@@8 ; Json::StyledWriter::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3StyledWriter@Json@@8
rdata$r	ENDS
;	COMDAT ??_R2StyledWriter@Json@@8
rdata$r	SEGMENT
??_R2StyledWriter@Json@@8 DD FLAT:??_R1A@?0A@EA@StyledWriter@Json@@8 ; Json::StyledWriter::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@Writer@Json@@8
rdata$r	ENDS
;	COMDAT ??_R3StyledWriter@Json@@8
rdata$r	SEGMENT
??_R3StyledWriter@Json@@8 DD 00H			; Json::StyledWriter::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2StyledWriter@Json@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVStyledWriter@Json@@@8
_DATA	SEGMENT
??_R0?AVStyledWriter@Json@@@8 DD FLAT:??_7type_info@@6B@ ; Json::StyledWriter `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVStyledWriter@Json@@', 00H
_DATA	ENDS
;	COMDAT ??_R4StyledWriter@Json@@6B@
rdata$r	SEGMENT
??_R4StyledWriter@Json@@6B@ DD 00H			; Json::StyledWriter::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVStyledWriter@Json@@@8
	DD	FLAT:??_R3StyledWriter@Json@@8
rdata$r	ENDS
;	COMDAT ??_7StyledWriter@Json@@6B@
CONST	SEGMENT
??_7StyledWriter@Json@@6B@ DD FLAT:??_R4StyledWriter@Json@@6B@ ; Json::StyledWriter::`vftable'
	DD	FLAT:??_EStyledWriter@Json@@UAEPAXI@Z
	DD	FLAT:?write@StyledWriter@Json@@UAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVValue@2@@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1StyledWriter@Json@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1StyledWriter@Json@@UAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1StyledWriter@Json@@UAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??1StyledWriter@Json@@UAE@XZ$2
__ehfuncinfo$??1StyledWriter@Json@@UAE@XZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??1StyledWriter@Json@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1StyledWriter@Json@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1StyledWriter@Json@@UAE@XZ PROC			; Json::StyledWriter::~StyledWriter, COMDAT
; _this$ = ecx

; 69   :       virtual ~StyledWriter(){}

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1StyledWriter@Json@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7StyledWriter@Json@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], 2
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 20					; 00000014H
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1Writer@Json@@UAE@XZ			; Json::Writer::~Writer
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1StyledWriter@Json@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1Writer@Json@@UAE@XZ			; Json::Writer::~Writer
__unwindfunclet$??1StyledWriter@Json@@UAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	jmp	??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
__unwindfunclet$??1StyledWriter@Json@@UAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 20					; 00000014H
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$??1StyledWriter@Json@@UAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1StyledWriter@Json@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1StyledWriter@Json@@UAE@XZ ENDP			; Json::StyledWriter::~StyledWriter
; Function compile flags: /Odtp
;	COMDAT ??_GStyledWriter@Json@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GStyledWriter@Json@@UAEPAXI@Z PROC			; Json::StyledWriter::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1StyledWriter@Json@@UAE@XZ		; Json::StyledWriter::~StyledWriter
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@5
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@5:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GStyledWriter@Json@@UAEPAXI@Z ENDP			; Json::StyledWriter::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?begin@Value@Json@@QBE?AVValueConstIterator@2@XZ ; Json::Value::begin
; Function compile flags: /Odtp
; File d:\git_zqprojs\zqproj\generic\cdmifuse\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp
;	COMDAT ?begin@Value@Json@@QBE?AVValueConstIterator@2@XZ
_TEXT	SEGMENT
tv67 = -16						; size = 4
_this$ = -12						; size = 4
$T31618 = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
?begin@Value@Json@@QBE?AVValueConstIterator@2@XZ PROC	; Json::Value::begin, COMDAT
; _this$ = ecx

; 1447 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 1448 :    switch ( type_ )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	shl	ecx, 24					; 00000018H
	sar	ecx, 24					; 00000018H
	mov	DWORD PTR tv67[ebp], ecx
	cmp	DWORD PTR tv67[ebp], 6
	jl	SHORT $LN4@begin
	cmp	DWORD PTR tv67[ebp], 7
	jle	SHORT $LN3@begin
	jmp	SHORT $LN4@begin
$LN3@begin:

; 1449 :    {
; 1450 : #ifdef JSON_VALUE_USE_INTERNAL_MAP
; 1451 :    case arrayValue:
; 1452 :       if ( value_.array_ )
; 1453 :       {
; 1454 :          ValueInternalArray::IteratorState it;
; 1455 :          value_.array_->makeBeginIterator( it );
; 1456 :          return const_iterator( it );
; 1457 :       }
; 1458 :       break;
; 1459 :    case objectValue:
; 1460 :       if ( value_.map_ )
; 1461 :       {
; 1462 :          ValueInternalMap::IteratorState it;
; 1463 :          value_.map_->makeBeginIterator( it );
; 1464 :          return const_iterator( it );
; 1465 :       }
; 1466 :       break;
; 1467 : #else
; 1468 :    case arrayValue:
; 1469 :    case objectValue:
; 1470 :       if ( value_.map_ )

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx], 0
	je	SHORT $LN4@begin

; 1471 :          return const_iterator( value_.map_->begin() );

	lea	eax, DWORD PTR $T31618[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?begin@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::begin
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0ValueConstIterator@Json@@AAE@ABViterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@Z ; Json::ValueConstIterator::ValueConstIterator
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN6@begin
$LN4@begin:

; 1472 :       break;
; 1473 : #endif
; 1474 :    default:
; 1475 :       break;
; 1476 :    }
; 1477 :    return const_iterator();

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0ValueConstIterator@Json@@QAE@XZ	; Json::ValueConstIterator::ValueConstIterator
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN6@begin:

; 1478 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?begin@Value@Json@@QBE?AVValueConstIterator@2@XZ ENDP	; Json::Value::begin
_TEXT	ENDS
PUBLIC	?end@Value@Json@@QBE?AVValueConstIterator@2@XZ	; Json::Value::end
; Function compile flags: /Odtp
;	COMDAT ?end@Value@Json@@QBE?AVValueConstIterator@2@XZ
_TEXT	SEGMENT
tv67 = -16						; size = 4
_this$ = -12						; size = 4
$T31621 = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
?end@Value@Json@@QBE?AVValueConstIterator@2@XZ PROC	; Json::Value::end, COMDAT
; _this$ = ecx

; 1482 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 1483 :    switch ( type_ )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	shl	ecx, 24					; 00000018H
	sar	ecx, 24					; 00000018H
	mov	DWORD PTR tv67[ebp], ecx
	cmp	DWORD PTR tv67[ebp], 6
	jl	SHORT $LN4@end
	cmp	DWORD PTR tv67[ebp], 7
	jle	SHORT $LN3@end
	jmp	SHORT $LN4@end
$LN3@end:

; 1484 :    {
; 1485 : #ifdef JSON_VALUE_USE_INTERNAL_MAP
; 1486 :    case arrayValue:
; 1487 :       if ( value_.array_ )
; 1488 :       {
; 1489 :          ValueInternalArray::IteratorState it;
; 1490 :          value_.array_->makeEndIterator( it );
; 1491 :          return const_iterator( it );
; 1492 :       }
; 1493 :       break;
; 1494 :    case objectValue:
; 1495 :       if ( value_.map_ )
; 1496 :       {
; 1497 :          ValueInternalMap::IteratorState it;
; 1498 :          value_.map_->makeEndIterator( it );
; 1499 :          return const_iterator( it );
; 1500 :       }
; 1501 :       break;
; 1502 : #else
; 1503 :    case arrayValue:
; 1504 :    case objectValue:
; 1505 :       if ( value_.map_ )

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx], 0
	je	SHORT $LN4@end

; 1506 :          return const_iterator( value_.map_->end() );

	lea	eax, DWORD PTR $T31621[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?end@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::end
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0ValueConstIterator@Json@@AAE@ABViterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@Z ; Json::ValueConstIterator::ValueConstIterator
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN6@end
$LN4@end:

; 1507 :       break;
; 1508 : #endif
; 1509 :    default:
; 1510 :       break;
; 1511 :    }
; 1512 :    return const_iterator();

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0ValueConstIterator@Json@@QAE@XZ	; Json::ValueConstIterator::ValueConstIterator
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN6@end:

; 1513 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?end@Value@Json@@QBE?AVValueConstIterator@2@XZ ENDP	; Json::Value::end
_TEXT	ENDS
PUBLIC	?begin@Value@Json@@QAE?AVValueIterator@2@XZ	; Json::Value::begin
; Function compile flags: /Odtp
;	COMDAT ?begin@Value@Json@@QAE?AVValueIterator@2@XZ
_TEXT	SEGMENT
tv67 = -16						; size = 4
_this$ = -12						; size = 4
$T31624 = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
?begin@Value@Json@@QAE?AVValueIterator@2@XZ PROC	; Json::Value::begin, COMDAT
; _this$ = ecx

; 1518 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 1519 :    switch ( type_ )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	shl	ecx, 24					; 00000018H
	sar	ecx, 24					; 00000018H
	mov	DWORD PTR tv67[ebp], ecx
	cmp	DWORD PTR tv67[ebp], 6
	jl	SHORT $LN4@begin@2
	cmp	DWORD PTR tv67[ebp], 7
	jle	SHORT $LN3@begin@2
	jmp	SHORT $LN4@begin@2
$LN3@begin@2:

; 1520 :    {
; 1521 : #ifdef JSON_VALUE_USE_INTERNAL_MAP
; 1522 :    case arrayValue:
; 1523 :       if ( value_.array_ )
; 1524 :       {
; 1525 :          ValueInternalArray::IteratorState it;
; 1526 :          value_.array_->makeBeginIterator( it );
; 1527 :          return iterator( it );
; 1528 :       }
; 1529 :       break;
; 1530 :    case objectValue:
; 1531 :       if ( value_.map_ )
; 1532 :       {
; 1533 :          ValueInternalMap::IteratorState it;
; 1534 :          value_.map_->makeBeginIterator( it );
; 1535 :          return iterator( it );
; 1536 :       }
; 1537 :       break;
; 1538 : #else
; 1539 :    case arrayValue:
; 1540 :    case objectValue:
; 1541 :       if ( value_.map_ )

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx], 0
	je	SHORT $LN4@begin@2

; 1542 :          return iterator( value_.map_->begin() );

	lea	eax, DWORD PTR $T31624[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?begin@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::begin
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0ValueIterator@Json@@AAE@ABViterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@Z ; Json::ValueIterator::ValueIterator
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN6@begin@2
$LN4@begin@2:

; 1543 :       break;
; 1544 : #endif
; 1545 :    default:
; 1546 :       break;
; 1547 :    }
; 1548 :    return iterator();

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0ValueIterator@Json@@QAE@XZ		; Json::ValueIterator::ValueIterator
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN6@begin@2:

; 1549 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?begin@Value@Json@@QAE?AVValueIterator@2@XZ ENDP	; Json::Value::begin
_TEXT	ENDS
PUBLIC	?end@Value@Json@@QAE?AVValueIterator@2@XZ	; Json::Value::end
; Function compile flags: /Odtp
;	COMDAT ?end@Value@Json@@QAE?AVValueIterator@2@XZ
_TEXT	SEGMENT
tv67 = -16						; size = 4
_this$ = -12						; size = 4
$T31627 = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
?end@Value@Json@@QAE?AVValueIterator@2@XZ PROC		; Json::Value::end, COMDAT
; _this$ = ecx

; 1553 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 1554 :    switch ( type_ )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	shl	ecx, 24					; 00000018H
	sar	ecx, 24					; 00000018H
	mov	DWORD PTR tv67[ebp], ecx
	cmp	DWORD PTR tv67[ebp], 6
	jl	SHORT $LN4@end@2
	cmp	DWORD PTR tv67[ebp], 7
	jle	SHORT $LN3@end@2
	jmp	SHORT $LN4@end@2
$LN3@end@2:

; 1555 :    {
; 1556 : #ifdef JSON_VALUE_USE_INTERNAL_MAP
; 1557 :    case arrayValue:
; 1558 :       if ( value_.array_ )
; 1559 :       {
; 1560 :          ValueInternalArray::IteratorState it;
; 1561 :          value_.array_->makeEndIterator( it );
; 1562 :          return iterator( it );
; 1563 :       }
; 1564 :       break;
; 1565 :    case objectValue:
; 1566 :       if ( value_.map_ )
; 1567 :       {
; 1568 :          ValueInternalMap::IteratorState it;
; 1569 :          value_.map_->makeEndIterator( it );
; 1570 :          return iterator( it );
; 1571 :       }
; 1572 :       break;
; 1573 : #else
; 1574 :    case arrayValue:
; 1575 :    case objectValue:
; 1576 :       if ( value_.map_ )

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx], 0
	je	SHORT $LN4@end@2

; 1577 :          return iterator( value_.map_->end() );

	lea	eax, DWORD PTR $T31627[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?end@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::end
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0ValueIterator@Json@@AAE@ABViterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@Z ; Json::ValueIterator::ValueIterator
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN6@end@2
$LN4@end@2:

; 1578 :       break;
; 1579 : #endif
; 1580 :    default:
; 1581 :       break;
; 1582 :    }
; 1583 :    return iterator();

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0ValueIterator@Json@@QAE@XZ		; Json::ValueIterator::ValueIterator
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN6@end@2:

; 1584 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?end@Value@Json@@QAE?AVValueIterator@2@XZ ENDP		; Json::Value::end
_TEXT	ENDS
PUBLIC	??0PathArgument@Json@@QAE@XZ			; Json::PathArgument::PathArgument
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
; Function compile flags: /Odtp
;	COMDAT ??0PathArgument@Json@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0PathArgument@Json@@QAE@XZ PROC			; Json::PathArgument::PathArgument, COMDAT
; _this$ = ecx

; 1592 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+32], 0

; 1593 : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0PathArgument@Json@@QAE@XZ ENDP			; Json::PathArgument::PathArgument
_TEXT	ENDS
PUBLIC	??0PathArgument@Json@@QAE@I@Z			; Json::PathArgument::PathArgument
; Function compile flags: /Odtp
;	COMDAT ??0PathArgument@Json@@QAE@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_index$ = 8						; size = 4
??0PathArgument@Json@@QAE@I@Z PROC			; Json::PathArgument::PathArgument, COMDAT
; _this$ = ecx

; 1599 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _index$[ebp]
	mov	DWORD PTR [eax+28], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+32], 1

; 1600 : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0PathArgument@Json@@QAE@I@Z ENDP			; Json::PathArgument::PathArgument
_TEXT	ENDS
PUBLIC	??0PathArgument@Json@@QAE@PBD@Z			; Json::PathArgument::PathArgument
; Function compile flags: /Odtp
;	COMDAT ??0PathArgument@Json@@QAE@PBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_key$ = 8						; size = 4
??0PathArgument@Json@@QAE@PBD@Z PROC			; Json::PathArgument::PathArgument, COMDAT
; _this$ = ecx

; 1606 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _key$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+32], 2

; 1607 : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0PathArgument@Json@@QAE@PBD@Z ENDP			; Json::PathArgument::PathArgument
_TEXT	ENDS
PUBLIC	??0PathArgument@Json@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::PathArgument::PathArgument
; Function compile flags: /Odtp
;	COMDAT ??0PathArgument@Json@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_key$ = 8						; size = 4
??0PathArgument@Json@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; Json::PathArgument::PathArgument, COMDAT
; _this$ = ecx

; 1613 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _key$[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+32], 2

; 1614 : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0PathArgument@Json@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; Json::PathArgument::PathArgument
_TEXT	ENDS
PUBLIC	??1?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAE@XZ ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::~vector<Json::PathArgument,std::allocator<Json::PathArgument> >
PUBLIC	??1?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QAE@XZ ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::~vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >
PUBLIC	?makePath@Path@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@4@@Z ; Json::Path::makePath
PUBLIC	?push_back@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QAEXABQBVPathArgument@Json@@@Z ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::push_back
PUBLIC	??0?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QAE@XZ ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >
PUBLIC	??0?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAE@XZ ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::vector<Json::PathArgument,std::allocator<Json::PathArgument> >
PUBLIC	??0Path@Json@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVPathArgument@1@1111@Z ; Json::Path::Path
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0Path@Json@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVPathArgument@1@1111@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0Path@Json@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVPathArgument@1@1111@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0Path@Json@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVPathArgument@1@1111@Z$1
__ehfuncinfo$??0Path@Json@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVPathArgument@1@1111@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0Path@Json@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVPathArgument@1@1111@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0Path@Json@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVPathArgument@1@1111@Z
_TEXT	SEGMENT
_this$ = -52						; size = 4
$T31646 = -48						; size = 4
$T31645 = -44						; size = 4
$T31644 = -40						; size = 4
$T31643 = -36						; size = 4
$T31642 = -32						; size = 4
_in$ = -28						; size = 16
__$EHRec$ = -12						; size = 12
_path$ = 8						; size = 4
_a1$ = 12						; size = 4
_a2$ = 16						; size = 4
_a3$ = 20						; size = 4
_a4$ = 24						; size = 4
_a5$ = 28						; size = 4
??0Path@Json@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVPathArgument@1@1111@Z PROC ; Json::Path::Path, COMDAT
; _this$ = ecx

; 1625 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0Path@Json@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVPathArgument@1@1111@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 40					; 00000028H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAE@XZ ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::vector<Json::PathArgument,std::allocator<Json::PathArgument> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1626 :    InArgs in;

	lea	ecx, DWORD PTR _in$[ebp]
	call	??0?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QAE@XZ ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 1627 :    in.push_back( &a1 );

	mov	eax, DWORD PTR _a1$[ebp]
	mov	DWORD PTR $T31642[ebp], eax
	lea	ecx, DWORD PTR $T31642[ebp]
	push	ecx
	lea	ecx, DWORD PTR _in$[ebp]
	call	?push_back@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QAEXABQBVPathArgument@Json@@@Z ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::push_back

; 1628 :    in.push_back( &a2 );

	mov	edx, DWORD PTR _a2$[ebp]
	mov	DWORD PTR $T31643[ebp], edx
	lea	eax, DWORD PTR $T31643[ebp]
	push	eax
	lea	ecx, DWORD PTR _in$[ebp]
	call	?push_back@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QAEXABQBVPathArgument@Json@@@Z ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::push_back

; 1629 :    in.push_back( &a3 );

	mov	ecx, DWORD PTR _a3$[ebp]
	mov	DWORD PTR $T31644[ebp], ecx
	lea	edx, DWORD PTR $T31644[ebp]
	push	edx
	lea	ecx, DWORD PTR _in$[ebp]
	call	?push_back@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QAEXABQBVPathArgument@Json@@@Z ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::push_back

; 1630 :    in.push_back( &a4 );

	mov	eax, DWORD PTR _a4$[ebp]
	mov	DWORD PTR $T31645[ebp], eax
	lea	ecx, DWORD PTR $T31645[ebp]
	push	ecx
	lea	ecx, DWORD PTR _in$[ebp]
	call	?push_back@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QAEXABQBVPathArgument@Json@@@Z ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::push_back

; 1631 :    in.push_back( &a5 );

	mov	edx, DWORD PTR _a5$[ebp]
	mov	DWORD PTR $T31646[ebp], edx
	lea	eax, DWORD PTR $T31646[ebp]
	push	eax
	lea	ecx, DWORD PTR _in$[ebp]
	call	?push_back@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QAEXABQBVPathArgument@Json@@@Z ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::push_back

; 1632 :    makePath( path, in );

	lea	ecx, DWORD PTR _in$[ebp]
	push	ecx
	mov	edx, DWORD PTR _path$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?makePath@Path@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@4@@Z ; Json::Path::makePath

; 1633 : }

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _in$[ebp]
	call	??1?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QAE@XZ ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::~vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0Path@Json@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVPathArgument@1@1111@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAE@XZ ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::~vector<Json::PathArgument,std::allocator<Json::PathArgument> >
__unwindfunclet$??0Path@Json@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVPathArgument@1@1111@Z$1:
	lea	ecx, DWORD PTR _in$[ebp]
	jmp	??1?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QAE@XZ ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::~vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >
__ehhandler$??0Path@Json@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVPathArgument@1@1111@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-44]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0Path@Json@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVPathArgument@1@1111@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0Path@Json@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVPathArgument@1@1111@Z ENDP ; Json::Path::Path
PUBLIC	??_C@_02GLFAOOJA@?$FL?4?$AA@			; `string'
PUBLIC	?invalidPath@Path@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z ; Json::Path::invalidPath
PUBLIC	??1PathArgument@Json@@QAE@XZ			; Json::PathArgument::~PathArgument
PUBLIC	?push_back@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAEXABVPathArgument@Json@@@Z ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::push_back
PUBLIC	?addPathInArg@Path@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@4@AAV?$_Vector_const_iterator@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@4@W4Kind@PathArgument@2@@Z ; Json::Path::addPathInArg
PUBLIC	?begin@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@2@XZ ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::begin
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD0@Z:PROC
EXTRN	__imp__strchr:PROC
;	COMDAT ??_C@_02GLFAOOJA@?$FL?4?$AA@
CONST	SEGMENT
??_C@_02GLFAOOJA@?$FL?4?$AA@ DB '[.', 00H		; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?makePath@Path@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@4@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?makePath@Path@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@4@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?makePath@Path@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@4@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?makePath@Path@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@4@@Z$2
__ehfuncinfo$?makePath@Path@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@4@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?makePath@Path@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@4@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?makePath@Path@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@4@@Z
_TEXT	SEGMENT
tv172 = -148						; size = 4
tv94 = -144						; size = 4
_this$ = -140						; size = 4
$T31659 = -136						; size = 28
$T31658 = -108						; size = 36
$T31657 = -72						; size = 36
_beginName$21981 = -36					; size = 4
_index$21969 = -32					; size = 4
_end$ = -28						; size = 4
_itInArg$ = -24						; size = 8
_current$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_path$ = 8						; size = 4
_in$ = 12						; size = 4
?makePath@Path@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@4@@Z PROC ; Json::Path::makePath, COMDAT
; _this$ = ecx

; 1639 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?makePath@Path@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@4@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 136				; 00000088H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1640 :    const char *current = path.c_str();

	mov	ecx, DWORD PTR _path$[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR _current$[ebp], eax

; 1641 :    const char *end = current + path.length();

	mov	ecx, DWORD PTR _path$[ebp]
	call	DWORD PTR __imp_?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
	add	eax, DWORD PTR _current$[ebp]
	mov	DWORD PTR _end$[ebp], eax

; 1642 :    InArgs::const_iterator itInArg = in.begin();

	lea	eax, DWORD PTR _itInArg$[ebp]
	push	eax
	mov	ecx, DWORD PTR _in$[ebp]
	call	?begin@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@2@XZ ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::begin
$LN17@makePath:

; 1643 :    while ( current != end )

	mov	ecx, DWORD PTR _current$[ebp]
	cmp	ecx, DWORD PTR _end$[ebp]
	je	$LN18@makePath

; 1644 :    {
; 1645 :       if ( *current == '[' )

	mov	edx, DWORD PTR _current$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 91					; 0000005bH
	jne	$LN15@makePath

; 1646 :       {
; 1647 :          ++current;

	mov	ecx, DWORD PTR _current$[ebp]
	add	ecx, 1
	mov	DWORD PTR _current$[ebp], ecx

; 1648 :          if ( *current == '%' )

	mov	edx, DWORD PTR _current$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 37					; 00000025H
	jne	SHORT $LN14@makePath

; 1649 :             addPathInArg( path, in, itInArg, PathArgument::kindIndex );

	push	1
	lea	ecx, DWORD PTR _itInArg$[ebp]
	push	ecx
	mov	edx, DWORD PTR _in$[ebp]
	push	edx
	mov	eax, DWORD PTR _path$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?addPathInArg@Path@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@4@AAV?$_Vector_const_iterator@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@4@W4Kind@PathArgument@2@@Z ; Json::Path::addPathInArg

; 1650 :          else

	jmp	SHORT $LN13@makePath
$LN14@makePath:

; 1651 :          {
; 1652 :             Value::UInt index = 0;

	mov	DWORD PTR _index$21969[ebp], 0
	jmp	SHORT $LN12@makePath
$LN11@makePath:

; 1653 :             for ( ; current != end && *current >= '0'  &&  *current <= '9'; ++current )

	mov	ecx, DWORD PTR _current$[ebp]
	add	ecx, 1
	mov	DWORD PTR _current$[ebp], ecx
$LN12@makePath:
	mov	edx, DWORD PTR _current$[ebp]
	cmp	edx, DWORD PTR _end$[ebp]
	je	SHORT $LN10@makePath
	mov	eax, DWORD PTR _current$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 48					; 00000030H
	jl	SHORT $LN10@makePath
	mov	edx, DWORD PTR _current$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 57					; 00000039H
	jg	SHORT $LN10@makePath

; 1654 :                index = index * 10 + Value::UInt(*current - '0');

	mov	ecx, DWORD PTR _index$21969[ebp]
	imul	ecx, 10					; 0000000aH
	mov	edx, DWORD PTR _current$[ebp]
	movsx	eax, BYTE PTR [edx]
	lea	ecx, DWORD PTR [ecx+eax-48]
	mov	DWORD PTR _index$21969[ebp], ecx
	jmp	SHORT $LN11@makePath
$LN10@makePath:

; 1655 :             args_.push_back( index );

	mov	edx, DWORD PTR _index$21969[ebp]
	push	edx
	lea	ecx, DWORD PTR $T31657[ebp]
	call	??0PathArgument@Json@@QAE@I@Z		; Json::PathArgument::PathArgument
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR $T31657[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?push_back@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAEXABVPathArgument@Json@@@Z ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::push_back
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T31657[ebp]
	call	??1PathArgument@Json@@QAE@XZ
$LN13@makePath:

; 1656 :          }
; 1657 :          if ( current == end  ||  *current++ != ']' )

	mov	ecx, DWORD PTR _current$[ebp]
	cmp	ecx, DWORD PTR _end$[ebp]
	je	SHORT $LN8@makePath
	mov	edx, DWORD PTR _current$[ebp]
	movsx	eax, BYTE PTR [edx]
	mov	ecx, DWORD PTR _current$[ebp]
	add	ecx, 1
	mov	DWORD PTR _current$[ebp], ecx
	cmp	eax, 93					; 0000005dH
	je	SHORT $LN9@makePath
$LN8@makePath:

; 1658 :             invalidPath( path, int(current - path.c_str()) );

	mov	ecx, DWORD PTR _path$[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	edx, DWORD PTR _current$[ebp]
	sub	edx, eax
	push	edx
	mov	eax, DWORD PTR _path$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?invalidPath@Path@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z ; Json::Path::invalidPath
$LN9@makePath:

; 1659 :       }

	jmp	$LN7@makePath
$LN15@makePath:

; 1660 :       else if ( *current == '%' )

	mov	ecx, DWORD PTR _current$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 37					; 00000025H
	jne	SHORT $LN6@makePath

; 1661 :       {
; 1662 :          addPathInArg( path, in, itInArg, PathArgument::kindKey );

	push	2
	lea	eax, DWORD PTR _itInArg$[ebp]
	push	eax
	mov	ecx, DWORD PTR _in$[ebp]
	push	ecx
	mov	edx, DWORD PTR _path$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?addPathInArg@Path@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@4@AAV?$_Vector_const_iterator@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@4@W4Kind@PathArgument@2@@Z ; Json::Path::addPathInArg

; 1663 :          ++current;

	mov	eax, DWORD PTR _current$[ebp]
	add	eax, 1
	mov	DWORD PTR _current$[ebp], eax
	jmp	$LN7@makePath
$LN6@makePath:

; 1664 :       }
; 1665 :       else if ( *current == '.' )

	mov	ecx, DWORD PTR _current$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 46					; 0000002eH
	jne	SHORT $LN4@makePath

; 1666 :       {
; 1667 :          ++current;

	mov	eax, DWORD PTR _current$[ebp]
	add	eax, 1
	mov	DWORD PTR _current$[ebp], eax

; 1668 :       }
; 1669 :       else

	jmp	$LN7@makePath
$LN4@makePath:

; 1670 :       {
; 1671 :          const char *beginName = current;

	mov	ecx, DWORD PTR _current$[ebp]
	mov	DWORD PTR _beginName$21981[ebp], ecx
$LN2@makePath:

; 1672 :          while ( current != end  &&  !strchr( "[.", *current ) )

	mov	edx, DWORD PTR _current$[ebp]
	cmp	edx, DWORD PTR _end$[ebp]
	je	SHORT $LN1@makePath
	mov	eax, DWORD PTR _current$[ebp]
	movsx	ecx, BYTE PTR [eax]
	push	ecx
	push	OFFSET ??_C@_02GLFAOOJA@?$FL?4?$AA@
	call	DWORD PTR __imp__strchr
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN1@makePath

; 1673 :             ++current;

	mov	edx, DWORD PTR _current$[ebp]
	add	edx, 1
	mov	DWORD PTR _current$[ebp], edx
	jmp	SHORT $LN2@makePath
$LN1@makePath:

; 1674 :          args_.push_back( std::string( beginName, current ) );

	mov	eax, DWORD PTR _current$[ebp]
	push	eax
	mov	ecx, DWORD PTR _beginName$21981[ebp]
	push	ecx
	lea	ecx, DWORD PTR $T31659[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD0@Z
	mov	DWORD PTR tv94[ebp], eax
	mov	edx, DWORD PTR tv94[ebp]
	mov	DWORD PTR tv172[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	mov	eax, DWORD PTR tv172[ebp]
	push	eax
	lea	ecx, DWORD PTR $T31658[ebp]
	call	??0PathArgument@Json@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::PathArgument::PathArgument
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR $T31658[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?push_back@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAEXABVPathArgument@Json@@@Z ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::push_back
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR $T31658[ebp]
	call	??1PathArgument@Json@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T31659[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN7@makePath:

; 1675 :       }
; 1676 :    }

	jmp	$LN17@makePath
$LN18@makePath:

; 1677 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?makePath@Path@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@4@@Z$0:
	lea	ecx, DWORD PTR $T31657[ebp]
	jmp	??1PathArgument@Json@@QAE@XZ
__unwindfunclet$?makePath@Path@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@4@@Z$1:
	lea	ecx, DWORD PTR $T31659[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?makePath@Path@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@4@@Z$2:
	lea	ecx, DWORD PTR $T31658[ebp]
	jmp	??1PathArgument@Json@@QAE@XZ
__ehhandler$?makePath@Path@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@4@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-140]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?makePath@Path@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@4@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?makePath@Path@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@4@@Z ENDP ; Json::Path::makePath
; Function compile flags: /Odtp
;	COMDAT ??1PathArgument@Json@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1PathArgument@Json@@QAE@XZ PROC			; Json::PathArgument::~PathArgument, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1PathArgument@Json@@QAE@XZ ENDP			; Json::PathArgument::~PathArgument
_TEXT	ENDS
PUBLIC	??D?$_Vector_const_iterator@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QBEABQBVPathArgument@Json@@XZ ; std::_Vector_const_iterator<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::operator*
PUBLIC	??8?$_Vector_const_iterator@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::operator==
PUBLIC	?end@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@2@XZ ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::end
; Function compile flags: /Odtp
;	COMDAT ?addPathInArg@Path@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@4@AAV?$_Vector_const_iterator@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@4@W4Kind@PathArgument@2@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
$T31674 = -8						; size = 8
_path$ = 8						; size = 4
_in$ = 12						; size = 4
_itInArg$ = 16						; size = 4
_kind$ = 20						; size = 4
?addPathInArg@Path@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@4@AAV?$_Vector_const_iterator@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@4@W4Kind@PathArgument@2@@Z PROC ; Json::Path::addPathInArg, COMDAT
; _this$ = ecx

; 1685 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1686 :    if ( itInArg == in.end() )

	lea	eax, DWORD PTR $T31674[ebp]
	push	eax
	mov	ecx, DWORD PTR _in$[ebp]
	call	?end@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@2@XZ ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::end
	push	eax
	mov	ecx, DWORD PTR _itInArg$[ebp]
	call	??8?$_Vector_const_iterator@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::operator==
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN4@addPathInA
	jmp	SHORT $LN5@addPathInA
$LN4@addPathInA:

; 1687 :    {
; 1688 :       // Error: missing argument %d
; 1689 :    }
; 1690 :    else if ( (*itInArg)->kind_ != kind )

	mov	ecx, DWORD PTR _itInArg$[ebp]
	call	??D?$_Vector_const_iterator@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QBEABQBVPathArgument@Json@@XZ ; std::_Vector_const_iterator<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::operator*
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edx+32]
	cmp	eax, DWORD PTR _kind$[ebp]
	je	SHORT $LN2@addPathInA

; 1691 :    {
; 1692 :       // Error: bad argument type
; 1693 :    }
; 1694 :    else

	jmp	SHORT $LN5@addPathInA
$LN2@addPathInA:

; 1695 :    {
; 1696 :       args_.push_back( **itInArg );

	mov	ecx, DWORD PTR _itInArg$[ebp]
	call	??D?$_Vector_const_iterator@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QBEABQBVPathArgument@Json@@XZ ; std::_Vector_const_iterator<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::operator*
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?push_back@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAEXABVPathArgument@Json@@@Z ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::push_back
$LN5@addPathInA:

; 1697 :    }
; 1698 : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?addPathInArg@Path@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@4@AAV?$_Vector_const_iterator@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@4@W4Kind@PathArgument@2@@Z ENDP ; Json::Path::addPathInArg
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?invalidPath@Path@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_path$ = 8						; size = 4
_location$ = 12						; size = 4
?invalidPath@Path@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z PROC ; Json::Path::invalidPath, COMDAT
; _this$ = ecx

; 1704 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1705 :    // Error: invalid path.
; 1706 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?invalidPath@Path@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z ENDP ; Json::Path::invalidPath
_TEXT	ENDS
PUBLIC	??D?$_Vector_const_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBEABVPathArgument@Json@@XZ ; std::_Vector_const_iterator<Json::PathArgument,std::allocator<Json::PathArgument> >::operator*
PUBLIC	??9?$_Vector_const_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Json::PathArgument,std::allocator<Json::PathArgument> >::operator!=
PUBLIC	?end@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBE?AV?$_Vector_const_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@2@XZ ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::end
PUBLIC	??E?$_Vector_const_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<Json::PathArgument,std::allocator<Json::PathArgument> >::operator++
PUBLIC	?begin@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBE?AV?$_Vector_const_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@2@XZ ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::begin
PUBLIC	?resolve@Path@Json@@QBEABVValue@2@ABV32@@Z	; Json::Path::resolve
; Function compile flags: /Odtp
;	COMDAT ?resolve@Path@Json@@QBEABVValue@2@ABV32@@Z
_TEXT	SEGMENT
_this$ = -28						; size = 4
$T31679 = -24						; size = 8
_arg$22195 = -16					; size = 4
_it$22189 = -12						; size = 8
_node$ = -4						; size = 4
_root$ = 8						; size = 4
?resolve@Path@Json@@QBEABVValue@2@ABV32@@Z PROC		; Json::Path::resolve, COMDAT
; _this$ = ecx

; 1711 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 1712 :    const Value *node = &root;

	mov	eax, DWORD PTR _root$[ebp]
	mov	DWORD PTR _node$[ebp], eax

; 1713 :    for ( Args::const_iterator it = args_.begin(); it != args_.end(); ++it )

	lea	ecx, DWORD PTR _it$22189[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBE?AV?$_Vector_const_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@2@XZ ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::begin
	jmp	SHORT $LN10@resolve
$LN9@resolve:
	lea	ecx, DWORD PTR _it$22189[ebp]
	call	??E?$_Vector_const_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<Json::PathArgument,std::allocator<Json::PathArgument> >::operator++
$LN10@resolve:
	lea	edx, DWORD PTR $T31679[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBE?AV?$_Vector_const_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@2@XZ ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::end
	push	eax
	lea	ecx, DWORD PTR _it$22189[ebp]
	call	??9?$_Vector_const_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Json::PathArgument,std::allocator<Json::PathArgument> >::operator!=
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN8@resolve

; 1714 :    {
; 1715 :       const PathArgument &arg = *it;

	lea	ecx, DWORD PTR _it$22189[ebp]
	call	??D?$_Vector_const_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBEABVPathArgument@Json@@XZ ; std::_Vector_const_iterator<Json::PathArgument,std::allocator<Json::PathArgument> >::operator*
	mov	DWORD PTR _arg$22195[ebp], eax

; 1716 :       if ( arg.kind_ == PathArgument::kindIndex )

	mov	ecx, DWORD PTR _arg$22195[ebp]
	cmp	DWORD PTR [ecx+32], 1
	jne	SHORT $LN7@resolve

; 1717 :       {
; 1718 :          if ( !node->isArray()  ||  node->isValidIndex( arg.index_ ) )

	mov	ecx, DWORD PTR _node$[ebp]
	call	?isArray@Value@Json@@QBE_NXZ		; Json::Value::isArray
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN6@resolve
	mov	eax, DWORD PTR _arg$22195[ebp]
	mov	ecx, DWORD PTR [eax+28]
	push	ecx
	mov	ecx, DWORD PTR _node$[ebp]
	call	?isValidIndex@Value@Json@@QBE_NI@Z	; Json::Value::isValidIndex
$LN6@resolve:

; 1719 :          {
; 1720 :             // Error: unable to resolve path (array value expected at position...
; 1721 :          }
; 1722 :          node = &((*node)[arg.index_]);

	mov	eax, DWORD PTR _arg$22195[ebp]
	mov	ecx, DWORD PTR [eax+28]
	push	ecx
	mov	ecx, DWORD PTR _node$[ebp]
	call	??AValue@Json@@QBEABV01@I@Z		; Json::Value::operator[]
	mov	DWORD PTR _node$[ebp], eax
	jmp	SHORT $LN4@resolve
$LN7@resolve:

; 1723 :       }
; 1724 :       else if ( arg.kind_ == PathArgument::kindKey )

	mov	edx, DWORD PTR _arg$22195[ebp]
	cmp	DWORD PTR [edx+32], 2
	jne	SHORT $LN4@resolve

; 1725 :       {
; 1726 :          if ( !node->isObject() )

	mov	ecx, DWORD PTR _node$[ebp]
	call	?isObject@Value@Json@@QBE_NXZ		; Json::Value::isObject

; 1727 :          {
; 1728 :             // Error: unable to resolve path (object value expected at position...)
; 1729 :          }
; 1730 :          node = &((*node)[arg.key_]);

	mov	ecx, DWORD PTR _arg$22195[ebp]
	push	ecx
	mov	ecx, DWORD PTR _node$[ebp]
	call	??AValue@Json@@QBEABV01@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::Value::operator[]
	mov	DWORD PTR _node$[ebp], eax
$LN4@resolve:

; 1731 :          if ( node == &Value::null )
; 1732 :          {
; 1733 :             // Error: unable to resolve path (object has no member named '' at position...)
; 1734 :          }
; 1735 :       }
; 1736 :    }

	jmp	$LN9@resolve
$LN8@resolve:

; 1737 :    return *node;

	mov	eax, DWORD PTR _node$[ebp]

; 1738 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?resolve@Path@Json@@QBEABVValue@2@ABV32@@Z ENDP		; Json::Path::resolve
_TEXT	ENDS
PUBLIC	?resolve@Path@Json@@QBE?AVValue@2@ABV32@0@Z	; Json::Path::resolve
; Function compile flags: /Odtp
;	COMDAT ?resolve@Path@Json@@QBE?AVValue@2@ABV32@0@Z
_TEXT	SEGMENT
_this$ = -32						; size = 4
$T31684 = -28						; size = 4
$T31682 = -24						; size = 8
_arg$22216 = -16					; size = 4
_it$22210 = -12						; size = 8
_node$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_root$ = 12						; size = 4
_defaultValue$ = 16					; size = 4
?resolve@Path@Json@@QBE?AVValue@2@ABV32@0@Z PROC	; Json::Path::resolve, COMDAT
; _this$ = ecx

; 1744 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T31684[ebp], 0

; 1745 :    const Value *node = &root;

	mov	eax, DWORD PTR _root$[ebp]
	mov	DWORD PTR _node$[ebp], eax

; 1746 :    for ( Args::const_iterator it = args_.begin(); it != args_.end(); ++it )

	lea	ecx, DWORD PTR _it$22210[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBE?AV?$_Vector_const_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@2@XZ ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::begin
	jmp	SHORT $LN10@resolve@2
$LN9@resolve@2:
	lea	ecx, DWORD PTR _it$22210[ebp]
	call	??E?$_Vector_const_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<Json::PathArgument,std::allocator<Json::PathArgument> >::operator++
$LN10@resolve@2:
	lea	edx, DWORD PTR $T31682[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBE?AV?$_Vector_const_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@2@XZ ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::end
	push	eax
	lea	ecx, DWORD PTR _it$22210[ebp]
	call	??9?$_Vector_const_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Json::PathArgument,std::allocator<Json::PathArgument> >::operator!=
	movzx	eax, al
	test	eax, eax
	je	$LN8@resolve@2

; 1747 :    {
; 1748 :       const PathArgument &arg = *it;

	lea	ecx, DWORD PTR _it$22210[ebp]
	call	??D?$_Vector_const_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBEABVPathArgument@Json@@XZ ; std::_Vector_const_iterator<Json::PathArgument,std::allocator<Json::PathArgument> >::operator*
	mov	DWORD PTR _arg$22216[ebp], eax

; 1749 :       if ( arg.kind_ == PathArgument::kindIndex )

	mov	ecx, DWORD PTR _arg$22216[ebp]
	cmp	DWORD PTR [ecx+32], 1
	jne	SHORT $LN7@resolve@2

; 1750 :       {
; 1751 :          if ( !node->isArray()  ||  node->isValidIndex( arg.index_ ) )

	mov	ecx, DWORD PTR _node$[ebp]
	call	?isArray@Value@Json@@QBE_NXZ		; Json::Value::isArray
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN5@resolve@2
	mov	eax, DWORD PTR _arg$22216[ebp]
	mov	ecx, DWORD PTR [eax+28]
	push	ecx
	mov	ecx, DWORD PTR _node$[ebp]
	call	?isValidIndex@Value@Json@@QBE_NI@Z	; Json::Value::isValidIndex
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN6@resolve@2
$LN5@resolve@2:

; 1752 :             return defaultValue;

	mov	eax, DWORD PTR _defaultValue$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Value@Json@@QAE@ABV01@@Z		; Json::Value::Value
	mov	ecx, DWORD PTR $T31684[ebp]
	or	ecx, 1
	mov	DWORD PTR $T31684[ebp], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN11@resolve@2
$LN6@resolve@2:

; 1753 :          node = &((*node)[arg.index_]);

	mov	edx, DWORD PTR _arg$22216[ebp]
	mov	eax, DWORD PTR [edx+28]
	push	eax
	mov	ecx, DWORD PTR _node$[ebp]
	call	??AValue@Json@@QBEABV01@I@Z		; Json::Value::operator[]
	mov	DWORD PTR _node$[ebp], eax
	jmp	SHORT $LN4@resolve@2
$LN7@resolve@2:

; 1754 :       }
; 1755 :       else if ( arg.kind_ == PathArgument::kindKey )

	mov	ecx, DWORD PTR _arg$22216[ebp]
	cmp	DWORD PTR [ecx+32], 2
	jne	SHORT $LN4@resolve@2

; 1756 :       {
; 1757 :          if ( !node->isObject() )

	mov	ecx, DWORD PTR _node$[ebp]
	call	?isObject@Value@Json@@QBE_NXZ		; Json::Value::isObject
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN2@resolve@2

; 1758 :             return defaultValue;

	mov	eax, DWORD PTR _defaultValue$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Value@Json@@QAE@ABV01@@Z		; Json::Value::Value
	mov	ecx, DWORD PTR $T31684[ebp]
	or	ecx, 1
	mov	DWORD PTR $T31684[ebp], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN11@resolve@2
$LN2@resolve@2:

; 1759 :          node = &((*node)[arg.key_]);

	mov	edx, DWORD PTR _arg$22216[ebp]
	push	edx
	mov	ecx, DWORD PTR _node$[ebp]
	call	??AValue@Json@@QBEABV01@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::Value::operator[]
	mov	DWORD PTR _node$[ebp], eax

; 1760 :          if ( node == &Value::null )

	cmp	DWORD PTR _node$[ebp], OFFSET ?null@Value@Json@@2V12@B ; Json::Value::null
	jne	SHORT $LN4@resolve@2

; 1761 :             return defaultValue;

	mov	eax, DWORD PTR _defaultValue$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Value@Json@@QAE@ABV01@@Z		; Json::Value::Value
	mov	ecx, DWORD PTR $T31684[ebp]
	or	ecx, 1
	mov	DWORD PTR $T31684[ebp], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN11@resolve@2
$LN4@resolve@2:

; 1762 :       }
; 1763 :    }

	jmp	$LN9@resolve@2
$LN8@resolve@2:

; 1764 :    return *node;

	mov	edx, DWORD PTR _node$[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Value@Json@@QAE@ABV01@@Z		; Json::Value::Value
	mov	eax, DWORD PTR $T31684[ebp]
	or	eax, 1
	mov	DWORD PTR $T31684[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN11@resolve@2:

; 1765 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?resolve@Path@Json@@QBE?AVValue@2@ABV32@0@Z ENDP	; Json::Path::resolve
_TEXT	ENDS
PUBLIC	?make@Path@Json@@QBEAAVValue@2@AAV32@@Z		; Json::Path::make
; Function compile flags: /Odtp
;	COMDAT ?make@Path@Json@@QBEAAVValue@2@AAV32@@Z
_TEXT	SEGMENT
_this$ = -28						; size = 4
$T31688 = -24						; size = 8
_arg$22235 = -16					; size = 4
_it$22229 = -12						; size = 8
_node$ = -4						; size = 4
_root$ = 8						; size = 4
?make@Path@Json@@QBEAAVValue@2@AAV32@@Z PROC		; Json::Path::make, COMDAT
; _this$ = ecx

; 1770 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 1771 :    Value *node = &root;

	mov	eax, DWORD PTR _root$[ebp]
	mov	DWORD PTR _node$[ebp], eax

; 1772 :    for ( Args::const_iterator it = args_.begin(); it != args_.end(); ++it )

	lea	ecx, DWORD PTR _it$22229[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBE?AV?$_Vector_const_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@2@XZ ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::begin
	jmp	SHORT $LN8@make
$LN7@make:
	lea	ecx, DWORD PTR _it$22229[ebp]
	call	??E?$_Vector_const_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<Json::PathArgument,std::allocator<Json::PathArgument> >::operator++
$LN8@make:
	lea	edx, DWORD PTR $T31688[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBE?AV?$_Vector_const_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@2@XZ ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::end
	push	eax
	lea	ecx, DWORD PTR _it$22229[ebp]
	call	??9?$_Vector_const_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Json::PathArgument,std::allocator<Json::PathArgument> >::operator!=
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN6@make

; 1773 :    {
; 1774 :       const PathArgument &arg = *it;

	lea	ecx, DWORD PTR _it$22229[ebp]
	call	??D?$_Vector_const_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBEABVPathArgument@Json@@XZ ; std::_Vector_const_iterator<Json::PathArgument,std::allocator<Json::PathArgument> >::operator*
	mov	DWORD PTR _arg$22235[ebp], eax

; 1775 :       if ( arg.kind_ == PathArgument::kindIndex )

	mov	ecx, DWORD PTR _arg$22235[ebp]
	cmp	DWORD PTR [ecx+32], 1
	jne	SHORT $LN5@make

; 1776 :       {
; 1777 :          if ( !node->isArray() )

	mov	ecx, DWORD PTR _node$[ebp]
	call	?isArray@Value@Json@@QBE_NXZ		; Json::Value::isArray

; 1778 :          {
; 1779 :             // Error: node is not an array at position ...
; 1780 :          }
; 1781 :          node = &((*node)[arg.index_]);

	mov	eax, DWORD PTR _arg$22235[ebp]
	mov	ecx, DWORD PTR [eax+28]
	push	ecx
	mov	ecx, DWORD PTR _node$[ebp]
	call	??AValue@Json@@QAEAAV01@I@Z		; Json::Value::operator[]
	mov	DWORD PTR _node$[ebp], eax
	jmp	SHORT $LN3@make
$LN5@make:

; 1782 :       }
; 1783 :       else if ( arg.kind_ == PathArgument::kindKey )

	mov	edx, DWORD PTR _arg$22235[ebp]
	cmp	DWORD PTR [edx+32], 2
	jne	SHORT $LN3@make

; 1784 :       {
; 1785 :          if ( !node->isObject() )

	mov	ecx, DWORD PTR _node$[ebp]
	call	?isObject@Value@Json@@QBE_NXZ		; Json::Value::isObject

; 1786 :          {
; 1787 :             // Error: node is not an object at position...
; 1788 :          }
; 1789 :          node = &((*node)[arg.key_]);

	mov	ecx, DWORD PTR _arg$22235[ebp]
	push	ecx
	mov	ecx, DWORD PTR _node$[ebp]
	call	??AValue@Json@@QAEAAV01@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::Value::operator[]
	mov	DWORD PTR _node$[ebp], eax
$LN3@make:

; 1790 :       }
; 1791 :    }

	jmp	SHORT $LN7@make
$LN6@make:

; 1792 :    return *node;

	mov	eax, DWORD PTR _node$[ebp]

; 1793 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?make@Path@Json@@QBEAAVValue@2@AAV32@@Z ENDP		; Json::Path::make
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IAE_NI@Z ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::_Buy
PUBLIC	??0?$_Vector_val@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IAE@V?$allocator@PBVPathArgument@Json@@@1@@Z ; std::_Vector_val<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::_Vector_val<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >
PUBLIC	??0?$allocator@PBVPathArgument@Json@@@std@@QAE@XZ ; std::allocator<Json::PathArgument const *>::allocator<Json::PathArgument const *>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 8\vc\include\vector
;	COMDAT ??0?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QAE@XZ PROC ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >, COMDAT
; _this$ = ecx

; 457  : 		{	// construct empty vector

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	call	??0?$allocator@PBVPathArgument@Json@@@std@@QAE@XZ ; std::allocator<Json::PathArgument const *>::allocator<Json::PathArgument const *>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_val@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IAE@V?$allocator@PBVPathArgument@Json@@@1@@Z ; std::_Vector_val<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::_Vector_val<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >

; 458  : 		_Buy(0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IAE_NI@Z ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::_Buy

; 459  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QAE@XZ ENDP ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IAEXXZ ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::_Tidy
; Function compile flags: /Odtp
;	COMDAT ??1?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QAE@XZ PROC ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::~vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >, COMDAT
; _this$ = ecx

; 545  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 546  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IAEXXZ ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::_Tidy

; 547  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??1?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QAE@XZ ENDP ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::~vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QAE@PAPBVPathArgument@Json@@PBU_Container_base@1@@Z ; std::_Vector_const_iterator<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::_Vector_const_iterator<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >
; Function compile flags: /Odtp
;	COMDAT ?begin@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@2@XZ PROC ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::begin, COMDAT
; _this$ = ecx

; 632  : 		{	// return iterator for beginning of nonmutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 633  : 		return (const_iterator(_Myfirst, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_const_iterator@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QAE@PAPBVPathArgument@Json@@PBU_Container_base@1@@Z ; std::_Vector_const_iterator<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::_Vector_const_iterator<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 634  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@2@XZ ENDP ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::begin
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?end@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@2@XZ PROC ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::end, COMDAT
; _this$ = ecx

; 642  : 		{	// return iterator for end of nonmutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 643  : 		return (const_iterator(_Mylast, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_const_iterator@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QAE@PAPBVPathArgument@Json@@PBU_Container_base@1@@Z ; std::_Vector_const_iterator<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::_Vector_const_iterator<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 644  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@2@XZ ENDP ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::end
_TEXT	ENDS
PUBLIC	?insert@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QAE?AV?$_Vector_iterator@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@2@V32@ABQBVPathArgument@Json@@@Z ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::insert
PUBLIC	?end@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QAE?AV?$_Vector_iterator@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@2@XZ ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::end
PUBLIC	?_Ufill@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IAEPAPBVPathArgument@Json@@PAPBV34@IABQBV34@@Z ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::_Ufill
PUBLIC	?capacity@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QBEIXZ ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::capacity
PUBLIC	?size@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QBEIXZ ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::size
; Function compile flags: /Odtp
;	COMDAT ?push_back@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QAEXABQBVPathArgument@Json@@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T31701 = -16						; size = 8
$T31700 = -8						; size = 8
__Val$ = 8						; size = 4
?push_back@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QAEXABQBVPathArgument@Json@@@Z PROC ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::push_back, COMDAT
; _this$ = ecx

; 786  : 		{	// insert element at end

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 787  : 		if (size() < capacity())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QBEIXZ ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?capacity@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QBEIXZ ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::capacity
	cmp	esi, eax
	jae	SHORT $LN2@push_back

; 788  : 
; 789  :  #if _HAS_ITERATOR_DEBUGGING
; 790  : 			{ // room at end, construct it there
; 791  : 			_Orphan_range(_Mylast, _Mylast);
; 792  : 			_Mylast = _Ufill(_Mylast, 1, _Val);
; 793  : 			}
; 794  : 
; 795  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 796  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Ufill@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IAEPAPBVPathArgument@Json@@PAPBV34@IABQBV34@@Z ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::_Ufill
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 797  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 798  : 
; 799  : 		else

	jmp	SHORT $LN3@push_back
$LN2@push_back:

; 800  : 			insert(end(), _Val);

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	lea	eax, DWORD PTR $T31700[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QAE?AV?$_Vector_iterator@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@2@XZ ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::end
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	lea	eax, DWORD PTR $T31701[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?insert@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QAE?AV?$_Vector_iterator@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@2@V32@ABQBVPathArgument@Json@@@Z ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::insert
$LN3@push_back:

; 801  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?push_back@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QAEXABQBVPathArgument@Json@@@Z ENDP ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::push_back
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAE_NI@Z ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::_Buy
PUBLIC	??0?$_Vector_val@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAE@V?$allocator@VPathArgument@Json@@@1@@Z ; std::_Vector_val<Json::PathArgument,std::allocator<Json::PathArgument> >::_Vector_val<Json::PathArgument,std::allocator<Json::PathArgument> >
PUBLIC	??0?$allocator@VPathArgument@Json@@@std@@QAE@XZ	; std::allocator<Json::PathArgument>::allocator<Json::PathArgument>
; Function compile flags: /Odtp
;	COMDAT ??0?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAE@XZ PROC ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::vector<Json::PathArgument,std::allocator<Json::PathArgument> >, COMDAT
; _this$ = ecx

; 457  : 		{	// construct empty vector

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	call	??0?$allocator@VPathArgument@Json@@@std@@QAE@XZ ; std::allocator<Json::PathArgument>::allocator<Json::PathArgument>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_val@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAE@V?$allocator@VPathArgument@Json@@@1@@Z ; std::_Vector_val<Json::PathArgument,std::allocator<Json::PathArgument> >::_Vector_val<Json::PathArgument,std::allocator<Json::PathArgument> >

; 458  : 		_Buy(0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAE_NI@Z ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::_Buy

; 459  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAE@XZ ENDP ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::vector<Json::PathArgument,std::allocator<Json::PathArgument> >
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAEXXZ ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::_Tidy
; Function compile flags: /Odtp
;	COMDAT ??1?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAE@XZ PROC ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::~vector<Json::PathArgument,std::allocator<Json::PathArgument> >, COMDAT
; _this$ = ecx

; 545  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 546  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAEXXZ ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::_Tidy

; 547  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??1?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAE@XZ ENDP ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::~vector<Json::PathArgument,std::allocator<Json::PathArgument> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAE@PAVPathArgument@Json@@PBU_Container_base@1@@Z ; std::_Vector_const_iterator<Json::PathArgument,std::allocator<Json::PathArgument> >::_Vector_const_iterator<Json::PathArgument,std::allocator<Json::PathArgument> >
; Function compile flags: /Odtp
;	COMDAT ?begin@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBE?AV?$_Vector_const_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBE?AV?$_Vector_const_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@2@XZ PROC ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::begin, COMDAT
; _this$ = ecx

; 632  : 		{	// return iterator for beginning of nonmutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 633  : 		return (const_iterator(_Myfirst, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_const_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAE@PAVPathArgument@Json@@PBU_Container_base@1@@Z ; std::_Vector_const_iterator<Json::PathArgument,std::allocator<Json::PathArgument> >::_Vector_const_iterator<Json::PathArgument,std::allocator<Json::PathArgument> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 634  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBE?AV?$_Vector_const_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@2@XZ ENDP ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::begin
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?end@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBE?AV?$_Vector_const_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBE?AV?$_Vector_const_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@2@XZ PROC ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::end, COMDAT
; _this$ = ecx

; 642  : 		{	// return iterator for end of nonmutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 643  : 		return (const_iterator(_Mylast, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_const_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAE@PAVPathArgument@Json@@PBU_Container_base@1@@Z ; std::_Vector_const_iterator<Json::PathArgument,std::allocator<Json::PathArgument> >::_Vector_const_iterator<Json::PathArgument,std::allocator<Json::PathArgument> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 644  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBE?AV?$_Vector_const_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@2@XZ ENDP ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::end
_TEXT	ENDS
PUBLIC	?insert@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAE?AV?$_Vector_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@2@V32@ABVPathArgument@Json@@@Z ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::insert
PUBLIC	?end@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAE?AV?$_Vector_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@2@XZ ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::end
PUBLIC	?_Ufill@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAEPAVPathArgument@Json@@PAV34@IABV34@@Z ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::_Ufill
PUBLIC	?capacity@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBEIXZ ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::capacity
PUBLIC	?size@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBEIXZ ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::size
; Function compile flags: /Odtp
;	COMDAT ?push_back@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAEXABVPathArgument@Json@@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T31714 = -16						; size = 8
$T31713 = -8						; size = 8
__Val$ = 8						; size = 4
?push_back@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAEXABVPathArgument@Json@@@Z PROC ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::push_back, COMDAT
; _this$ = ecx

; 786  : 		{	// insert element at end

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 787  : 		if (size() < capacity())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBEIXZ ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?capacity@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBEIXZ ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::capacity
	cmp	esi, eax
	jae	SHORT $LN2@push_back@2

; 788  : 
; 789  :  #if _HAS_ITERATOR_DEBUGGING
; 790  : 			{ // room at end, construct it there
; 791  : 			_Orphan_range(_Mylast, _Mylast);
; 792  : 			_Mylast = _Ufill(_Mylast, 1, _Val);
; 793  : 			}
; 794  : 
; 795  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 796  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Ufill@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAEPAVPathArgument@Json@@PAV34@IABV34@@Z ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::_Ufill
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 797  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 798  : 
; 799  : 		else

	jmp	SHORT $LN3@push_back@2
$LN2@push_back@2:

; 800  : 			insert(end(), _Val);

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	lea	eax, DWORD PTR $T31713[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAE?AV?$_Vector_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@2@XZ ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::end
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	lea	eax, DWORD PTR $T31714[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?insert@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAE?AV?$_Vector_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@2@V32@ABVPathArgument@Json@@@Z ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::insert
$LN3@push_back@2:

; 801  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?push_back@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAEXABVPathArgument@Json@@@Z ENDP ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::push_back
_TEXT	ENDS
PUBLIC	??0?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE@ABU?$less@VCZString@Value@Json@@@1@ABV?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@1@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >
PUBLIC	??0?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@QAE@XZ ; std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >::allocator<std::pair<Json::Value::CZString const ,Json::Value> >
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 8\vc\include\map
;	COMDAT ??0?$map@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T31718 = -2						; size = 1
$T31717 = -1						; size = 1
??0?$map@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@@std@@QAE@XZ PROC ; std::map<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > >::map<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > >, COMDAT
; _this$ = ecx

; 107  : 		{	// construct empty map from defaults

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR $T31717[ebp]
	call	??0?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@QAE@XZ ; std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >::allocator<std::pair<Json::Value::CZString const ,Json::Value> >
	push	eax
	lea	eax, DWORD PTR $T31718[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE@ABU?$less@VCZString@Value@Json@@@1@ABV?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@1@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >

; 108  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$map@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@@std@@QAE@XZ ENDP ; std::map<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > >::map<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > >
_TEXT	ENDS
PUBLIC	?_Tidy@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Tidy
PUBLIC	?_Copy@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEXABV12@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Copy
PUBLIC	?_Init@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Init
PUBLIC	??0?$_Tree_val@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAE@ABU?$less@VCZString@Value@Json@@@1@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@1@@Z ; std::_Tree_val<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Tree_val<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >
PUBLIC	?key_comp@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBE?AU?$less@VCZString@Value@Json@@@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::key_comp
PUBLIC	?get_allocator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBE?AV?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::get_allocator
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 8\vc\include\xtree
xdata$x	SEGMENT
__catchsym$??0?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE@ABV01@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??0?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE@ABV01@@Z$0
__unwindtable$??0?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??0?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE@ABV01@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??0?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE@ABV01@@Z$2
__ehfuncinfo$??0?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE@ABV01@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE@ABV01@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??0?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -28						; size = 4
$T31723 = -21						; size = 1
$T31722 = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Right$ = 8						; size = 4
??0?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE@ABV01@@Z PROC ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >, COMDAT
; _this$ = ecx

; 514  : 		{	// construct tree by copying _Right

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	eax, esp
	mov	DWORD PTR $T31722[ebp], esp
	push	eax
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?get_allocator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBE?AV?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::get_allocator
	lea	ecx, DWORD PTR $T31723[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?key_comp@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBE?AU?$less@VCZString@Value@Json@@@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::key_comp
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Tree_val@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAE@ABU?$less@VCZString@Value@Json@@@1@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@1@@Z ; std::_Tree_val<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Tree_val<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >

; 515  : 		_Init();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Init@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Init

; 516  : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 517  : 		_Copy(_Right);

	mov	edx, DWORD PTR __Right$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Copy@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEXABV12@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Copy
	jmp	SHORT $LN4@Tree
__catch$??0?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE@ABV01@@Z$0:

; 518  : 		_CATCH_ALL
; 519  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Tidy

; 520  : 		_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
	mov	eax, $LN2@Tree
	ret	0
$LN4@Tree:

; 521  : 		_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
$LN2@Tree:

; 522  : 		}

	mov	eax, DWORD PTR _this$[ebp]
$LN3@Tree:
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??0?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-32]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE@ABV01@@Z ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >
; Function compile flags: /Odtp
;	COMDAT ??1?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::~_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >, COMDAT
; _this$ = ecx

; 525  : 		{	// destroy tree

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 526  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Tidy

; 527  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::~_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >
_TEXT	ENDS
PUBLIC	??0iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PBV12@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::iterator::iterator
PUBLIC	?_Lmost@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Lmost
; Function compile flags: /Odtp
;	COMDAT ?begin@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@XZ PROC ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::begin, COMDAT
; _this$ = ecx

; 541  : 		{	// return iterator for beginning of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 542  : 		return (_TREE_ITERATOR(_Lmost()));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lmost@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Lmost
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PBV12@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::iterator::iterator
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 543  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::begin
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@XZ PROC ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::end, COMDAT
; _this$ = ecx

; 551  : 		{	// return iterator for end of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 552  : 		return (_TREE_ITERATOR(_Myhead));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PBV12@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::iterator::iterator
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 553  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::end
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?size@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBEIXZ PROC ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::size, COMDAT
; _this$ = ecx

; 581  : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 582  : 		return (_Mysize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]

; 583  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::size
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?empty@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?empty@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBE_NXZ PROC ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::empty, COMDAT
; _this$ = ecx

; 591  : 		{	// return true only if sequence is empty

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 592  : 		return (size() == 0);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::size
	neg	eax
	sbb	eax, eax
	add	eax, 1

; 593  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?empty@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBE_NXZ ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::empty
_TEXT	ENDS
PUBLIC	?insert@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBVCZString@Value@Json@@V23@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::insert
PUBLIC	?_Isnil@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Isnil
PUBLIC	?_Right@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Right
PUBLIC	?_Rmost@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Rmost
PUBLIC	??R?$less@VCZString@Value@Json@@@std@@QBE_NABVCZString@Value@Json@@0@Z ; std::less<Json::Value::CZString>::operator()
PUBLIC	?_Key@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAABVCZString@Value@Json@@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Key
PUBLIC	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator::_Mynode
PUBLIC	?_Kfn@?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@SAABVCZString@Value@Json@@ABU?$pair@$$CBVCZString@Value@Json@@V23@@2@@Z ; std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0>::_Kfn
PUBLIC	?_Insert@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@ABU?$pair@$$CBVCZString@Value@Json@@V23@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Insert
; Function compile flags: /Odtp
;	COMDAT ?insert@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@V312@ABU?$pair@$$CBVCZString@Value@Json@@V23@@2@@Z
_TEXT	SEGMENT
_this$ = -72						; size = 4
$T31754 = -68						; size = 12
$T31753 = -56						; size = 8
$T31752 = -48						; size = 8
$T31751 = -40						; size = 8
$T31750 = -32						; size = 8
$T31749 = -24						; size = 8
$T31748 = -16						; size = 8
__Next$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 8
__Val$ = 20						; size = 4
?insert@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@V312@ABU?$pair@$$CBVCZString@Value@Json@@V23@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::insert, COMDAT
; _this$ = ecx

; 645  : 		{	// try to insert node with value _Val using _Where as a hint

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	mov	DWORD PTR _this$[ebp], ecx

; 646  : 
; 647  :  #if _HAS_ITERATOR_DEBUGGING
; 648  : 		if (_Where._Mycont != this)
; 649  : 			_DEBUG_ERROR("map/set insert iterator outside range");
; 650  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 651  : 
; 652  : 		iterator _Next;

	lea	ecx, DWORD PTR __Next$[ebp]
	call	??0iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::iterator::iterator

; 653  : 
; 654  : 		if (size() == 0)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::size
	test	eax, eax
	jne	SHORT $LN32@insert

; 655  : 			return (_Insert(true, _Myhead, _Val));	// insert into empty tree

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	push	1
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@ABU?$pair@$$CBVCZString@Value@Json@@V23@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Insert
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN33@insert
	jmp	$LN31@insert
$LN32@insert:

; 656  : 		else if (this->_Multi)

	xor	ecx, ecx
	je	$LN30@insert

; 657  : 			{	// insert even if duplicate
; 658  : 			if (_Where == begin())

	lea	edx, DWORD PTR $T31748[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::begin
	push	eax
	lea	ecx, DWORD PTR __Where$[ebp]
	call	??8const_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN29@insert

; 659  : 				{	// insert at beginning if before first element
; 660  : 				if (!_DEBUG_LT_PRED(this->comp,

	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	call	?_Kfn@?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@SAABVCZString@Value@Json@@ABU?$pair@$$CBVCZString@Value@Json@@V23@@2@@Z ; std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0>::_Kfn
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR __Where$[ebp]
	call	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator::_Mynode
	push	eax
	call	?_Key@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAABVCZString@Value@Json@@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Key
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??R?$less@VCZString@Value@Json@@@std@@QBE_NABVCZString@Value@Json@@0@Z ; std::less<Json::Value::CZString>::operator()
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN28@insert

; 661  : 					_Key(_Where._Mynode()), this->_Kfn(_Val)))
; 662  : 					return (_Insert(true, _Where._Mynode(), _Val));

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Where$[ebp]
	call	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator::_Mynode
	push	eax
	push	1
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@ABU?$pair@$$CBVCZString@Value@Json@@V23@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Insert
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN33@insert
$LN28@insert:

; 663  : 				}

	jmp	$LN27@insert
$LN29@insert:

; 664  : 			else if (_Where == end())

	lea	edx, DWORD PTR $T31749[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::end
	push	eax
	lea	ecx, DWORD PTR __Where$[ebp]
	call	??8const_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN26@insert

; 665  : 				{	// insert at end if after last element
; 666  : 				if (!_DEBUG_LT_PRED(this->comp,

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rmost@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Rmost
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Key@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAABVCZString@Value@Json@@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Key
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	call	?_Kfn@?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@SAABVCZString@Value@Json@@ABU?$pair@$$CBVCZString@Value@Json@@V23@@2@@Z ; std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0>::_Kfn
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??R?$less@VCZString@Value@Json@@@std@@QBE_NABVCZString@Value@Json@@0@Z ; std::less<Json::Value::CZString>::operator()
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN25@insert

; 667  : 					this->_Kfn(_Val), _Key(_Rmost())))
; 668  : 					return (_Insert(false, _Rmost(), _Val));

	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rmost@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Rmost
	mov	edx, DWORD PTR [eax]
	push	edx
	push	0
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@ABU?$pair@$$CBVCZString@Value@Json@@V23@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Insert
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN33@insert
$LN25@insert:

; 669  : 				}
; 670  : 			else if (!_DEBUG_LT_PRED(this->comp,

	jmp	$LN27@insert
$LN26@insert:

; 671  : 				_Key(_Where._Mynode()), this->_Kfn(_Val))
; 672  : 				&& !_DEBUG_LT_PRED(this->comp,

	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	call	?_Kfn@?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@SAABVCZString@Value@Json@@ABU?$pair@$$CBVCZString@Value@Json@@V23@@2@@Z ; std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0>::_Kfn
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR __Where$[ebp]
	call	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator::_Mynode
	push	eax
	call	?_Key@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAABVCZString@Value@Json@@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Key
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??R?$less@VCZString@Value@Json@@@std@@QBE_NABVCZString@Value@Json@@0@Z ; std::less<Json::Value::CZString>::operator()
	movzx	edx, al
	test	edx, edx
	jne	$LN23@insert
	mov	eax, DWORD PTR __Where$[ebp]
	mov	DWORD PTR __Next$[ebp], eax
	mov	ecx, DWORD PTR __Where$[ebp+4]
	mov	DWORD PTR __Next$[ebp+4], ecx
	lea	ecx, DWORD PTR __Next$[ebp]
	call	??Fiterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::iterator::operator--
	mov	ecx, eax
	call	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator::_Mynode
	push	eax
	call	?_Key@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAABVCZString@Value@Json@@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Key
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	call	?_Kfn@?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@SAABVCZString@Value@Json@@ABU?$pair@$$CBVCZString@Value@Json@@V23@@2@@Z ; std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0>::_Kfn
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??R?$less@VCZString@Value@Json@@@std@@QBE_NABVCZString@Value@Json@@0@Z ; std::less<Json::Value::CZString>::operator()
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN23@insert

; 673  : 					this->_Kfn(_Val), _Key((--(_Next = _Where))._Mynode())))
; 674  : 				{	// insert before _Where
; 675  : 				if (_Isnil(_Right(_Next._Mynode())))

	lea	ecx, DWORD PTR __Next$[ebp]
	call	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator::_Mynode
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Isnil
	add	esp, 4
	movsx	edx, BYTE PTR [eax]
	test	edx, edx
	je	SHORT $LN22@insert

; 676  : 					return (_Insert(false, _Next._Mynode(), _Val));

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Next$[ebp]
	call	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator::_Mynode
	push	eax
	push	0
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@ABU?$pair@$$CBVCZString@Value@Json@@V23@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Insert
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN33@insert

; 677  : 				else

	jmp	SHORT $LN21@insert
$LN22@insert:

; 678  : 					return (_Insert(true, _Where._Mynode(), _Val));

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	lea	ecx, DWORD PTR __Where$[ebp]
	call	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator::_Mynode
	push	eax
	push	1
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@ABU?$pair@$$CBVCZString@Value@Json@@V23@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Insert
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN33@insert
$LN21@insert:

; 679  : 				}
; 680  : 			else if (!_DEBUG_LT_PRED(this->comp,

	jmp	$LN27@insert
$LN23@insert:

; 681  : 				this->_Kfn(_Val), _Key(_Where._Mynode()))
; 682  : 				&& (++(_Next = _Where) == end()
; 683  : 					|| !_DEBUG_LT_PRED(this->comp,

	lea	ecx, DWORD PTR __Where$[ebp]
	call	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator::_Mynode
	push	eax
	call	?_Key@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAABVCZString@Value@Json@@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Key
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	call	?_Kfn@?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@SAABVCZString@Value@Json@@ABU?$pair@$$CBVCZString@Value@Json@@V23@@2@@Z ; std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0>::_Kfn
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??R?$less@VCZString@Value@Json@@@std@@QBE_NABVCZString@Value@Json@@0@Z ; std::less<Json::Value::CZString>::operator()
	movzx	edx, al
	test	edx, edx
	jne	$LN27@insert
	mov	eax, DWORD PTR __Where$[ebp]
	mov	DWORD PTR __Next$[ebp], eax
	mov	ecx, DWORD PTR __Where$[ebp+4]
	mov	DWORD PTR __Next$[ebp+4], ecx
	lea	edx, DWORD PTR $T31750[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::end
	push	eax
	lea	ecx, DWORD PTR __Next$[ebp]
	call	??Eiterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::iterator::operator++
	mov	ecx, eax
	call	??8const_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator::operator==
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN18@insert
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	call	?_Kfn@?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@SAABVCZString@Value@Json@@ABU?$pair@$$CBVCZString@Value@Json@@V23@@2@@Z ; std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0>::_Kfn
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR __Next$[ebp]
	call	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator::_Mynode
	push	eax
	call	?_Key@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAABVCZString@Value@Json@@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Key
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??R?$less@VCZString@Value@Json@@@std@@QBE_NABVCZString@Value@Json@@0@Z ; std::less<Json::Value::CZString>::operator()
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN27@insert
$LN18@insert:

; 684  : 						_Key(_Next._Mynode()), this->_Kfn(_Val))))
; 685  : 				{	// insert after _Where
; 686  : 				if (_Isnil(_Right(_Where._Mynode())))

	lea	ecx, DWORD PTR __Where$[ebp]
	call	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator::_Mynode
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Right
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Isnil
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN17@insert

; 687  : 					return (_Insert(false, _Where._Mynode(), _Val));

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	lea	ecx, DWORD PTR __Where$[ebp]
	call	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator::_Mynode
	push	eax
	push	0
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@ABU?$pair@$$CBVCZString@Value@Json@@V23@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Insert
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN33@insert

; 688  : 				else

	jmp	SHORT $LN27@insert
$LN17@insert:

; 689  : 					return (_Insert(true, _Next._Mynode(), _Val));

	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Next$[ebp]
	call	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator::_Mynode
	push	eax
	push	1
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@ABU?$pair@$$CBVCZString@Value@Json@@V23@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Insert
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN33@insert
$LN27@insert:

; 690  : 				}
; 691  : 			}
; 692  : 		else

	jmp	$LN31@insert
$LN30@insert:

; 693  : 			{	// insert only if unique
; 694  : 			if (_Where == begin())

	lea	eax, DWORD PTR $T31751[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::begin
	push	eax
	lea	ecx, DWORD PTR __Where$[ebp]
	call	??8const_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator::operator==
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN14@insert

; 695  : 				{	// insert at beginning if before first element
; 696  : 				if (_DEBUG_LT_PRED(this->comp,

	lea	ecx, DWORD PTR __Where$[ebp]
	call	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator::_Mynode
	push	eax
	call	?_Key@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAABVCZString@Value@Json@@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Key
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	call	?_Kfn@?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@SAABVCZString@Value@Json@@ABU?$pair@$$CBVCZString@Value@Json@@V23@@2@@Z ; std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0>::_Kfn
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??R?$less@VCZString@Value@Json@@@std@@QBE_NABVCZString@Value@Json@@0@Z ; std::less<Json::Value::CZString>::operator()
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN13@insert

; 697  : 					this->_Kfn(_Val), _Key(_Where._Mynode())))
; 698  : 					return (_Insert(true, _Where._Mynode(), _Val));

	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Where$[ebp]
	call	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator::_Mynode
	push	eax
	push	1
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@ABU?$pair@$$CBVCZString@Value@Json@@V23@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Insert
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN33@insert
$LN13@insert:

; 699  : 				}

	jmp	$LN31@insert
$LN14@insert:

; 700  : 			else if (_Where == end())

	lea	eax, DWORD PTR $T31752[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::end
	push	eax
	lea	ecx, DWORD PTR __Where$[ebp]
	call	??8const_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator::operator==
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN11@insert

; 701  : 				{	// insert at end if after last element
; 702  : 				if (_DEBUG_LT_PRED(this->comp,

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	call	?_Kfn@?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@SAABVCZString@Value@Json@@ABU?$pair@$$CBVCZString@Value@Json@@V23@@2@@Z ; std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0>::_Kfn
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rmost@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Rmost
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Key@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAABVCZString@Value@Json@@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Key
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??R?$less@VCZString@Value@Json@@@std@@QBE_NABVCZString@Value@Json@@0@Z ; std::less<Json::Value::CZString>::operator()
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN10@insert

; 703  : 					_Key(_Rmost()), this->_Kfn(_Val)))
; 704  : 					return (_Insert(false, _Rmost(), _Val));

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rmost@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Rmost
	mov	eax, DWORD PTR [eax]
	push	eax
	push	0
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@ABU?$pair@$$CBVCZString@Value@Json@@V23@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Insert
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN33@insert
$LN10@insert:

; 705  : 				}
; 706  : 			else if (_DEBUG_LT_PRED(this->comp,

	jmp	$LN31@insert
$LN11@insert:

; 707  : 				this->_Kfn(_Val), _Key(_Where._Mynode()))
; 708  : 				&& _DEBUG_LT_PRED(this->comp,

	lea	ecx, DWORD PTR __Where$[ebp]
	call	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator::_Mynode
	push	eax
	call	?_Key@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAABVCZString@Value@Json@@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Key
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	call	?_Kfn@?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@SAABVCZString@Value@Json@@ABU?$pair@$$CBVCZString@Value@Json@@V23@@2@@Z ; std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0>::_Kfn
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??R?$less@VCZString@Value@Json@@@std@@QBE_NABVCZString@Value@Json@@0@Z ; std::less<Json::Value::CZString>::operator()
	movzx	eax, al
	test	eax, eax
	je	$LN8@insert
	mov	ecx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR __Next$[ebp], ecx
	mov	edx, DWORD PTR __Where$[ebp+4]
	mov	DWORD PTR __Next$[ebp+4], edx
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	call	?_Kfn@?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@SAABVCZString@Value@Json@@ABU?$pair@$$CBVCZString@Value@Json@@V23@@2@@Z ; std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0>::_Kfn
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR __Next$[ebp]
	call	??Fiterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::iterator::operator--
	mov	ecx, eax
	call	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator::_Mynode
	push	eax
	call	?_Key@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAABVCZString@Value@Json@@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Key
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??R?$less@VCZString@Value@Json@@@std@@QBE_NABVCZString@Value@Json@@0@Z ; std::less<Json::Value::CZString>::operator()
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN8@insert

; 709  : 					_Key((--(_Next = _Where))._Mynode()), this->_Kfn(_Val)))
; 710  : 				{	// insert before _Where
; 711  : 				if (_Isnil(_Right(_Next._Mynode())))

	lea	ecx, DWORD PTR __Next$[ebp]
	call	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator::_Mynode
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Right
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	push	edx
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Isnil
	add	esp, 4
	movsx	eax, BYTE PTR [eax]
	test	eax, eax
	je	SHORT $LN7@insert

; 712  : 					return (_Insert(false, _Next._Mynode(), _Val));

	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Next$[ebp]
	call	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator::_Mynode
	push	eax
	push	0
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@ABU?$pair@$$CBVCZString@Value@Json@@V23@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Insert
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN33@insert

; 713  : 				else

	jmp	SHORT $LN6@insert
$LN7@insert:

; 714  : 					return (_Insert(true, _Where._Mynode(), _Val));

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Where$[ebp]
	call	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator::_Mynode
	push	eax
	push	1
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@ABU?$pair@$$CBVCZString@Value@Json@@V23@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Insert
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN33@insert
$LN6@insert:

; 715  : 				}
; 716  : 			else if (_DEBUG_LT_PRED(this->comp,

	jmp	$LN31@insert
$LN8@insert:

; 717  : 				_Key(_Where._Mynode()), this->_Kfn(_Val))
; 718  : 				&& (++(_Next = _Where) == end()
; 719  : 					|| _DEBUG_LT_PRED(this->comp,

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	call	?_Kfn@?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@SAABVCZString@Value@Json@@ABU?$pair@$$CBVCZString@Value@Json@@V23@@2@@Z ; std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0>::_Kfn
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR __Where$[ebp]
	call	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator::_Mynode
	push	eax
	call	?_Key@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAABVCZString@Value@Json@@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Key
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??R?$less@VCZString@Value@Json@@@std@@QBE_NABVCZString@Value@Json@@0@Z ; std::less<Json::Value::CZString>::operator()
	movzx	eax, al
	test	eax, eax
	je	$LN31@insert
	mov	ecx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR __Next$[ebp], ecx
	mov	edx, DWORD PTR __Where$[ebp+4]
	mov	DWORD PTR __Next$[ebp+4], edx
	lea	eax, DWORD PTR $T31753[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::end
	push	eax
	lea	ecx, DWORD PTR __Next$[ebp]
	call	??Eiterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::iterator::operator++
	mov	ecx, eax
	call	??8const_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator::operator==
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN3@insert
	lea	ecx, DWORD PTR __Next$[ebp]
	call	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator::_Mynode
	push	eax
	call	?_Key@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAABVCZString@Value@Json@@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Key
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	call	?_Kfn@?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@SAABVCZString@Value@Json@@ABU?$pair@$$CBVCZString@Value@Json@@V23@@2@@Z ; std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0>::_Kfn
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??R?$less@VCZString@Value@Json@@@std@@QBE_NABVCZString@Value@Json@@0@Z ; std::less<Json::Value::CZString>::operator()
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN31@insert
$LN3@insert:

; 720  : 						this->_Kfn(_Val), _Key(_Next._Mynode()))))
; 721  : 				{	// insert after _Where
; 722  : 				if (_Isnil(_Right(_Where._Mynode())))

	lea	ecx, DWORD PTR __Where$[ebp]
	call	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator::_Mynode
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Isnil
	add	esp, 4
	movsx	edx, BYTE PTR [eax]
	test	edx, edx
	je	SHORT $LN2@insert

; 723  : 					return (_Insert(false, _Where._Mynode(), _Val));

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Where$[ebp]
	call	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator::_Mynode
	push	eax
	push	0
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@ABU?$pair@$$CBVCZString@Value@Json@@V23@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Insert
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN33@insert

; 724  : 				else

	jmp	SHORT $LN31@insert
$LN2@insert:

; 725  : 					return (_Insert(true, _Next._Mynode(), _Val));

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	lea	ecx, DWORD PTR __Next$[ebp]
	call	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator::_Mynode
	push	eax
	push	1
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@ABU?$pair@$$CBVCZString@Value@Json@@V23@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Insert
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN33@insert
$LN31@insert:

; 726  : 				}
; 727  : 			}
; 728  : 
; 729  : 		return (insert(_Val).first);	// try usual insert if all else fails

	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T31754[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?insert@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBVCZString@Value@Json@@V23@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::insert
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN33@insert:

; 730  : 		}

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?insert@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@V312@ABU?$pair@$$CBVCZString@Value@Json@@V23@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::insert
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Node>::deallocate
PUBLIC	?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Node>::destroy
PUBLIC	?_Rrotate@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Rrotate
PUBLIC	?_Lrotate@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Lrotate
PUBLIC	??$swap@D@std@@YAXAAD0@Z			; std::swap<char>
PUBLIC	?_Color@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Color
PUBLIC	?_Max@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Max
PUBLIC	?_Min@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Min
PUBLIC	?_Root@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Root
PUBLIC	?_Parent@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Parent
PUBLIC	?_Left@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Left
PUBLIC	__TI3?AVout_of_range@std@@
PUBLIC	??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::out_of_range::out_of_range
PUBLIC	??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@ ; `string'
PUBLIC	??1out_of_range@std@@UAE@XZ			; std::out_of_range::~out_of_range
PUBLIC	__CTA3?AVout_of_range@std@@
PUBLIC	__CT??_R0?AVout_of_range@std@@@8??0out_of_range@std@@QAE@ABV01@@Z40
PUBLIC	??_R0?AVout_of_range@std@@@8			; std::out_of_range `RTTI Type Descriptor'
PUBLIC	??0out_of_range@std@@QAE@ABV01@@Z		; std::out_of_range::out_of_range
PUBLIC	__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
PUBLIC	??_R0?AVlogic_error@std@@@8			; std::logic_error `RTTI Type Descriptor'
PUBLIC	??0logic_error@std@@QAE@ABV01@@Z		; std::logic_error::logic_error
;	COMDAT ??_R0?AVlogic_error@std@@@8
_DATA	SEGMENT
??_R0?AVlogic_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::logic_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlogic_error@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0logic_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVout_of_range@std@@@8
_DATA	SEGMENT
??_R0?AVout_of_range@std@@@8 DD FLAT:??_7type_info@@6B@	; std::out_of_range `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVout_of_range@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVout_of_range@std@@@8??0out_of_range@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVout_of_range@std@@@8??0out_of_range@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVout_of_range@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0out_of_range@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA3?AVout_of_range@std@@
xdata$x	SEGMENT
__CTA3?AVout_of_range@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVout_of_range@std@@@8??0out_of_range@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVout_of_range@std@@
xdata$x	SEGMENT
__TI3?AVout_of_range@std@@ DD 00H
	DD	FLAT:??1out_of_range@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVout_of_range@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@
CONST	SEGMENT
??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@ DB 'invalid '
	DB	'map/set<T> iterator', 00H			; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?erase@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@V312@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?erase@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@V312@@Z$0
__ehfuncinfo$?erase@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@V312@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?erase@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@V312@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@V312@@Z
_TEXT	SEGMENT
tv177 = -108						; size = 4
tv165 = -104						; size = 4
_this$ = -100						; size = 4
$T31758 = -96						; size = 28
$T31757 = -68						; size = 40
__Fixnodeparent$ = -28					; size = 4
__Pnode$ = -24						; size = 4
__Fixnode$ = -20					; size = 4
__Erasednode$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 8
?erase@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@V312@@Z PROC ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::erase, COMDAT
; _this$ = ecx

; 747  : 		{	// erase element at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?erase@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@V312@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 96					; 00000060H
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 748  : 
; 749  :  #if _HAS_ITERATOR_DEBUGGING
; 750  : 		if (_Where._Mycont != this || _Isnil(_Where._Mynode()))
; 751  : 			_DEBUG_ERROR("map/set erase iterator outside range");
; 752  : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase
; 753  : 		++_Where;	// save successor iterator for return
; 754  : 		_Orphan_ptr(*this, _Erasednode);
; 755  : 
; 756  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 757  : 		if (_Isnil(_Where._Mynode()))

	lea	ecx, DWORD PTR __Where$[ebp]
	call	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator::_Mynode
	push	eax
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Isnil
	add	esp, 4
	movsx	eax, BYTE PTR [eax]
	test	eax, eax
	je	SHORT $LN40@erase

; 758  : 			_THROW(out_of_range, "invalid map/set<T> iterator");

	push	OFFSET ??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@
	lea	ecx, DWORD PTR $T31758[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T31758[ebp]
	push	ecx
	lea	ecx, DWORD PTR $T31757[ebp]
	call	??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::out_of_range::out_of_range
	push	OFFSET __TI3?AVout_of_range@std@@
	lea	edx, DWORD PTR $T31757[ebp]
	push	edx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T31758[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN40@erase:

; 759  : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase

	lea	ecx, DWORD PTR __Where$[ebp]
	call	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator::_Mynode
	mov	DWORD PTR __Erasednode$[ebp], eax

; 760  : 		++_Where;	// save successor iterator for return

	lea	ecx, DWORD PTR __Where$[ebp]
	call	??Eiterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::iterator::operator++

; 761  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 762  : 
; 763  : 		_Nodeptr _Fixnode;	// the node to recolor as needed
; 764  : 		_Nodeptr _Fixnodeparent;	// parent of _Fixnode (which may be nil)
; 765  : 		_Nodeptr _Pnode = _Erasednode;

	mov	eax, DWORD PTR __Erasednode$[ebp]
	mov	DWORD PTR __Pnode$[ebp], eax

; 766  : 
; 767  : 		if (_Isnil(_Left(_Pnode)))

	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	call	?_Left@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Left
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	push	edx
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Isnil
	add	esp, 4
	movsx	eax, BYTE PTR [eax]
	test	eax, eax
	je	SHORT $LN39@erase

; 768  : 			_Fixnode = _Right(_Pnode);	// must stitch up right subtree

	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	call	?_Right@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Right
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR __Fixnode$[ebp], edx
	jmp	SHORT $LN38@erase
$LN39@erase:

; 769  : 		else if (_Isnil(_Right(_Pnode)))

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Isnil
	add	esp, 4
	movsx	edx, BYTE PTR [eax]
	test	edx, edx
	je	SHORT $LN37@erase

; 770  : 			_Fixnode = _Left(_Pnode);	// must stitch up left subtree

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Fixnode$[ebp], ecx

; 771  : 		else

	jmp	SHORT $LN38@erase
$LN37@erase:

; 772  : 			{	// two subtrees, must lift successor node to replace erased
; 773  : 			_Pnode = _Where._Mynode();	// _Pnode is successor node

	lea	ecx, DWORD PTR __Where$[ebp]
	call	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator::_Mynode
	mov	DWORD PTR __Pnode$[ebp], eax

; 774  : 			_Fixnode = _Right(_Pnode);	// _Fixnode is its only subtree

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Right
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR __Fixnode$[ebp], eax
$LN38@erase:

; 775  : 			}
; 776  : 
; 777  : 		if (_Pnode == _Erasednode)

	mov	ecx, DWORD PTR __Pnode$[ebp]
	cmp	ecx, DWORD PTR __Erasednode$[ebp]
	jne	$LN35@erase

; 778  : 			{	// at most one subtree, relink it
; 779  : 			_Fixnodeparent = _Parent(_Erasednode);

	mov	edx, DWORD PTR __Erasednode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR __Fixnodeparent$[ebp], eax

; 780  : 			if (!_Isnil(_Fixnode))

	mov	ecx, DWORD PTR __Fixnode$[ebp]
	push	ecx
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Isnil
	add	esp, 4
	movsx	edx, BYTE PTR [eax]
	test	edx, edx
	jne	SHORT $LN34@erase

; 781  : 				_Parent(_Fixnode) = _Fixnodeparent;	// link up

	mov	eax, DWORD PTR __Fixnode$[ebp]
	push	eax
	call	?_Parent@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR [eax], ecx
$LN34@erase:

; 782  : 
; 783  : 			if (_Root() == _Erasednode)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Root
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR __Erasednode$[ebp]
	jne	SHORT $LN33@erase

; 784  : 				_Root() = _Fixnode;	// link down from root

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Root
	mov	ecx, DWORD PTR __Fixnode$[ebp]
	mov	DWORD PTR [eax], ecx
	jmp	SHORT $LN32@erase
$LN33@erase:

; 785  : 			else if (_Left(_Fixnodeparent) == _Erasednode)

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	call	?_Left@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Left
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	cmp	eax, DWORD PTR __Erasednode$[ebp]
	jne	SHORT $LN31@erase

; 786  : 				_Left(_Fixnodeparent) = _Fixnode;	// link down to left

	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	push	ecx
	call	?_Left@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Left
	add	esp, 4
	mov	edx, DWORD PTR __Fixnode$[ebp]
	mov	DWORD PTR [eax], edx

; 787  : 			else

	jmp	SHORT $LN32@erase
$LN31@erase:

; 788  : 				_Right(_Fixnodeparent) = _Fixnode;	// link down to right

	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR __Fixnode$[ebp]
	mov	DWORD PTR [eax], ecx
$LN32@erase:

; 789  : 
; 790  : 			if (_Lmost() == _Erasednode)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lmost@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Lmost
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR __Erasednode$[ebp]
	jne	SHORT $LN29@erase

; 791  : 				_Lmost() = _Isnil(_Fixnode)
; 792  : 					? _Fixnodeparent	// smallest is parent of erased node
; 793  : 					: _Min(_Fixnode);	// smallest in relinked subtree

	mov	eax, DWORD PTR __Fixnode$[ebp]
	push	eax
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Isnil
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN43@erase
	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR tv165[ebp], edx
	jmp	SHORT $LN44@erase
$LN43@erase:
	mov	eax, DWORD PTR __Fixnode$[ebp]
	push	eax
	call	?_Min@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Min
	add	esp, 4
	mov	DWORD PTR tv165[ebp], eax
$LN44@erase:
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lmost@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Lmost
	mov	ecx, DWORD PTR tv165[ebp]
	mov	DWORD PTR [eax], ecx
$LN29@erase:

; 794  : 
; 795  : 			if (_Rmost() == _Erasednode)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rmost@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Rmost
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR __Erasednode$[ebp]
	jne	SHORT $LN28@erase

; 796  : 				_Rmost() = _Isnil(_Fixnode)
; 797  : 					? _Fixnodeparent	// largest is parent of erased node
; 798  : 					: _Max(_Fixnode);	// largest in relinked subtree

	mov	eax, DWORD PTR __Fixnode$[ebp]
	push	eax
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Isnil
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN45@erase
	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR tv177[ebp], edx
	jmp	SHORT $LN46@erase
$LN45@erase:
	mov	eax, DWORD PTR __Fixnode$[ebp]
	push	eax
	call	?_Max@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Max
	add	esp, 4
	mov	DWORD PTR tv177[ebp], eax
$LN46@erase:
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rmost@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Rmost
	mov	ecx, DWORD PTR tv177[ebp]
	mov	DWORD PTR [eax], ecx
$LN28@erase:

; 799  : 			}
; 800  : 		else

	jmp	$LN27@erase
$LN35@erase:

; 801  : 			{	// erased has two subtrees, _Pnode is successor to erased
; 802  : 			_Parent(_Left(_Erasednode)) = _Pnode;	// link left up

	mov	edx, DWORD PTR __Erasednode$[ebp]
	push	edx
	call	?_Left@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Left
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Parent@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx

; 803  : 			_Left(_Pnode) = _Left(_Erasednode);	// link successor down

	mov	edx, DWORD PTR __Erasednode$[ebp]
	push	edx
	call	?_Left@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Left
	add	esp, 4
	mov	esi, eax
	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [eax], ecx

; 804  : 
; 805  : 			if (_Pnode == _Right(_Erasednode))

	mov	edx, DWORD PTR __Erasednode$[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR __Pnode$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jne	SHORT $LN26@erase

; 806  : 				_Fixnodeparent = _Pnode;	// successor is next to erased

	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR __Fixnodeparent$[ebp], edx

; 807  : 			else

	jmp	$LN25@erase
$LN26@erase:

; 808  : 				{	// successor further down, link in place of erased
; 809  : 				_Fixnodeparent = _Parent(_Pnode);	// parent is successor's

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Parent@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Fixnodeparent$[ebp], ecx

; 810  : 				if (!_Isnil(_Fixnode))

	mov	edx, DWORD PTR __Fixnode$[ebp]
	push	edx
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Isnil
	add	esp, 4
	movsx	eax, BYTE PTR [eax]
	test	eax, eax
	jne	SHORT $LN24@erase

; 811  : 					_Parent(_Fixnode) = _Fixnodeparent;	// link fix up

	mov	ecx, DWORD PTR __Fixnode$[ebp]
	push	ecx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Parent
	add	esp, 4
	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR [eax], edx
$LN24@erase:

; 812  : 				_Left(_Fixnodeparent) = _Fixnode;	// link fix down

	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR __Fixnode$[ebp]
	mov	DWORD PTR [eax], ecx

; 813  : 				_Right(_Pnode) = _Right(_Erasednode);	// link successor down

	mov	edx, DWORD PTR __Erasednode$[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Right
	add	esp, 4
	mov	esi, eax
	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [eax], ecx

; 814  : 				_Parent(_Right(_Erasednode)) = _Pnode;	// link right up

	mov	edx, DWORD PTR __Erasednode$[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Right
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Parent@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx
$LN25@erase:

; 815  : 				}
; 816  : 
; 817  : 			if (_Root() == _Erasednode)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Root
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR __Erasednode$[ebp]
	jne	SHORT $LN23@erase

; 818  : 				_Root() = _Pnode;	// link down from root

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Root
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx
	jmp	SHORT $LN22@erase
$LN23@erase:

; 819  : 			else if (_Left(_Parent(_Erasednode)) == _Erasednode)

	mov	edx, DWORD PTR __Erasednode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR __Erasednode$[ebp]
	jne	SHORT $LN21@erase

; 820  : 				_Left(_Parent(_Erasednode)) = _Pnode;	// link down to left

	mov	edx, DWORD PTR __Erasednode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx

; 821  : 			else

	jmp	SHORT $LN22@erase
$LN21@erase:

; 822  : 				_Right(_Parent(_Erasednode)) = _Pnode;	// link down to right

	mov	edx, DWORD PTR __Erasednode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx
$LN22@erase:

; 823  : 
; 824  : 			_Parent(_Pnode) = _Parent(_Erasednode);	// link successor up

	mov	edx, DWORD PTR __Erasednode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Parent
	add	esp, 4
	mov	esi, eax
	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Parent@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [eax], ecx

; 825  : 			std::swap(_Color(_Pnode), _Color(_Erasednode));	// recolor it

	mov	edx, DWORD PTR __Erasednode$[ebp]
	push	edx
	call	?_Color@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Color
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Color@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Color
	add	esp, 4
	push	eax
	call	??$swap@D@std@@YAXAAD0@Z		; std::swap<char>
	add	esp, 8
$LN27@erase:

; 826  : 			}
; 827  : 
; 828  : 		if (_Color(_Erasednode) == _Black)

	mov	ecx, DWORD PTR __Erasednode$[ebp]
	push	ecx
	call	?_Color@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Color
	add	esp, 4
	movsx	edx, BYTE PTR [eax]
	cmp	edx, 1
	jne	$LN19@erase
	jmp	SHORT $LN18@erase
$LN17@erase:

; 829  : 			{	// erasing black link, must recolor/rebalance tree
; 830  : 			for (; _Fixnode != _Root() && _Color(_Fixnode) == _Black;
; 831  : 				_Fixnodeparent = _Parent(_Fixnode))

	mov	eax, DWORD PTR __Fixnode$[ebp]
	push	eax
	call	?_Parent@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Fixnodeparent$[ebp], ecx
$LN18@erase:
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Root
	mov	edx, DWORD PTR __Fixnode$[ebp]
	cmp	edx, DWORD PTR [eax]
	je	$LN16@erase
	mov	eax, DWORD PTR __Fixnode$[ebp]
	push	eax
	call	?_Color@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Color
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 1
	jne	$LN16@erase

; 832  : 				if (_Fixnode == _Left(_Fixnodeparent))

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	call	?_Left@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR __Fixnode$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jne	$LN15@erase

; 833  : 					{	// fixup left subtree
; 834  : 					_Pnode = _Right(_Fixnodeparent);

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Right
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], eax

; 835  : 					if (_Color(_Pnode) == _Red)

	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	call	?_Color@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Color
	add	esp, 4
	movsx	edx, BYTE PTR [eax]
	test	edx, edx
	jne	SHORT $LN14@erase

; 836  : 						{	// rotate red up from right subtree
; 837  : 						_Color(_Pnode) = _Black;

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Color@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 838  : 						_Color(_Fixnodeparent) = _Red;

	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	push	ecx
	call	?_Color@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 0

; 839  : 						_Lrotate(_Fixnodeparent);

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Lrotate

; 840  : 						_Pnode = _Right(_Fixnodeparent);

	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], ecx
$LN14@erase:

; 841  : 						}
; 842  : 
; 843  : 					if (_Isnil(_Pnode))

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Isnil
	add	esp, 4
	movsx	eax, BYTE PTR [eax]
	test	eax, eax
	je	SHORT $LN13@erase

; 844  : 						_Fixnode = _Fixnodeparent;	// shouldn't happen

	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR __Fixnode$[ebp], ecx

; 845  : 					else if (_Color(_Left(_Pnode)) == _Black

	jmp	$LN12@erase
$LN13@erase:

; 846  : 						&& _Color(_Right(_Pnode)) == _Black)

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Left@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Left
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Color@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Color
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 1
	jne	SHORT $LN11@erase
	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Right
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Color@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Color
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 1
	jne	SHORT $LN11@erase

; 847  : 						{	// redden right subtree with black children
; 848  : 						_Color(_Pnode) = _Red;

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Color@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 0

; 849  : 						_Fixnode = _Fixnodeparent;

	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR __Fixnode$[ebp], eax

; 850  : 						}
; 851  : 					else

	jmp	$LN12@erase
$LN11@erase:

; 852  : 						{	// must rearrange right subtree
; 853  : 						if (_Color(_Right(_Pnode)) == _Black)

	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	call	?_Right@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Right
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	push	edx
	call	?_Color@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Color
	add	esp, 4
	movsx	eax, BYTE PTR [eax]
	cmp	eax, 1
	jne	SHORT $LN9@erase

; 854  : 							{	// rotate red up from left sub-subtree
; 855  : 							_Color(_Left(_Pnode)) = _Black;

	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	call	?_Left@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Left
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	push	edx
	call	?_Color@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 856  : 							_Color(_Pnode) = _Red;

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Color@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 0

; 857  : 							_Rrotate(_Pnode);

	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Rrotate

; 858  : 							_Pnode = _Right(_Fixnodeparent);

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Right
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], eax
$LN9@erase:

; 859  : 							}
; 860  : 
; 861  : 						_Color(_Pnode) = _Color(_Fixnodeparent);

	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	push	ecx
	call	?_Color@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Color
	add	esp, 4
	mov	esi, eax
	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Color@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Color
	add	esp, 4
	mov	cl, BYTE PTR [esi]
	mov	BYTE PTR [eax], cl

; 862  : 						_Color(_Fixnodeparent) = _Black;

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	call	?_Color@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 863  : 						_Color(_Right(_Pnode)) = _Black;

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Color@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 864  : 						_Lrotate(_Fixnodeparent);

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Lrotate

; 865  : 						break;	// tree now recolored/rebalanced

	jmp	$LN16@erase
$LN12@erase:

; 866  : 						}
; 867  : 					}
; 868  : 				else

	jmp	$LN8@erase
$LN15@erase:

; 869  : 					{	// fixup right subtree
; 870  : 					_Pnode = _Left(_Fixnodeparent);

	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], ecx

; 871  : 					if (_Color(_Pnode) == _Red)

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Color@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Color
	add	esp, 4
	movsx	eax, BYTE PTR [eax]
	test	eax, eax
	jne	SHORT $LN7@erase

; 872  : 						{	// rotate red up from left subtree
; 873  : 						_Color(_Pnode) = _Black;

	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	call	?_Color@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 874  : 						_Color(_Fixnodeparent) = _Red;

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	call	?_Color@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 0

; 875  : 						_Rrotate(_Fixnodeparent);

	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Rrotate

; 876  : 						_Pnode = _Left(_Fixnodeparent);

	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	push	ecx
	call	?_Left@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Left
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], edx
$LN7@erase:

; 877  : 						}
; 878  : 					if (_Isnil(_Pnode))

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Isnil
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN6@erase

; 879  : 						_Fixnode = _Fixnodeparent;	// shouldn't happen

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR __Fixnode$[ebp], edx

; 880  : 					else if (_Color(_Right(_Pnode)) == _Black

	jmp	$LN8@erase
$LN6@erase:

; 881  : 						&& _Color(_Left(_Pnode)) == _Black)

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Color@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Color
	add	esp, 4
	movsx	edx, BYTE PTR [eax]
	cmp	edx, 1
	jne	SHORT $LN4@erase
	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Color@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Color
	add	esp, 4
	movsx	edx, BYTE PTR [eax]
	cmp	edx, 1
	jne	SHORT $LN4@erase

; 882  : 						{	// redden left subtree with black children
; 883  : 						_Color(_Pnode) = _Red;

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Color@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 0

; 884  : 						_Fixnode = _Fixnodeparent;

	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR __Fixnode$[ebp], ecx

; 885  : 						}
; 886  : 					else

	jmp	$LN8@erase
$LN4@erase:

; 887  : 						{	// must rearrange left subtree
; 888  : 						if (_Color(_Left(_Pnode)) == _Black)

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Left@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Left
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Color@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Color
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 1
	jne	SHORT $LN2@erase

; 889  : 							{	// rotate red up from right sub-subtree
; 890  : 							_Color(_Right(_Pnode)) = _Black;

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Right
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Color@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 891  : 							_Color(_Pnode) = _Red;

	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	call	?_Color@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 0

; 892  : 							_Lrotate(_Pnode);

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Lrotate

; 893  : 							_Pnode = _Left(_Fixnodeparent);

	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], ecx
$LN2@erase:

; 894  : 							}
; 895  : 
; 896  : 						_Color(_Pnode) = _Color(_Fixnodeparent);

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	call	?_Color@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Color
	add	esp, 4
	mov	esi, eax
	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Color@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Color
	add	esp, 4
	mov	cl, BYTE PTR [esi]
	mov	BYTE PTR [eax], cl

; 897  : 						_Color(_Fixnodeparent) = _Black;

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	call	?_Color@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 898  : 						_Color(_Left(_Pnode)) = _Black;

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Color@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 899  : 						_Rrotate(_Fixnodeparent);

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Rrotate

; 900  : 						break;	// tree now recolored/rebalanced

	jmp	SHORT $LN16@erase
$LN8@erase:

; 901  : 						}
; 902  : 					}

	jmp	$LN17@erase
$LN16@erase:

; 903  : 
; 904  : 			_Color(_Fixnode) = _Black;	// ensure stopping node is black

	mov	eax, DWORD PTR __Fixnode$[ebp]
	push	eax
	call	?_Color@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1
$LN19@erase:

; 905  : 			}
; 906  : 
; 907  : 		this->_Alnod.destroy(_Erasednode);	// destroy, free erased node

	mov	ecx, DWORD PTR __Erasednode$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1
	call	?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Node>::destroy

; 908  : 		this->_Alnod.deallocate(_Erasednode, 1);

	push	1
	mov	edx, DWORD PTR __Erasednode$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1
	call	?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Node>::deallocate

; 909  : 
; 910  : 		if (0 < _Mysize)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	jbe	SHORT $LN1@erase

; 911  : 			--_Mysize;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	sub	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], edx
$LN1@erase:

; 912  : 
; 913  : 		return (_Where);	// return successor iterator

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR __Where$[ebp+4]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN42@erase:

; 914  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?erase@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@V312@@Z$0:
	lea	ecx, DWORD PTR $T31758[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?erase@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@V312@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-104]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?erase@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@V312@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?erase@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@V312@@Z ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::erase
PUBLIC	??_7out_of_range@std@@6B@			; std::out_of_range::`vftable'
PUBLIC	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
PUBLIC	??_R4out_of_range@std@@6B@			; std::out_of_range::`RTTI Complete Object Locator'
PUBLIC	??_R3out_of_range@std@@8			; std::out_of_range::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2out_of_range@std@@8			; std::out_of_range::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@out_of_range@std@@8		; std::out_of_range::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@logic_error@std@@8		; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3logic_error@std@@8				; std::logic_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2logic_error@std@@8				; std::logic_error::`RTTI Base Class Array'
PUBLIC	?what@logic_error@std@@UBEPBDXZ			; std::logic_error::what
EXTRN	??_Eout_of_range@std@@UAEPAXI@Z:PROC		; std::out_of_range::`vector deleting destructor'
;	COMDAT ??_R2logic_error@std@@8
; File c:\program files (x86)\microsoft visual studio 8\vc\include\stdexcept
rdata$r	SEGMENT
??_R2logic_error@std@@8 DD FLAT:??_R1A@?0A@EA@logic_error@std@@8 ; std::logic_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3logic_error@std@@8
rdata$r	SEGMENT
??_R3logic_error@std@@8 DD 00H				; std::logic_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@logic_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@logic_error@std@@8 DD FLAT:??_R0?AVlogic_error@std@@@8 ; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@out_of_range@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@out_of_range@std@@8 DD FLAT:??_R0?AVout_of_range@std@@@8 ; std::out_of_range::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3out_of_range@std@@8
rdata$r	ENDS
;	COMDAT ??_R2out_of_range@std@@8
rdata$r	SEGMENT
??_R2out_of_range@std@@8 DD FLAT:??_R1A@?0A@EA@out_of_range@std@@8 ; std::out_of_range::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@logic_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3out_of_range@std@@8
rdata$r	SEGMENT
??_R3out_of_range@std@@8 DD 00H				; std::out_of_range::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2out_of_range@std@@8
rdata$r	ENDS
;	COMDAT ??_R4out_of_range@std@@6B@
rdata$r	SEGMENT
??_R4out_of_range@std@@6B@ DD 00H			; std::out_of_range::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVout_of_range@std@@@8
	DD	FLAT:??_R3out_of_range@std@@8
rdata$r	ENDS
;	COMDAT ??_7out_of_range@std@@6B@
CONST	SEGMENT
??_7out_of_range@std@@6B@ DD FLAT:??_R4out_of_range@std@@6B@ ; std::out_of_range::`vftable'
	DD	FLAT:??_Eout_of_range@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Message$ = 8						; size = 4
??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::out_of_range::out_of_range, COMDAT
; _this$ = ecx

; 130  : 		{	// construct from message string

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Message$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7out_of_range@std@@6B@

; 131  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::out_of_range::out_of_range
_TEXT	ENDS
PUBLIC	??_7logic_error@std@@6B@			; std::logic_error::`vftable'
PUBLIC	??_R4logic_error@std@@6B@			; std::logic_error::`RTTI Complete Object Locator'
EXTRN	??_Elogic_error@std@@UAEPAXI@Z:PROC		; std::logic_error::`vector deleting destructor'
;	COMDAT ??_R4logic_error@std@@6B@
rdata$r	SEGMENT
??_R4logic_error@std@@6B@ DD 00H			; std::logic_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	FLAT:??_R3logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_7logic_error@std@@6B@
CONST	SEGMENT
??_7logic_error@std@@6B@ DD FLAT:??_R4logic_error@std@@6B@ ; std::logic_error::`vftable'
	DD	FLAT:??_Elogic_error@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0
__ehfuncinfo$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Message$ = 8						; size = 4
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::logic_error::logic_error, COMDAT
; _this$ = ecx

; 27   : 		{	// construct from message string

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7logic_error@std@@6B@
	mov	ecx, DWORD PTR __Message$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z

; 28   : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::logic_error::logic_error
; Function compile flags: /Odtp
;	COMDAT ?what@logic_error@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?what@logic_error@std@@UBEPBDXZ PROC			; std::logic_error::what, COMDAT
; _this$ = ecx

; 35   : 		{	// return pointer to message string

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 36   : 		return (_Str.c_str());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ

; 37   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?what@logic_error@std@@UBEPBDXZ ENDP			; std::logic_error::what
_TEXT	ENDS
PUBLIC	??1logic_error@std@@UAE@XZ			; std::logic_error::~logic_error
; Function compile flags: /Odtp
;	COMDAT ??_Glogic_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Glogic_error@std@@UAEPAXI@Z PROC			; std::logic_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1logic_error@std@@UAE@XZ		; std::logic_error::~logic_error
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@6
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@6:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Glogic_error@std@@UAEPAXI@Z ENDP			; std::logic_error::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1logic_error@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1logic_error@std@@UAE@XZ PROC				; std::logic_error::~logic_error, COMDAT
; _this$ = ecx

; 31   : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7logic_error@std@@6B@

; 32   : 		}

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1logic_error@std@@UAE@XZ ENDP				; std::logic_error::~logic_error
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1out_of_range@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1out_of_range@std@@UAE@XZ PROC			; std::out_of_range::~out_of_range, COMDAT
; _this$ = ecx

; 134  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7out_of_range@std@@6B@

; 135  : 		}

	mov	ecx, DWORD PTR _this$[ebp]
	call	??1logic_error@std@@UAE@XZ		; std::logic_error::~logic_error
	mov	esp, ebp
	pop	ebp
	ret	0
??1out_of_range@std@@UAE@XZ ENDP			; std::out_of_range::~out_of_range
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_Gout_of_range@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gout_of_range@std@@UAEPAXI@Z PROC			; std::out_of_range::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1out_of_range@std@@UAE@XZ		; std::out_of_range::~out_of_range
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@7
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@7:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Gout_of_range@std@@UAEPAXI@Z ENDP			; std::out_of_range::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0out_of_range@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0out_of_range@std@@QAE@ABV01@@Z PROC			; std::out_of_range::out_of_range, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0logic_error@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7out_of_range@std@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0out_of_range@std@@QAE@ABV01@@Z ENDP			; std::out_of_range::out_of_range
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0logic_error@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0
__ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0logic_error@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0logic_error@std@@QAE@ABV01@@Z PROC			; std::logic_error::logic_error, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 12					; 0000000cH
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0logic_error@std@@QAE@ABV01@@Z ENDP			; std::logic_error::logic_error
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@V312@0@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::erase
PUBLIC	??$_Distance@Viterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@I@std@@YAXViterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@0AAI@Z ; std::_Distance<std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::iterator,unsigned int>
PUBLIC	?equal_range@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@V123@@2@ABVCZString@Value@Json@@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::equal_range
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 8\vc\include\xtree
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAEIABVCZString@Value@Json@@@Z
_TEXT	SEGMENT
_this$ = -32						; size = 4
$T31808 = -28						; size = 8
__Where$ = -20						; size = 16
__Num$ = -4						; size = 4
__Keyval$ = 8						; size = 4
?erase@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAEIABVCZString@Value@Json@@@Z PROC ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::erase, COMDAT
; _this$ = ecx

; 932  : 		{	// erase and count all that match _Keyval

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 933  : 		_Pairii _Where = equal_range(_Keyval);

	mov	eax, DWORD PTR __Keyval$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Where$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?equal_range@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@V123@@2@ABVCZString@Value@Json@@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::equal_range

; 934  : 		size_type _Num = 0;

	mov	DWORD PTR __Num$[ebp], 0

; 935  : 		_Distance(_Where.first, _Where.second, _Num);

	lea	edx, DWORD PTR __Num$[ebp]
	push	edx
	mov	eax, DWORD PTR __Where$[ebp+12]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp+8]
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp+4]
	push	edx
	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	call	??$_Distance@Viterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@I@std@@YAXViterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@0AAI@Z ; std::_Distance<std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::iterator,unsigned int>
	add	esp, 20					; 00000014H

; 936  : 		erase(_Where.first, _Where.second);

	mov	ecx, DWORD PTR __Where$[ebp+12]
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp+8]
	push	edx
	mov	eax, DWORD PTR __Where$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T31808[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@V312@0@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::erase

; 937  : 		return (_Num);

	mov	eax, DWORD PTR __Num$[ebp]

; 938  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?erase@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAEIABVCZString@Value@Json@@@Z ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::erase
_TEXT	ENDS
PUBLIC	?_Erase@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Erase
; Function compile flags: /Odtp
;	COMDAT ?clear@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?clear@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::clear, COMDAT
; _this$ = ecx

; 948  : 		{	// erase all

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 949  : 
; 950  :  #if _HAS_ITERATOR_DEBUGGING
; 951  : 		this->_Orphan_ptr(*this, 0);
; 952  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 953  : 
; 954  : 		_Erase(_Root());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Root
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Erase@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Erase

; 955  : 		_Root() = _Myhead, _Mysize = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Root
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0

; 956  : 		_Lmost() = _Myhead, _Rmost() = _Myhead;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lmost@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Lmost
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rmost@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Rmost
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], edx

; 957  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?clear@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::clear
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?find@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@ABVCZString@Value@Json@@@Z
_TEXT	SEGMENT
tv88 = -36						; size = 4
_this$ = -32						; size = 4
$T31816 = -28						; size = 8
$T31814 = -20						; size = 8
$T31813 = -12						; size = 4
__Where$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
?find@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@ABVCZString@Value@Json@@@Z PROC ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::find, COMDAT
; _this$ = ecx

; 960  : 		{	// find an element in mutable sequence that matches _Keyval

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	DWORD PTR _this$[ebp], ecx

; 961  : 		iterator _Where = lower_bound(_Keyval);

	mov	eax, DWORD PTR __Keyval$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Where$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?lower_bound@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@ABVCZString@Value@Json@@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::lower_bound

; 962  : 		return (_Where == end()
; 963  : 			|| _DEBUG_LT_PRED(this->comp,
; 964  : 				_Keyval, _Key(_Where._Mynode()))
; 965  : 					? end() : _Where);

	lea	edx, DWORD PTR $T31814[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::end
	push	eax
	lea	ecx, DWORD PTR __Where$[ebp]
	call	??8const_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator::operator==
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@find
	lea	ecx, DWORD PTR __Where$[ebp]
	call	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator::_Mynode
	push	eax
	call	?_Key@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAABVCZString@Value@Json@@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Key
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Keyval$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??R?$less@VCZString@Value@Json@@@std@@QBE_NABVCZString@Value@Json@@0@Z ; std::less<Json::Value::CZString>::operator()
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN3@find
	lea	eax, DWORD PTR __Where$[ebp]
	mov	DWORD PTR tv88[ebp], eax
	jmp	SHORT $LN4@find
$LN3@find:
	lea	ecx, DWORD PTR $T31816[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::end
	mov	DWORD PTR tv88[ebp], eax
$LN4@find:
	mov	edx, DWORD PTR tv88[ebp]
	mov	DWORD PTR $T31813[ebp], edx
	mov	eax, DWORD PTR $T31813[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 966  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?find@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@ABVCZString@Value@Json@@@Z ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::find
_TEXT	ENDS
PUBLIC	?_Lbound@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@ABVCZString@Value@Json@@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Lbound
; Function compile flags: /Odtp
;	COMDAT ?lower_bound@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@ABVCZString@Value@Json@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
?lower_bound@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@ABVCZString@Value@Json@@@Z PROC ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::lower_bound, COMDAT
; _this$ = ecx

; 986  : 		{	// find leftmost node not less than _Keyval in mutable tree

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 987  : 		return (_TREE_ITERATOR(_Lbound(_Keyval)));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Keyval$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lbound@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@ABVCZString@Value@Json@@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Lbound
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PBV12@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::iterator::iterator
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 988  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?lower_bound@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@ABVCZString@Value@Json@@@Z ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::lower_bound
_TEXT	ENDS
PUBLIC	??0const_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator::const_iterator
; Function compile flags: /Odtp
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::iterator::iterator, COMDAT
; _this$ = ecx

; 420  : 		iterator()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0const_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator::const_iterator

; 421  : 			{	// construct with null node pointer
; 422  : 			}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::iterator::iterator
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??Diterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBEAAU?$pair@$$CBVCZString@Value@Json@@V23@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Diterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBEAAU?$pair@$$CBVCZString@Value@Json@@V23@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::iterator::operator*, COMDAT
; _this$ = ecx

; 450  : 			{	// return designated value

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 451  : 			return ((reference)**(const_iterator *)this);

	mov	ecx, DWORD PTR _this$[ebp]
	call	??Dconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBEABU?$pair@$$CBVCZString@Value@Json@@V23@@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator::operator*

; 452  : 			}

	mov	esp, ebp
	pop	ebp
	ret	0
??Diterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBEAAU?$pair@$$CBVCZString@Value@Json@@V23@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::iterator::operator*
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??Citerator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBEPAU?$pair@$$CBVCZString@Value@Json@@V23@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Citerator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBEPAU?$pair@$$CBVCZString@Value@Json@@V23@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::iterator::operator->, COMDAT
; _this$ = ecx

; 455  : 			{	// return pointer to class object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 456  : 			return (&**this);

	mov	ecx, DWORD PTR _this$[ebp]
	call	??Diterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBEAAU?$pair@$$CBVCZString@Value@Json@@V23@@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::iterator::operator*

; 457  : 			}

	mov	esp, ebp
	pop	ebp
	ret	0
??Citerator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBEPAU?$pair@$$CBVCZString@Value@Json@@V23@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::iterator::operator->
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??Eiterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Eiterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAEAAV012@XZ PROC ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::iterator::operator++, COMDAT
; _this$ = ecx

; 460  : 			{	// preincrement

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 461  : 			++(*(const_iterator *)this);

	mov	ecx, DWORD PTR _this$[ebp]
	call	??Econst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator::operator++

; 462  : 			return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 463  : 			}

	mov	esp, ebp
	pop	ebp
	ret	0
??Eiterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::iterator::operator++
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??Fiterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Fiterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAEAAV012@XZ PROC ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::iterator::operator--, COMDAT
; _this$ = ecx

; 473  : 			{	// predecrement

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 474  : 			--(*(const_iterator *)this);

	mov	ecx, DWORD PTR _this$[ebp]
	call	??Fconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator::operator--

; 475  : 			return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 476  : 			}

	mov	esp, ebp
	pop	ebp
	ret	0
??Fiterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::iterator::operator--
_TEXT	ENDS
PUBLIC	?_Myval@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAU?$pair@$$CBVCZString@Value@Json@@V23@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Myval
EXTRN	__imp___invalid_parameter_noinfo:PROC
; Function compile flags: /Odtp
;	COMDAT ??Dconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBEABU?$pair@$$CBVCZString@Value@Json@@V23@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Dconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBEABU?$pair@$$CBVCZString@Value@Json@@V23@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator::operator*, COMDAT
; _this$ = ecx

; 239  : 			{	// return designated value

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 240  : 
; 241  :  #if _HAS_ITERATOR_DEBUGGING
; 242  : 			if (this->_Mycont == 0
; 243  : 				|| _Ptr == ((_Myt *)this->_Mycont)->_Myhead)
; 244  : 				{
; 245  : 				_DEBUG_ERROR("map/set iterator not dereferencable");
; 246  : 				_SCL_SECURE_OUT_OF_RANGE;
; 247  : 				}
; 248  :  #else
; 249  : 			_SCL_SECURE_VALIDATE(this->_Mycont != NULL);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN2@operator@8
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator@8:

; 250  : 			_SCL_SECURE_VALIDATE_RANGE(_Ptr != ((_Myt *)(this->_Mycont))->_Myhead);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, DWORD PTR [edx+4]
	jne	SHORT $LN1@operator@8
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN1@operator@8:

; 251  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 252  : 
; 253  : 			return (_Myval(_Ptr));

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?_Myval@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAU?$pair@$$CBVCZString@Value@Json@@V23@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Myval
	add	esp, 4

; 254  : 			}

	mov	esp, ebp
	pop	ebp
	ret	0
??Dconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBEABU?$pair@$$CBVCZString@Value@Json@@V23@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator::operator*
_TEXT	ENDS
PUBLIC	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator::_Inc
; Function compile flags: /Odtp
;	COMDAT ??Econst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Econst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAEAAV012@XZ PROC ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator::operator++, COMDAT
; _this$ = ecx

; 262  : 			{	// preincrement

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 263  : 			_Inc();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator::_Inc

; 264  : 			return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 265  : 			}

	mov	esp, ebp
	pop	ebp
	ret	0
??Econst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator::operator++
_TEXT	ENDS
PUBLIC	?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator::_Dec
; Function compile flags: /Odtp
;	COMDAT ??Fconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Fconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAEAAV012@XZ PROC ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator::operator--, COMDAT
; _this$ = ecx

; 275  : 			{	// predecrement

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 276  : 			_Dec();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator::_Dec

; 277  : 			return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 278  : 			}

	mov	esp, ebp
	pop	ebp
	ret	0
??Fconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator::operator--
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8const_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBE_NABV012@@Z PROC ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator::operator==, COMDAT
; _this$ = ecx

; 288  : 			{	// test for iterator equality

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 289  : 
; 290  :  #if _HAS_ITERATOR_DEBUGGING
; 291  : 			if (this->_Mycont == 0 || this->_Mycont != _Right._Mycont)
; 292  : 				{
; 293  : 				_DEBUG_ERROR("map/set iterators incompatible");
; 294  : 				_SCL_SECURE_INVALID_ARGUMENT;
; 295  : 				}
; 296  :  #else
; 297  : 			_SCL_SECURE_VALIDATE(this->_Mycont != NULL && this->_Mycont == _Right._Mycont);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN1@operator@9
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [edx]
	je	SHORT $LN2@operator@9
$LN1@operator@9:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator@9:

; 298  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 299  : 
; 300  : 			return (_Ptr == _Right._Ptr);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx+4]
	sete	cl
	mov	al, cl

; 301  : 			}

	mov	esp, ebp
	pop	ebp
	ret	4
??8const_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBE_NABV012@@Z ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator::operator==
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??9const_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBE_NABV012@@Z PROC ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator::operator!=, COMDAT
; _this$ = ecx

; 304  : 			{	// test for iterator inequality

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 305  : 			return (!(*this == _Right));

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8const_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator::operator==
	movzx	eax, al
	neg	eax
	sbb	eax, eax
	add	eax, 1

; 306  : 			}

	mov	esp, ebp
	pop	ebp
	ret	4
??9const_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBE_NABV012@@Z ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator::operator!=
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAE_NI@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Buy
PUBLIC	??0?$_Vector_val@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAE@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z ; std::_Vector_val<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Vector_val<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	??0?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@XZ ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 8\vc\include\vector
;	COMDAT ??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT
; _this$ = ecx

; 457  : 		{	// construct empty vector

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	call	??0?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@XZ ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_val@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAE@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z ; std::_Vector_val<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Vector_val<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >

; 458  : 		_Buy(0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAE_NI@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Buy

; 459  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Tidy
PUBLIC	??$_Ucopy@V?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@V?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@1@0PAV21@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Ucopy<std::_Vector_const_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
PUBLIC	?begin@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBE?AV?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::begin
PUBLIC	?end@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBE?AV?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::end
PUBLIC	?size@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::size
PUBLIC	??0?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@ABV01@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@ABV01@@Z$0
__unwindtable$??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@ABV01@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@ABV01@@Z$2
__ehfuncinfo$??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@ABV01@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@ABV01@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
tv134 = -52						; size = 4
tv133 = -48						; size = 4
tv132 = -44						; size = 4
_this$ = -40						; size = 4
$T31847 = -36						; size = 8
$T31846 = -28						; size = 8
$T31845 = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Right$ = 8						; size = 4
??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@ABV01@@Z PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT
; _this$ = ecx

; 487  : 		{	// construct by copying _Right

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 36					; 00000024H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T31845[ebp], esp
	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	call	??0?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_val@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAE@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z ; std::_Vector_val<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Vector_val<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >

; 488  : 		if (_Buy(_Right.size()))

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::size
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAE_NI@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Buy
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN3@vector@2

; 489  : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 490  : 			_Mylast = _Ucopy(_Right.begin(), _Right.end(), _Myfirst);

	lea	edx, DWORD PTR $T31846[ebp]
	push	edx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?end@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBE?AV?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::end
	mov	DWORD PTR tv132[ebp], eax
	lea	eax, DWORD PTR $T31847[ebp]
	push	eax
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?begin@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBE?AV?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::begin
	mov	DWORD PTR tv133[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR tv132[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	eax, DWORD PTR tv133[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Ucopy@V?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@V?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@1@0PAV21@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Ucopy<std::_Vector_const_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
	mov	DWORD PTR tv134[ebp], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR tv134[ebp]
	mov	DWORD PTR [eax+8], ecx
	jmp	SHORT $LN5@vector@2
__catch$??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@ABV01@@Z$0:

; 491  : 			_CATCH_ALL
; 492  : 			_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Tidy

; 493  : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
	mov	eax, $LN3@vector@2
	ret	0
$LN5@vector@2:

; 494  : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
$LN3@vector@2:

; 495  : 		}

	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@2:
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-56]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@ABV01@@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
; Function compile flags: /Odtp
;	COMDAT ??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT
; _this$ = ecx

; 545  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 546  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Tidy

; 547  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Destroy
PUBLIC	?deallocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::deallocate
PUBLIC	??$_Umove@V?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@V?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@1@0PAV21@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Umove<std::_Vector_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
PUBLIC	?begin@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::begin
PUBLIC	?end@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::end
PUBLIC	?allocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::allocate
PUBLIC	?capacity@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::capacity
PUBLIC	?_Xlen@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@KAXXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Xlen
PUBLIC	?max_size@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::max_size
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?reserve@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXI@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?reserve@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXI@Z$0
__unwindtable$?reserve@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXI@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?reserve@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXI@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?reserve@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXI@Z$2
__ehfuncinfo$?reserve@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?reserve@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXI@Z
	DD	01H
	DD	FLAT:__tryblocktable$?reserve@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXI@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?reserve@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXI@Z
_TEXT	SEGMENT
tv146 = -52						; size = 4
tv145 = -48						; size = 4
_this$ = -44						; size = 4
$T31865 = -40						; size = 8
$T31864 = -32						; size = 8
__Size$24083 = -24					; size = 4
__Ptr$24026 = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Count$ = 8						; size = 4
?reserve@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXI@Z PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::reserve, COMDAT
; _this$ = ecx

; 589  : 		{	// determine new minimum length of allocated storage

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?reserve@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 36					; 00000024H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 590  : 		if (max_size() < _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::max_size
	cmp	eax, DWORD PTR __Count$[ebp]
	jae	SHORT $LN5@reserve

; 591  : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@KAXXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Xlen
	jmp	$LN7@reserve
$LN5@reserve:

; 592  : 		else if (capacity() < _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?capacity@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::capacity
	cmp	eax, DWORD PTR __Count$[ebp]
	jae	$LN7@reserve

; 593  : 			{	// not enough room, reallocate
; 594  : 			pointer _Ptr = this->_Alval.allocate(_Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?allocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::allocate
	mov	DWORD PTR __Ptr$24026[ebp], eax

; 595  : 
; 596  : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 597  : 			_Umove(begin(), end(), _Ptr);

	lea	ecx, DWORD PTR $T31864[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::end
	mov	DWORD PTR tv145[ebp], eax
	lea	edx, DWORD PTR $T31865[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::begin
	mov	DWORD PTR tv146[ebp], eax
	mov	eax, DWORD PTR __Ptr$24026[ebp]
	push	eax
	mov	ecx, DWORD PTR tv145[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR [ecx]
	push	eax
	mov	ecx, DWORD PTR tv146[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR [ecx]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@V?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@V?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@1@0PAV21@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Umove<std::_Vector_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
	jmp	SHORT $LN8@reserve
__catch$?reserve@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXI@Z$0:

; 598  : 			_CATCH_ALL
; 599  : 			this->_Alval.deallocate(_Ptr, _Count);

	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Ptr$24026[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?deallocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::deallocate

; 600  : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
	mov	eax, __tryend$?reserve@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXI@Z$1
	ret	0
$LN8@reserve:

; 601  : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?reserve@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXI@Z$1:

; 602  : 
; 603  : 			size_type _Size = size();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::size
	mov	DWORD PTR __Size$24083[ebp], eax

; 604  : 			if (_Myfirst != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN1@reserve

; 605  : 				{	// destroy and deallocate old array
; 606  : 				_Destroy(_Myfirst, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Destroy

; 607  : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	sub	ecx, DWORD PTR [eax+4]
	mov	eax, ecx
	cdq
	mov	ecx, 28					; 0000001cH
	idiv	ecx
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?deallocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::deallocate
$LN1@reserve:

; 608  : 				}
; 609  : 
; 610  :  #if _HAS_ITERATOR_DEBUGGING
; 611  : 			this->_Orphan_all();
; 612  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 613  : 
; 614  : 			_Myend = _Ptr + _Count;

	mov	ecx, DWORD PTR __Count$[ebp]
	imul	ecx, 28					; 0000001cH
	add	ecx, DWORD PTR __Ptr$24026[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], ecx

; 615  : 			_Mylast = _Ptr + _Size;

	mov	eax, DWORD PTR __Size$24083[ebp]
	imul	eax, 28					; 0000001cH
	add	eax, DWORD PTR __Ptr$24026[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 616  : 			_Myfirst = _Ptr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Ptr$24026[ebp]
	mov	DWORD PTR [edx+4], eax
$LN7@reserve:

; 617  : 			}
; 618  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?reserve@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXI@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-56]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?reserve@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?reserve@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXI@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::reserve
PUBLIC	?insert@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V32@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::insert
PUBLIC	?_Ufill@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@PAV32@IABV32@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Ufill
; Function compile flags: /Odtp
;	COMDAT ?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T31881 = -16						; size = 8
$T31880 = -8						; size = 8
__Val$ = 8						; size = 4
?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::push_back, COMDAT
; _this$ = ecx

; 786  : 		{	// insert element at end

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 787  : 		if (size() < capacity())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?capacity@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::capacity
	cmp	esi, eax
	jae	SHORT $LN2@push_back@3

; 788  : 
; 789  :  #if _HAS_ITERATOR_DEBUGGING
; 790  : 			{ // room at end, construct it there
; 791  : 			_Orphan_range(_Mylast, _Mylast);
; 792  : 			_Mylast = _Ufill(_Mylast, 1, _Val);
; 793  : 			}
; 794  : 
; 795  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 796  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Ufill@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@PAV32@IABV32@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Ufill
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 797  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 798  : 
; 799  : 		else

	jmp	SHORT $LN3@push_back@3
$LN2@push_back@3:

; 800  : 			insert(end(), _Val);

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	lea	eax, DWORD PTR $T31880[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::end
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	lea	eax, DWORD PTR $T31881[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?insert@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V32@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::insert
$LN3@push_back@3:

; 801  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::push_back
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 8\vc\include\utility
xdata$x	SEGMENT
__unwindtable$??0?$pair@$$CBVCZString@Value@Json@@V23@@std@@QAE@ABVCZString@Value@Json@@ABV34@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$pair@$$CBVCZString@Value@Json@@V23@@std@@QAE@ABVCZString@Value@Json@@ABV34@@Z$0
__ehfuncinfo$??0?$pair@$$CBVCZString@Value@Json@@V23@@std@@QAE@ABVCZString@Value@Json@@ABV34@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$pair@$$CBVCZString@Value@Json@@V23@@std@@QAE@ABVCZString@Value@Json@@ABV34@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$pair@$$CBVCZString@Value@Json@@V23@@std@@QAE@ABVCZString@Value@Json@@ABV34@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??0?$pair@$$CBVCZString@Value@Json@@V23@@std@@QAE@ABVCZString@Value@Json@@ABV34@@Z PROC ; std::pair<Json::Value::CZString const ,Json::Value>::pair<Json::Value::CZString const ,Json::Value>, COMDAT
; _this$ = ecx

; 37   : 		{	// construct from specified values

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$pair@$$CBVCZString@Value@Json@@V23@@std@@QAE@ABVCZString@Value@Json@@ABV34@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Val1$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0CZString@Value@Json@@QAE@ABV012@@Z	; Json::Value::CZString::CZString
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR __Val2$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??0Value@Json@@QAE@ABV01@@Z		; Json::Value::Value

; 38   : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$pair@$$CBVCZString@Value@Json@@V23@@std@@QAE@ABVCZString@Value@Json@@ABV34@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1CZString@Value@Json@@QAE@XZ		; Json::Value::CZString::~CZString
__ehhandler$??0?$pair@$$CBVCZString@Value@Json@@V23@@std@@QAE@ABVCZString@Value@Json@@ABV34@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$pair@$$CBVCZString@Value@Json@@V23@@std@@QAE@ABVCZString@Value@Json@@ABV34@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$pair@$$CBVCZString@Value@Json@@V23@@std@@QAE@ABVCZString@Value@Json@@ABV34@@Z ENDP ; std::pair<Json::Value::CZString const ,Json::Value>::pair<Json::Value::CZString const ,Json::Value>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 8\vc\include\vector
;	COMDAT ??D?$_Vector_const_iterator@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QBEABQBVPathArgument@Json@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??D?$_Vector_const_iterator@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QBEABQBVPathArgument@Json@@XZ PROC ; std::_Vector_const_iterator<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::operator*, COMDAT
; _this$ = ecx

; 92   : 		{	// return designated object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 93   : 
; 94   :  #if _HAS_ITERATOR_DEBUGGING
; 95   : 		if (this->_Mycont == 0
; 96   : 			|| _Myptr < ((_Myvec *)this->_Mycont)->_Myfirst
; 97   : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 98   : 			{
; 99   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 100  : 			_SCL_SECURE_OUT_OF_RANGE;
; 101  : 			}
; 102  :  #else
; 103  :  		_SCL_SECURE_VALIDATE(this->_Mycont != NULL);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN2@operator@10
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator@10:

; 104  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Mycont))->_Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, DWORD PTR [edx+8]
	jb	SHORT $LN1@operator@10
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN1@operator@10:

; 105  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 106  : 
; 107  : 		return (*_Myptr);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]

; 108  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??D?$_Vector_const_iterator@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QBEABQBVPathArgument@Json@@XZ ENDP ; std::_Vector_const_iterator<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::operator*
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??8?$_Vector_const_iterator@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::operator==, COMDAT
; _this$ = ecx

; 190  : 		{	// test for iterator equality

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 191  : 
; 192  :  #if _HAS_ITERATOR_DEBUGGING
; 193  : 		_Compat(_Right);
; 194  :  #else
; 195  : 		_SCL_SECURE_VALIDATE(this->_Mycont != NULL && this->_Mycont == _Right._Mycont);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN1@operator@11
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [edx]
	je	SHORT $LN2@operator@11
$LN1@operator@11:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator@11:

; 196  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 197  : 
; 198  : 		return (_Myptr == _Right._Myptr);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx+4]
	sete	cl
	mov	al, cl

; 199  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??8?$_Vector_const_iterator@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::operator==
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??D?$_Vector_const_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBEABVPathArgument@Json@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??D?$_Vector_const_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBEABVPathArgument@Json@@XZ PROC ; std::_Vector_const_iterator<Json::PathArgument,std::allocator<Json::PathArgument> >::operator*, COMDAT
; _this$ = ecx

; 92   : 		{	// return designated object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 93   : 
; 94   :  #if _HAS_ITERATOR_DEBUGGING
; 95   : 		if (this->_Mycont == 0
; 96   : 			|| _Myptr < ((_Myvec *)this->_Mycont)->_Myfirst
; 97   : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 98   : 			{
; 99   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 100  : 			_SCL_SECURE_OUT_OF_RANGE;
; 101  : 			}
; 102  :  #else
; 103  :  		_SCL_SECURE_VALIDATE(this->_Mycont != NULL);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN2@operator@12
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator@12:

; 104  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Mycont))->_Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, DWORD PTR [edx+8]
	jb	SHORT $LN1@operator@12
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN1@operator@12:

; 105  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 106  : 
; 107  : 		return (*_Myptr);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]

; 108  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??D?$_Vector_const_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBEABVPathArgument@Json@@XZ ENDP ; std::_Vector_const_iterator<Json::PathArgument,std::allocator<Json::PathArgument> >::operator*
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??E?$_Vector_const_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??E?$_Vector_const_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<Json::PathArgument,std::allocator<Json::PathArgument> >::operator++, COMDAT
; _this$ = ecx

; 116  : 		{	// preincrement

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 117  : 		_SCL_SECURE_VALIDATE(this->_Mycont != NULL);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN2@operator@13
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator@13:

; 118  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Mycont))->_Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, DWORD PTR [edx+8]
	jb	SHORT $LN1@operator@13
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN1@operator@13:

; 119  : 		++_Myptr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	add	eax, 36					; 00000024H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 120  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 121  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??E?$_Vector_const_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<Json::PathArgument,std::allocator<Json::PathArgument> >::operator++
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Json::PathArgument,std::allocator<Json::PathArgument> >::operator==
; Function compile flags: /Odtp
;	COMDAT ??9?$_Vector_const_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<Json::PathArgument,std::allocator<Json::PathArgument> >::operator!=, COMDAT
; _this$ = ecx

; 202  : 		{	// test for iterator inequality

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 203  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8?$_Vector_const_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Json::PathArgument,std::allocator<Json::PathArgument> >::operator==
	movzx	eax, al
	neg	eax
	sbb	eax, eax
	add	eax, 1

; 204  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??9?$_Vector_const_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<Json::PathArgument,std::allocator<Json::PathArgument> >::operator!=
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
tv70 = -8						; size = 4
_this$ = -4						; size = 4
?capacity@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QBEIXZ PROC ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::capacity, COMDAT
; _this$ = ecx

; 621  : 		{	// return current length of allocated storage

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 622  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN3@capacity
	mov	DWORD PTR tv70[ebp], 0
	jmp	SHORT $LN4@capacity
$LN3@capacity:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	mov	DWORD PTR tv70[ebp], eax
$LN4@capacity:
	mov	eax, DWORD PTR tv70[ebp]

; 623  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?capacity@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QBEIXZ ENDP ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::capacity
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QAE@PAPBVPathArgument@Json@@PBU_Container_base@1@@Z ; std::_Vector_iterator<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::_Vector_iterator<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >
; Function compile flags: /Odtp
;	COMDAT ?end@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QAE?AV?$_Vector_iterator@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QAE?AV?$_Vector_iterator@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@2@XZ PROC ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::end, COMDAT
; _this$ = ecx

; 637  : 		{	// return iterator for end of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 638  : 		return (iterator(_Mylast, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QAE@PAPBVPathArgument@Json@@PBU_Container_base@1@@Z ; std::_Vector_iterator<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::_Vector_iterator<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 639  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QAE?AV?$_Vector_iterator@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@2@XZ ENDP ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::end
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?size@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
tv70 = -8						; size = 4
_this$ = -4						; size = 4
?size@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QBEIXZ PROC ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::size, COMDAT
; _this$ = ecx

; 702  : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 703  : 		return (_Myfirst == 0 ? 0 : _Mylast - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN3@size@2
	mov	DWORD PTR tv70[ebp], 0
	jmp	SHORT $LN4@size@2
$LN3@size@2:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	mov	DWORD PTR tv70[ebp], eax
$LN4@size@2:
	mov	eax, DWORD PTR tv70[ebp]

; 704  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QBEIXZ ENDP ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::size
_TEXT	ENDS
PUBLIC	??H?$_Vector_iterator@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::operator+
PUBLIC	?_Insert_n@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IAEXV?$_Vector_iterator@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@2@IABQBVPathArgument@Json@@@Z ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::_Insert_n
PUBLIC	??G?$_Vector_iterator@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QBEHABV?$_Vector_const_iterator@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@1@@Z ; std::_Vector_iterator<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::operator-
PUBLIC	?begin@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QAE?AV?$_Vector_iterator@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@2@XZ ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::begin
; Function compile flags: /Odtp
;	COMDAT ?insert@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QAE?AV?$_Vector_iterator@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@2@V32@ABQBVPathArgument@Json@@@Z
_TEXT	SEGMENT
tv73 = -28						; size = 4
_this$ = -24						; size = 4
$T31917 = -20						; size = 8
$T31914 = -12						; size = 8
__Off$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 8
__Val$ = 20						; size = 4
?insert@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QAE?AV?$_Vector_iterator@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@2@V32@ABQBVPathArgument@Json@@@Z PROC ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::insert, COMDAT
; _this$ = ecx

; 852  : 		{	// insert _Val at _Where

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 853  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QBEIXZ ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::size
	test	eax, eax
	jne	SHORT $LN3@insert@2
	mov	DWORD PTR tv73[ebp], 0
	jmp	SHORT $LN4@insert@2
$LN3@insert@2:
	lea	eax, DWORD PTR $T31914[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QAE?AV?$_Vector_iterator@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@2@XZ ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::begin
	push	eax
	lea	ecx, DWORD PTR __Where$[ebp]
	call	??G?$_Vector_iterator@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QBEHABV?$_Vector_const_iterator@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@1@@Z ; std::_Vector_iterator<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::operator-
	mov	DWORD PTR tv73[ebp], eax
$LN4@insert@2:
	mov	ecx, DWORD PTR tv73[ebp]
	mov	DWORD PTR __Off$[ebp], ecx

; 854  : 		_Insert_n(_Where, (size_type)1, _Val);

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	push	1
	mov	eax, DWORD PTR __Where$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert_n@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IAEXV?$_Vector_iterator@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@2@IABQBVPathArgument@Json@@@Z ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::_Insert_n

; 855  : 		return (begin() + _Off);

	mov	edx, DWORD PTR __Off$[ebp]
	push	edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T31917[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QAE?AV?$_Vector_iterator@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@2@XZ ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::begin
	mov	ecx, eax
	call	??H?$_Vector_iterator@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::operator+
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 856  : 		}

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?insert@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QAE?AV?$_Vector_iterator@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@2@V32@ABQBVPathArgument@Json@@@Z ENDP ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::insert
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@PBVPathArgument@Json@@@std@@QAEPAPBVPathArgument@Json@@I@Z ; std::allocator<Json::PathArgument const *>::allocate
PUBLIC	?_Xlen@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@KAXXZ ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::_Xlen
PUBLIC	?max_size@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QBEIXZ ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::max_size
; Function compile flags: /Odtp
;	COMDAT ?_Buy@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Capacity$ = 8						; size = 4
?_Buy@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IAE_NI@Z PROC ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::_Buy, COMDAT
; _this$ = ecx

; 1066 : 		{	// allocate array with _Capacity elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1067 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], 0

; 1068 : 		if (_Capacity == 0)

	cmp	DWORD PTR __Capacity$[ebp], 0
	jne	SHORT $LN4@Buy

; 1069 : 			return (false);

	xor	al, al
	jmp	SHORT $LN5@Buy
	jmp	SHORT $LN3@Buy
$LN4@Buy:

; 1070 : 		else if (max_size() < _Capacity)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QBEIXZ ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::max_size
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN2@Buy

; 1071 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@KAXXZ ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::_Xlen

; 1072 : 		else

	jmp	SHORT $LN3@Buy
$LN2@Buy:

; 1073 : 			{	// nonempty array, allocate storage
; 1074 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	mov	eax, DWORD PTR __Capacity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?allocate@?$allocator@PBVPathArgument@Json@@@std@@QAEPAPBVPathArgument@Json@@I@Z ; std::allocator<Json::PathArgument const *>::allocate
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 1075 : 			_Mylast = _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+8], ecx

; 1076 : 			_Myend = _Myfirst + _Capacity;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR __Capacity$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], edx
$LN3@Buy:

; 1077 : 			}
; 1078 : 		return (true);

	mov	al, 1
$LN5@Buy:

; 1079 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Buy@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::_Buy
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@PBVPathArgument@Json@@@std@@QAEXPAPBVPathArgument@Json@@I@Z ; std::allocator<Json::PathArgument const *>::deallocate
PUBLIC	?_Destroy@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IAEXPAPBVPathArgument@Json@@0@Z ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::_Destroy
; Function compile flags: /Odtp
;	COMDAT ?_Tidy@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Tidy@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IAEXXZ PROC ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::_Tidy, COMDAT
; _this$ = ecx

; 1087 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1088 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN1@Tidy

; 1089 : 			{	// something to free, destroy and deallocate it
; 1090 : 
; 1091 :  #if _HAS_ITERATOR_DEBUGGING
; 1092 : 			this->_Orphan_all();
; 1093 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1094 : 
; 1095 : 			_Destroy(_Myfirst, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IAEXPAPBVPathArgument@Json@@0@Z ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::_Destroy

; 1096 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	sub	ecx, DWORD PTR [eax+4]
	sar	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?deallocate@?$allocator@PBVPathArgument@Json@@@std@@QAEXPAPBVPathArgument@Json@@I@Z ; std::allocator<Json::PathArgument const *>::deallocate
$LN1@Tidy:

; 1097 : 			}
; 1098 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0

; 1099 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IAEXXZ ENDP ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::_Tidy
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_fill_n@PAPBVPathArgument@Json@@IPBV12@V?$allocator@PBVPathArgument@Json@@@std@@@stdext@@YAXPAPBVPathArgument@Json@@IABQBV12@AAV?$allocator@PBVPathArgument@Json@@@std@@@Z ; stdext::unchecked_uninitialized_fill_n<Json::PathArgument const * *,unsigned int,Json::PathArgument const *,std::allocator<Json::PathArgument const *> >
; Function compile flags: /Odtp
;	COMDAT ?_Ufill@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IAEPAPBVPathArgument@Json@@PAPBV34@IABQBV34@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Ufill@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IAEPAPBVPathArgument@Json@@PAPBV34@IABQBV34@@Z PROC ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::_Ufill, COMDAT
; _this$ = ecx

; 1207 : 		{	// copy initializing _Count * _Val, using allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1208 : 		_STDEXT unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??$unchecked_uninitialized_fill_n@PAPBVPathArgument@Json@@IPBV12@V?$allocator@PBVPathArgument@Json@@@std@@@stdext@@YAXPAPBVPathArgument@Json@@IABQBV12@AAV?$allocator@PBVPathArgument@Json@@@std@@@Z ; stdext::unchecked_uninitialized_fill_n<Json::PathArgument const * *,unsigned int,Json::PathArgument const *,std::allocator<Json::PathArgument const *> >
	add	esp, 16					; 00000010H

; 1209 : 		return (_Ptr + _Count);

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Ptr$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]

; 1210 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?_Ufill@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IAEPAPBVPathArgument@Json@@PAPBV34@IABQBV34@@Z ENDP ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::_Ufill
_TEXT	ENDS
PUBLIC	??0?$allocator@PBVPathArgument@Json@@@std@@QAE@ABV01@@Z ; std::allocator<Json::PathArgument const *>::allocator<Json::PathArgument const *>
; Function compile flags: /Odtp
;	COMDAT ??0?$_Vector_val@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IAE@V?$allocator@PBVPathArgument@Json@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Al$ = 8						; size = 1
??0?$_Vector_val@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IAE@V?$allocator@PBVPathArgument@Json@@@1@@Z PROC ; std::_Vector_val<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::_Vector_val<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >, COMDAT
; _this$ = ecx

; 412  : 		{	// construct allocator from _Al

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$allocator@PBVPathArgument@Json@@@std@@QAE@ABV01@@Z ; std::allocator<Json::PathArgument const *>::allocator<Json::PathArgument const *>

; 413  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_Vector_val@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IAE@V?$allocator@PBVPathArgument@Json@@@1@@Z ENDP ; std::_Vector_val<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::_Vector_val<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 8\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@PBVPathArgument@Json@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@PBVPathArgument@Json@@@std@@QAE@XZ PROC	; std::allocator<Json::PathArgument const *>::allocator<Json::PathArgument const *>, COMDAT
; _this$ = ecx

; 120  : 	allocator() _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 121  : 		{	// construct default allocator (do nothing)
; 122  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$allocator@PBVPathArgument@Json@@@std@@QAE@XZ ENDP	; std::allocator<Json::PathArgument const *>::allocator<Json::PathArgument const *>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 8\vc\include\vector
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
tv70 = -8						; size = 4
_this$ = -4						; size = 4
?capacity@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBEIXZ PROC ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::capacity, COMDAT
; _this$ = ecx

; 621  : 		{	// return current length of allocated storage

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 622  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN3@capacity@2
	mov	DWORD PTR tv70[ebp], 0
	jmp	SHORT $LN4@capacity@2
$LN3@capacity@2:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx+4]
	cdq
	mov	ecx, 36					; 00000024H
	idiv	ecx
	mov	DWORD PTR tv70[ebp], eax
$LN4@capacity@2:
	mov	eax, DWORD PTR tv70[ebp]

; 623  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?capacity@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBEIXZ ENDP ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::capacity
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAE@PAVPathArgument@Json@@PBU_Container_base@1@@Z ; std::_Vector_iterator<Json::PathArgument,std::allocator<Json::PathArgument> >::_Vector_iterator<Json::PathArgument,std::allocator<Json::PathArgument> >
; Function compile flags: /Odtp
;	COMDAT ?end@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAE?AV?$_Vector_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAE?AV?$_Vector_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@2@XZ PROC ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::end, COMDAT
; _this$ = ecx

; 637  : 		{	// return iterator for end of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 638  : 		return (iterator(_Mylast, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAE@PAVPathArgument@Json@@PBU_Container_base@1@@Z ; std::_Vector_iterator<Json::PathArgument,std::allocator<Json::PathArgument> >::_Vector_iterator<Json::PathArgument,std::allocator<Json::PathArgument> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 639  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAE?AV?$_Vector_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@2@XZ ENDP ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::end
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?size@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
tv70 = -8						; size = 4
_this$ = -4						; size = 4
?size@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBEIXZ PROC ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::size, COMDAT
; _this$ = ecx

; 702  : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 703  : 		return (_Myfirst == 0 ? 0 : _Mylast - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN3@size@3
	mov	DWORD PTR tv70[ebp], 0
	jmp	SHORT $LN4@size@3
$LN3@size@3:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	cdq
	mov	ecx, 36					; 00000024H
	idiv	ecx
	mov	DWORD PTR tv70[ebp], eax
$LN4@size@3:
	mov	eax, DWORD PTR tv70[ebp]

; 704  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBEIXZ ENDP ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::size
_TEXT	ENDS
PUBLIC	??H?$_Vector_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<Json::PathArgument,std::allocator<Json::PathArgument> >::operator+
PUBLIC	?_Insert_n@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAEXV?$_Vector_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@2@IABVPathArgument@Json@@@Z ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::_Insert_n
PUBLIC	??G?$_Vector_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBEHABV?$_Vector_const_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@1@@Z ; std::_Vector_iterator<Json::PathArgument,std::allocator<Json::PathArgument> >::operator-
PUBLIC	?begin@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAE?AV?$_Vector_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@2@XZ ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::begin
; Function compile flags: /Odtp
;	COMDAT ?insert@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAE?AV?$_Vector_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@2@V32@ABVPathArgument@Json@@@Z
_TEXT	SEGMENT
tv73 = -28						; size = 4
_this$ = -24						; size = 4
$T31943 = -20						; size = 8
$T31940 = -12						; size = 8
__Off$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 8
__Val$ = 20						; size = 4
?insert@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAE?AV?$_Vector_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@2@V32@ABVPathArgument@Json@@@Z PROC ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::insert, COMDAT
; _this$ = ecx

; 852  : 		{	// insert _Val at _Where

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 853  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBEIXZ ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::size
	test	eax, eax
	jne	SHORT $LN3@insert@3
	mov	DWORD PTR tv73[ebp], 0
	jmp	SHORT $LN4@insert@3
$LN3@insert@3:
	lea	eax, DWORD PTR $T31940[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAE?AV?$_Vector_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@2@XZ ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::begin
	push	eax
	lea	ecx, DWORD PTR __Where$[ebp]
	call	??G?$_Vector_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBEHABV?$_Vector_const_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@1@@Z ; std::_Vector_iterator<Json::PathArgument,std::allocator<Json::PathArgument> >::operator-
	mov	DWORD PTR tv73[ebp], eax
$LN4@insert@3:
	mov	ecx, DWORD PTR tv73[ebp]
	mov	DWORD PTR __Off$[ebp], ecx

; 854  : 		_Insert_n(_Where, (size_type)1, _Val);

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	push	1
	mov	eax, DWORD PTR __Where$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert_n@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAEXV?$_Vector_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@2@IABVPathArgument@Json@@@Z ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::_Insert_n

; 855  : 		return (begin() + _Off);

	mov	edx, DWORD PTR __Off$[ebp]
	push	edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T31943[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAE?AV?$_Vector_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@2@XZ ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::begin
	mov	ecx, eax
	call	??H?$_Vector_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<Json::PathArgument,std::allocator<Json::PathArgument> >::operator+
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 856  : 		}

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?insert@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAE?AV?$_Vector_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@2@V32@ABVPathArgument@Json@@@Z ENDP ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::insert
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@VPathArgument@Json@@@std@@QAEPAVPathArgument@Json@@I@Z ; std::allocator<Json::PathArgument>::allocate
PUBLIC	?_Xlen@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@KAXXZ ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::_Xlen
PUBLIC	?max_size@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBEIXZ ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::max_size
; Function compile flags: /Odtp
;	COMDAT ?_Buy@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Capacity$ = 8						; size = 4
?_Buy@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAE_NI@Z PROC ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::_Buy, COMDAT
; _this$ = ecx

; 1066 : 		{	// allocate array with _Capacity elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1067 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], 0

; 1068 : 		if (_Capacity == 0)

	cmp	DWORD PTR __Capacity$[ebp], 0
	jne	SHORT $LN4@Buy@2

; 1069 : 			return (false);

	xor	al, al
	jmp	SHORT $LN5@Buy@2
	jmp	SHORT $LN3@Buy@2
$LN4@Buy@2:

; 1070 : 		else if (max_size() < _Capacity)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBEIXZ ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::max_size
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN2@Buy@2

; 1071 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@KAXXZ ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::_Xlen

; 1072 : 		else

	jmp	SHORT $LN3@Buy@2
$LN2@Buy@2:

; 1073 : 			{	// nonempty array, allocate storage
; 1074 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	mov	eax, DWORD PTR __Capacity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?allocate@?$allocator@VPathArgument@Json@@@std@@QAEPAVPathArgument@Json@@I@Z ; std::allocator<Json::PathArgument>::allocate
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 1075 : 			_Mylast = _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+8], ecx

; 1076 : 			_Myend = _Myfirst + _Capacity;

	mov	edx, DWORD PTR __Capacity$[ebp]
	imul	edx, 36					; 00000024H
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], edx
$LN3@Buy@2:

; 1077 : 			}
; 1078 : 		return (true);

	mov	al, 1
$LN5@Buy@2:

; 1079 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Buy@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::_Buy
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@VPathArgument@Json@@@std@@QAEXPAVPathArgument@Json@@I@Z ; std::allocator<Json::PathArgument>::deallocate
PUBLIC	?_Destroy@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAEXPAVPathArgument@Json@@0@Z ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::_Destroy
; Function compile flags: /Odtp
;	COMDAT ?_Tidy@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Tidy@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAEXXZ PROC ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::_Tidy, COMDAT
; _this$ = ecx

; 1087 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1088 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN1@Tidy@2

; 1089 : 			{	// something to free, destroy and deallocate it
; 1090 : 
; 1091 :  #if _HAS_ITERATOR_DEBUGGING
; 1092 : 			this->_Orphan_all();
; 1093 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1094 : 
; 1095 : 			_Destroy(_Myfirst, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAEXPAVPathArgument@Json@@0@Z ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::_Destroy

; 1096 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	sub	ecx, DWORD PTR [eax+4]
	mov	eax, ecx
	cdq
	mov	ecx, 36					; 00000024H
	idiv	ecx
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?deallocate@?$allocator@VPathArgument@Json@@@std@@QAEXPAVPathArgument@Json@@I@Z ; std::allocator<Json::PathArgument>::deallocate
$LN1@Tidy@2:

; 1097 : 			}
; 1098 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0

; 1099 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAEXXZ ENDP ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::_Tidy
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_fill_n@PAVPathArgument@Json@@IV12@V?$allocator@VPathArgument@Json@@@std@@@stdext@@YAXPAVPathArgument@Json@@IABV12@AAV?$allocator@VPathArgument@Json@@@std@@@Z ; stdext::unchecked_uninitialized_fill_n<Json::PathArgument *,unsigned int,Json::PathArgument,std::allocator<Json::PathArgument> >
; Function compile flags: /Odtp
;	COMDAT ?_Ufill@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAEPAVPathArgument@Json@@PAV34@IABV34@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Ufill@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAEPAVPathArgument@Json@@PAV34@IABV34@@Z PROC ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::_Ufill, COMDAT
; _this$ = ecx

; 1207 : 		{	// copy initializing _Count * _Val, using allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1208 : 		_STDEXT unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??$unchecked_uninitialized_fill_n@PAVPathArgument@Json@@IV12@V?$allocator@VPathArgument@Json@@@std@@@stdext@@YAXPAVPathArgument@Json@@IABV12@AAV?$allocator@VPathArgument@Json@@@std@@@Z ; stdext::unchecked_uninitialized_fill_n<Json::PathArgument *,unsigned int,Json::PathArgument,std::allocator<Json::PathArgument> >
	add	esp, 16					; 00000010H

; 1209 : 		return (_Ptr + _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	imul	eax, 36					; 00000024H
	add	eax, DWORD PTR __Ptr$[ebp]

; 1210 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?_Ufill@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAEPAVPathArgument@Json@@PAV34@IABV34@@Z ENDP ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::_Ufill
_TEXT	ENDS
PUBLIC	??0?$allocator@VPathArgument@Json@@@std@@QAE@ABV01@@Z ; std::allocator<Json::PathArgument>::allocator<Json::PathArgument>
; Function compile flags: /Odtp
;	COMDAT ??0?$_Vector_val@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAE@V?$allocator@VPathArgument@Json@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Al$ = 8						; size = 1
??0?$_Vector_val@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAE@V?$allocator@VPathArgument@Json@@@1@@Z PROC ; std::_Vector_val<Json::PathArgument,std::allocator<Json::PathArgument> >::_Vector_val<Json::PathArgument,std::allocator<Json::PathArgument> >, COMDAT
; _this$ = ecx

; 412  : 		{	// construct allocator from _Al

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$allocator@VPathArgument@Json@@@std@@QAE@ABV01@@Z ; std::allocator<Json::PathArgument>::allocator<Json::PathArgument>

; 413  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_Vector_val@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAE@V?$allocator@VPathArgument@Json@@@1@@Z ENDP ; std::_Vector_val<Json::PathArgument,std::allocator<Json::PathArgument> >::_Vector_val<Json::PathArgument,std::allocator<Json::PathArgument> >
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 8\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@VPathArgument@Json@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@VPathArgument@Json@@@std@@QAE@XZ PROC	; std::allocator<Json::PathArgument>::allocator<Json::PathArgument>, COMDAT
; _this$ = ecx

; 120  : 	allocator() _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 121  : 		{	// construct default allocator (do nothing)
; 122  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$allocator@VPathArgument@Json@@@std@@QAE@XZ ENDP	; std::allocator<Json::PathArgument>::allocator<Json::PathArgument>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 8\vc\include\xtree
_TEXT	ENDS
;	COMDAT ?_Color@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Color@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Color, COMDAT

; 140  : 		{	// return reference to color in node

	push	ebp
	mov	ebp, esp

; 141  : 		return ((_Charref)(*_Pnode)._Color);

	mov	eax, DWORD PTR __Pnode$[ebp]
	add	eax, 40					; 00000028H

; 142  : 		}

	pop	ebp
	ret	0
?_Color@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Color
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Isnil@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Isnil, COMDAT

; 145  : 		{	// return reference to nil flag in node

	push	ebp
	mov	ebp, esp

; 146  : 		return ((_Charref)(*_Pnode)._Isnil);

	mov	eax, DWORD PTR __Pnode$[ebp]
	add	eax, 41					; 00000029H

; 147  : 		}

	pop	ebp
	ret	0
?_Isnil@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Isnil
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Key@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAABVCZString@Value@Json@@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Key@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAABVCZString@Value@Json@@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Key, COMDAT

; 150  : 		{	// return reference to key in node

	push	ebp
	mov	ebp, esp

; 151  : 		return (_Mybase::_Kfn(_Myval(_Pnode)));

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Myval@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAU?$pair@$$CBVCZString@Value@Json@@V23@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Myval
	add	esp, 4
	push	eax
	call	?_Kfn@?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@SAABVCZString@Value@Json@@ABU?$pair@$$CBVCZString@Value@Json@@V23@@2@@Z ; std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0>::_Kfn
	add	esp, 4

; 152  : 		}

	pop	ebp
	ret	0
?_Key@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAABVCZString@Value@Json@@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Key
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Left@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Left, COMDAT

; 155  : 		{	// return reference to left pointer in node

	push	ebp
	mov	ebp, esp

; 156  : 		return ((_Nodepref)(*_Pnode)._Left);

	mov	eax, DWORD PTR __Pnode$[ebp]

; 157  : 		}

	pop	ebp
	ret	0
?_Left@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Left
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Parent@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Parent, COMDAT

; 160  : 		{	// return reference to parent pointer in node

	push	ebp
	mov	ebp, esp

; 161  : 		return ((_Nodepref)(*_Pnode)._Parent);

	mov	eax, DWORD PTR __Pnode$[ebp]
	add	eax, 4

; 162  : 		}

	pop	ebp
	ret	0
?_Parent@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Parent
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Right@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Right, COMDAT

; 165  : 		{	// return reference to right pointer in node

	push	ebp
	mov	ebp, esp

; 166  : 		return ((_Nodepref)(*_Pnode)._Right);

	mov	eax, DWORD PTR __Pnode$[ebp]
	add	eax, 8

; 167  : 		}

	pop	ebp
	ret	0
?_Right@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Right
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Myval@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAU?$pair@$$CBVCZString@Value@Json@@V23@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Myval@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAU?$pair@$$CBVCZString@Value@Json@@V23@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Myval, COMDAT

; 170  : 		{	// return reference to value in node

	push	ebp
	mov	ebp, esp

; 171  : 		return ((_Vref)(*_Pnode)._Myval);

	mov	eax, DWORD PTR __Pnode$[ebp]
	add	eax, 16					; 00000010H

; 172  : 		}

	pop	ebp
	ret	0
?_Myval@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAU?$pair@$$CBVCZString@Value@Json@@V23@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Myval
_TEXT	ENDS
PUBLIC	??0?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >::allocator<std::pair<Json::Value::CZString const ,Json::Value> >
; Function compile flags: /Odtp
;	COMDAT ??0?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE@ABU?$less@VCZString@Value@Json@@@1@ABV?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 4
??0?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE@ABU?$less@VCZString@Value@Json@@@1@ABV?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@1@@Z PROC ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >, COMDAT
; _this$ = ecx

; 495  : 		{	// construct empty tree

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	call	??0?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >::allocator<std::pair<Json::Value::CZString const ,Json::Value> >
	mov	ecx, DWORD PTR __Parg$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Tree_val@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAE@ABU?$less@VCZString@Value@Json@@@1@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@1@@Z ; std::_Tree_val<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Tree_val<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >

; 496  : 		_Init();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Init@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Init

; 497  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE@ABU?$less@VCZString@Value@Json@@@1@ABV?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?get_allocator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBE?AV?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?get_allocator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBE?AV?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::get_allocator, COMDAT
; _this$ = ecx

; 596  : 		{	// return allocator object for values

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 597  : 		return (this->_Alval);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 3
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >::allocator<std::pair<Json::Value::CZString const ,Json::Value> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 598  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?get_allocator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBE?AV?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::get_allocator
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?key_comp@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBE?AU?$less@VCZString@Value@Json@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?key_comp@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBE?AU?$less@VCZString@Value@Json@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::key_comp, COMDAT
; _this$ = ecx

; 601  : 		{	// return object for comparing keys

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 602  : 		return (this->comp);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 603  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?key_comp@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBE?AU?$less@VCZString@Value@Json@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::key_comp
_TEXT	ENDS
PUBLIC	??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@1@AB_N@Z ; std::pair<std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::iterator,bool>::pair<std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::iterator,bool>
; Function compile flags: /Odtp
;	COMDAT ?insert@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBVCZString@Value@Json@@V23@@2@@Z
_TEXT	SEGMENT
tv85 = -76						; size = 4
_this$ = -72						; size = 4
$T31986 = -65						; size = 1
$T31985 = -64						; size = 8
$T31984 = -53						; size = 1
$T31983 = -52						; size = 8
$T31982 = -41						; size = 1
$T31981 = -40						; size = 8
$T31980 = -32						; size = 8
$T31979 = -21						; size = 1
__Where$25220 = -20					; size = 8
__Trynode$ = -12					; size = 4
__Wherenode$ = -8					; size = 4
__Addleft$ = -1						; size = 1
___$ReturnUdt$ = 8					; size = 4
__Val$ = 12						; size = 4
?insert@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBVCZString@Value@Json@@V23@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::insert, COMDAT
; _this$ = ecx

; 611  : 		{	// try to insert node with value _Val

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	mov	DWORD PTR _this$[ebp], ecx

; 612  : 		_Nodeptr _Trynode = _Root();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Root
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR __Trynode$[ebp], eax

; 613  : 		_Nodeptr _Wherenode = _Myhead;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR __Wherenode$[ebp], edx

; 614  : 		bool _Addleft = true;	// add to left of head if tree empty

	mov	BYTE PTR __Addleft$[ebp], 1
$LN10@insert@4:

; 615  : 		while (!_Isnil(_Trynode))

	mov	eax, DWORD PTR __Trynode$[ebp]
	push	eax
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Isnil
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN9@insert@4

; 616  : 			{	// look for leaf to insert before (_Addleft) or after
; 617  : 			_Wherenode = _Trynode;

	mov	edx, DWORD PTR __Trynode$[ebp]
	mov	DWORD PTR __Wherenode$[ebp], edx

; 618  : 			_Addleft = _DEBUG_LT_PRED(this->comp,

	mov	eax, DWORD PTR __Trynode$[ebp]
	push	eax
	call	?_Key@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAABVCZString@Value@Json@@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Key
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	call	?_Kfn@?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@SAABVCZString@Value@Json@@ABU?$pair@$$CBVCZString@Value@Json@@V23@@2@@Z ; std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0>::_Kfn
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??R?$less@VCZString@Value@Json@@@std@@QBE_NABVCZString@Value@Json@@0@Z ; std::less<Json::Value::CZString>::operator()
	mov	BYTE PTR __Addleft$[ebp], al

; 619  : 				this->_Kfn(_Val), _Key(_Trynode));
; 620  : 			_Trynode = _Addleft ? _Left(_Trynode) : _Right(_Trynode);

	movzx	edx, BYTE PTR __Addleft$[ebp]
	test	edx, edx
	je	SHORT $LN13@insert@4
	mov	eax, DWORD PTR __Trynode$[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv85[ebp], ecx
	jmp	SHORT $LN14@insert@4
$LN13@insert@4:
	mov	edx, DWORD PTR __Trynode$[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Right
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR tv85[ebp], eax
$LN14@insert@4:
	mov	ecx, DWORD PTR tv85[ebp]
	mov	DWORD PTR __Trynode$[ebp], ecx

; 621  : 			}

	jmp	SHORT $LN10@insert@4
$LN9@insert@4:

; 622  : 
; 623  : 		if (this->_Multi)

	xor	edx, edx
	je	SHORT $LN8@insert@4

; 624  : 			return (_Pairib(_Insert(_Addleft, _Wherenode, _Val), true));

	mov	BYTE PTR $T31979[ebp], 1
	lea	eax, DWORD PTR $T31979[ebp]
	push	eax
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	mov	al, BYTE PTR __Addleft$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T31980[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@ABU?$pair@$$CBVCZString@Value@Json@@V23@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Insert
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@1@AB_N@Z ; std::pair<std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::iterator,bool>::pair<std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::iterator,bool>
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN11@insert@4

; 625  : 		else

	jmp	$LN11@insert@4
$LN8@insert@4:

; 626  : 			{	// insert only if unique
; 627  : 			iterator _Where = _TREE_ITERATOR(_Wherenode);

	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Where$25220[ebp]
	call	??0iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PBV12@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::iterator::iterator

; 628  : 			if (!_Addleft)

	movzx	ecx, BYTE PTR __Addleft$[ebp]
	test	ecx, ecx
	jne	SHORT $LN6@insert@4
	jmp	SHORT $LN5@insert@4
$LN6@insert@4:

; 629  : 				;	// need to test if insert after is okay
; 630  : 			else if (_Where == begin())

	lea	edx, DWORD PTR $T31981[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::begin
	push	eax
	lea	ecx, DWORD PTR __Where$25220[ebp]
	call	??8const_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN4@insert@4

; 631  : 				return (_Pairib(_Insert(true, _Wherenode, _Val), true));

	mov	BYTE PTR $T31982[ebp], 1
	lea	ecx, DWORD PTR $T31982[ebp]
	push	ecx
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	push	1
	lea	ecx, DWORD PTR $T31983[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@ABU?$pair@$$CBVCZString@Value@Json@@V23@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Insert
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@1@AB_N@Z ; std::pair<std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::iterator,bool>::pair<std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::iterator,bool>
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN11@insert@4

; 632  : 			else

	jmp	SHORT $LN5@insert@4
$LN4@insert@4:

; 633  : 				--_Where;	// need to test if insert before is okay

	lea	ecx, DWORD PTR __Where$25220[ebp]
	call	??Fiterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::iterator::operator--
$LN5@insert@4:

; 634  : 
; 635  : 			if (_DEBUG_LT_PRED(this->comp,

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	call	?_Kfn@?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@SAABVCZString@Value@Json@@ABU?$pair@$$CBVCZString@Value@Json@@V23@@2@@Z ; std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0>::_Kfn
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR __Where$25220[ebp]
	call	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator::_Mynode
	push	eax
	call	?_Key@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAABVCZString@Value@Json@@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Key
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??R?$less@VCZString@Value@Json@@@std@@QBE_NABVCZString@Value@Json@@0@Z ; std::less<Json::Value::CZString>::operator()
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@insert@4

; 636  : 				_Key(_Where._Mynode()), this->_Kfn(_Val)))
; 637  : 				return (_Pairib(_Insert(_Addleft, _Wherenode, _Val), true));

	mov	BYTE PTR $T31984[ebp], 1
	lea	ecx, DWORD PTR $T31984[ebp]
	push	ecx
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	mov	cl, BYTE PTR __Addleft$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T31985[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@ABU?$pair@$$CBVCZString@Value@Json@@V23@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Insert
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@1@AB_N@Z ; std::pair<std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::iterator,bool>::pair<std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::iterator,bool>
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN11@insert@4

; 638  : 			else

	jmp	SHORT $LN11@insert@4
$LN2@insert@4:

; 639  : 				return (_Pairib(_Where, false));

	mov	BYTE PTR $T31986[ebp], 0
	lea	eax, DWORD PTR $T31986[ebp]
	push	eax
	lea	ecx, DWORD PTR __Where$25220[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@1@AB_N@Z ; std::pair<std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::iterator,bool>::pair<std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::iterator,bool>
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN11@insert@4:

; 640  : 			}
; 641  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?insert@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBVCZString@Value@Json@@V23@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::insert
_TEXT	ENDS
PUBLIC	??Eiterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AV012@H@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::iterator::operator++
; Function compile flags: /Odtp
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@V312@0@Z
_TEXT	SEGMENT
_this$ = -36						; size = 4
$T31992 = -32						; size = 8
$T31991 = -24						; size = 8
$T31990 = -16						; size = 8
$T31989 = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 8
__Last$ = 20						; size = 8
?erase@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@V312@0@Z PROC ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::erase, COMDAT
; _this$ = ecx

; 917  : 		{	// erase [_First, _Last)

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	DWORD PTR _this$[ebp], ecx

; 918  : 		if (_First == begin() && _Last == end())

	lea	eax, DWORD PTR $T31989[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::begin
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	call	??8const_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator::operator==
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@erase@2
	lea	edx, DWORD PTR $T31990[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::end
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	call	??8const_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@erase@2

; 919  : 			{	// erase all
; 920  : 			clear();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?clear@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::clear

; 921  : 			return (begin());

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::begin
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN5@erase@2

; 922  : 			}
; 923  : 		else

	jmp	SHORT $LN5@erase@2
$LN2@erase@2:

; 924  : 			{	// partial erase, one at a time
; 925  : 			while (_First != _Last)

	lea	edx, DWORD PTR __Last$[ebp]
	push	edx
	lea	ecx, DWORD PTR __First$[ebp]
	call	??9const_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator::operator!=
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@erase@2

; 926  : 				erase(_First++);

	push	0
	lea	ecx, DWORD PTR $T31991[ebp]
	push	ecx
	lea	ecx, DWORD PTR __First$[ebp]
	call	??Eiterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AV012@H@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::iterator::operator++
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	lea	ecx, DWORD PTR $T31992[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@V312@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::erase
	jmp	SHORT $LN2@erase@2
$LN1@erase@2:

; 927  : 			return (_First);

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR __First$[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN5@erase@2:

; 928  : 			}
; 929  : 		}

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?erase@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@V312@0@Z ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::erase
_TEXT	ENDS
PUBLIC	??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@V123@@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@1@0@Z ; std::pair<std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::iterator,std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::iterator>::pair<std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::iterator,std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::iterator>
PUBLIC	?upper_bound@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@ABVCZString@Value@Json@@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::upper_bound
; Function compile flags: /Odtp
;	COMDAT ?equal_range@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@V123@@2@ABVCZString@Value@Json@@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T31996 = -16						; size = 8
$T31995 = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
?equal_range@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@V123@@2@ABVCZString@Value@Json@@@Z PROC ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::equal_range, COMDAT
; _this$ = ecx

; 1006 : 		{	// find range equivalent to _Keyval in mutable tree

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 1007 : 		return (_Pairii(lower_bound(_Keyval), upper_bound(_Keyval)));

	mov	eax, DWORD PTR __Keyval$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T31995[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?upper_bound@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@ABVCZString@Value@Json@@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::upper_bound
	push	eax
	mov	edx, DWORD PTR __Keyval$[ebp]
	push	edx
	lea	eax, DWORD PTR $T31996[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?lower_bound@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@ABVCZString@Value@Json@@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::lower_bound
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@V123@@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@1@0@Z ; std::pair<std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::iterator,std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::iterator>::pair<std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::iterator,std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::iterator>
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1008 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?equal_range@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@V123@@2@ABVCZString@Value@Json@@@Z ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::equal_range
_TEXT	ENDS
PUBLIC	?_Copy@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@0@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Copy
; Function compile flags: /Odtp
;	COMDAT ?_Copy@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEXABV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
?_Copy@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEXABV12@@Z PROC ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Copy, COMDAT
; _this$ = ecx

; 1036 : 		{	// copy entire tree from _Right

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 1037 : 		_Root() = _Copy(_Right._Root(), _Myhead);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Root
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Copy@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@0@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Copy
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Root
	mov	DWORD PTR [eax], esi

; 1038 : 		_Mysize = _Right.size();

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::size
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 1039 : 		if (!_Isnil(_Root()))

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Root
	mov	edx, DWORD PTR [eax]
	push	edx
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Isnil
	add	esp, 4
	movsx	eax, BYTE PTR [eax]
	test	eax, eax
	jne	SHORT $LN2@Copy

; 1040 : 			{	// nonempty tree, look for new smallest and largest
; 1041 : 			_Lmost() = _Min(_Root());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Root
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Min@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Min
	add	esp, 4
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lmost@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Lmost
	mov	DWORD PTR [eax], esi

; 1042 : 			_Rmost() = _Max(_Root());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Root
	mov	edx, DWORD PTR [eax]
	push	edx
	call	?_Max@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Max
	add	esp, 4
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rmost@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Rmost
	mov	DWORD PTR [eax], esi

; 1043 : 			}
; 1044 : 		else

	jmp	SHORT $LN3@Copy
$LN2@Copy:

; 1045 : 			_Lmost() = _Myhead, _Rmost() = _Myhead;	// empty tree

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lmost@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Lmost
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rmost@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Rmost
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], edx
$LN3@Copy:

; 1046 : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?_Copy@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEXABV12@@Z ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Copy
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Erase@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Pnode$25262 = -4					; size = 4
__Rootnode$ = 8						; size = 4
?_Erase@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Erase, COMDAT
; _this$ = ecx

; 1072 : 		{	// free entire subtree, recursively

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1073 : 		for (_Nodeptr _Pnode = _Rootnode; !_Isnil(_Pnode); _Rootnode = _Pnode)

	mov	eax, DWORD PTR __Rootnode$[ebp]
	mov	DWORD PTR __Pnode$25262[ebp], eax
	jmp	SHORT $LN3@Erase
$LN2@Erase:
	mov	ecx, DWORD PTR __Pnode$25262[ebp]
	mov	DWORD PTR __Rootnode$[ebp], ecx
$LN3@Erase:
	mov	edx, DWORD PTR __Pnode$25262[ebp]
	push	edx
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Isnil
	add	esp, 4
	movsx	eax, BYTE PTR [eax]
	test	eax, eax
	jne	SHORT $LN4@Erase

; 1074 : 			{	// free subtrees, then node
; 1075 : 			_Erase(_Right(_Pnode));

	mov	ecx, DWORD PTR __Pnode$25262[ebp]
	push	ecx
	call	?_Right@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Right
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Erase@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Erase

; 1076 : 			_Pnode = _Left(_Pnode);

	mov	eax, DWORD PTR __Pnode$25262[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$25262[ebp], ecx

; 1077 : 			this->_Alnod.destroy(_Rootnode);	// destroy, free erased node

	mov	edx, DWORD PTR __Rootnode$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1
	call	?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Node>::destroy

; 1078 : 			this->_Alnod.deallocate(_Rootnode, 1);

	push	1
	mov	eax, DWORD PTR __Rootnode$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1
	call	?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Node>::deallocate

; 1079 : 			}

	jmp	SHORT $LN2@Erase
$LN4@Erase:

; 1080 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Erase@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Erase
_TEXT	ENDS
PUBLIC	?_Buynode@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Buynode
; Function compile flags: /Odtp
;	COMDAT ?_Init@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Init@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEXXZ PROC ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Init, COMDAT
; _this$ = ecx

; 1083 : 		{	// create head/nil node and make tree empty

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1084 : 		_Myhead = _Buynode();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buynode@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Buynode
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 1085 : 		_Isnil(_Myhead) = true;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Isnil
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 1086 : 		_Root() = _Myhead;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Root
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], edx

; 1087 : 		_Lmost() = _Myhead, _Rmost() = _Myhead;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lmost@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Lmost
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rmost@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Rmost
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], edx

; 1088 : 		_Mysize = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0

; 1089 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Init@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Init
_TEXT	ENDS
PUBLIC	?_Buynode@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBVCZString@Value@Json@@V23@@2@D@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Buynode
PUBLIC	__TI3?AVlength_error@std@@
PUBLIC	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
PUBLIC	??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	?max_size@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::max_size
PUBLIC	??1length_error@std@@UAE@XZ			; std::length_error::~length_error
PUBLIC	__CTA3?AVlength_error@std@@
PUBLIC	__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
PUBLIC	??_R0?AVlength_error@std@@@8			; std::length_error `RTTI Type Descriptor'
PUBLIC	??0length_error@std@@QAE@ABV01@@Z		; std::length_error::length_error
;	COMDAT ??_R0?AVlength_error@std@@@8
_DATA	SEGMENT
??_R0?AVlength_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::length_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlength_error@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0length_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA3?AVlength_error@std@@
xdata$x	SEGMENT
__CTA3?AVlength_error@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVlength_error@std@@
xdata$x	SEGMENT
__TI3?AVlength_error@std@@ DD 00H
	DD	FLAT:??1length_error@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVlength_error@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@ DB 'map/set<T> too l'
	DB	'ong', 00H					; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Insert@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@ABU?$pair@$$CBVCZString@Value@Json@@V23@@2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Insert@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@ABU?$pair@$$CBVCZString@Value@Json@@V23@@2@@Z$0
__ehfuncinfo$?_Insert@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@ABU?$pair@$$CBVCZString@Value@Json@@V23@@2@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Insert@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@ABU?$pair@$$CBVCZString@Value@Json@@V23@@2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Insert@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@ABU?$pair@$$CBVCZString@Value@Json@@V23@@2@@Z
_TEXT	SEGMENT
_this$ = -92						; size = 4
$T32006 = -88						; size = 28
$T32005 = -60						; size = 40
__Pnode$25287 = -20					; size = 4
__Newnode$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Addleft$ = 12						; size = 1
__Wherenode$ = 16					; size = 4
__Val$ = 20						; size = 4
?_Insert@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@ABU?$pair@$$CBVCZString@Value@Json@@V23@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Insert, COMDAT
; _this$ = ecx

; 1093 : 		{	// add node with value next to _Wherenode, to left if _Addnode

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Insert@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@ABU?$pair@$$CBVCZString@Value@Json@@V23@@2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 80					; 00000050H
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1094 : 		if (max_size() - 1 <= _Mysize)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::max_size
	sub	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR [ecx+8]
	ja	SHORT $LN17@Insert

; 1095 : 			_THROW(length_error, "map/set<T> too long");

	push	OFFSET ??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T32006[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	edx, DWORD PTR $T32006[ebp]
	push	edx
	lea	ecx, DWORD PTR $T32005[ebp]
	call	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
	push	OFFSET __TI3?AVlength_error@std@@
	lea	eax, DWORD PTR $T32005[ebp]
	push	eax
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T32006[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN17@Insert:

; 1096 : 		_Nodeptr _Newnode = _Buynode(_Myhead, _Wherenode, _Myhead,
; 1097 : 			_Val, _Red);

	push	0
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buynode@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBVCZString@Value@Json@@V23@@2@D@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Buynode
	mov	DWORD PTR __Newnode$[ebp], eax

; 1098 : 
; 1099 : 		++_Mysize;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	add	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], edx

; 1100 : 		if (_Wherenode == _Myhead)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Wherenode$[ebp]
	cmp	edx, DWORD PTR [ecx+4]
	jne	SHORT $LN16@Insert

; 1101 : 			{	// first node in tree, just set head values
; 1102 : 			_Root() = _Newnode;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Root
	mov	ecx, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR [eax], ecx

; 1103 : 			_Lmost() = _Newnode, _Rmost() = _Newnode;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lmost@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Lmost
	mov	edx, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rmost@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Rmost
	mov	ecx, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR [eax], ecx
	jmp	SHORT $LN15@Insert
$LN16@Insert:

; 1104 : 			}
; 1105 : 		else if (_Addleft)

	movzx	edx, BYTE PTR __Addleft$[ebp]
	test	edx, edx
	je	SHORT $LN14@Insert

; 1106 : 			{	// add to left of _Wherenode
; 1107 : 			_Left(_Wherenode) = _Newnode;

	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR [eax], ecx

; 1108 : 			if (_Wherenode == _Lmost())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lmost@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Lmost
	mov	edx, DWORD PTR __Wherenode$[ebp]
	cmp	edx, DWORD PTR [eax]
	jne	SHORT $LN13@Insert

; 1109 : 				_Lmost() = _Newnode;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lmost@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Lmost
	mov	ecx, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR [eax], ecx
$LN13@Insert:

; 1110 : 			}
; 1111 : 		else

	jmp	SHORT $LN15@Insert
$LN14@Insert:

; 1112 : 			{	// add to right of _Wherenode
; 1113 : 			_Right(_Wherenode) = _Newnode;

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR [eax], ecx

; 1114 : 			if (_Wherenode == _Rmost())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rmost@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Rmost
	mov	edx, DWORD PTR __Wherenode$[ebp]
	cmp	edx, DWORD PTR [eax]
	jne	SHORT $LN15@Insert

; 1115 : 				_Rmost() = _Newnode;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rmost@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Rmost
	mov	ecx, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR [eax], ecx
$LN15@Insert:

; 1116 : 			}
; 1117 : 
; 1118 : 		for (_Nodeptr _Pnode = _Newnode; _Color(_Parent(_Pnode)) == _Red; )

	mov	edx, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR __Pnode$25287[ebp], edx
$LN10@Insert:
	mov	eax, DWORD PTR __Pnode$25287[ebp]
	push	eax
	call	?_Parent@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Color@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Color
	add	esp, 4
	movsx	edx, BYTE PTR [eax]
	test	edx, edx
	jne	$LN9@Insert

; 1119 : 			if (_Parent(_Pnode) == _Left(_Parent(_Parent(_Pnode))))

	mov	eax, DWORD PTR __Pnode$25287[ebp]
	push	eax
	call	?_Parent@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Parent
	add	esp, 4
	mov	esi, eax
	mov	ecx, DWORD PTR __Pnode$25287[ebp]
	push	ecx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Parent
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [esi]
	cmp	ecx, DWORD PTR [eax]
	jne	$LN8@Insert

; 1120 : 				{	// fixup red-red in left subtree
; 1121 : 				_Wherenode = _Right(_Parent(_Parent(_Pnode)));

	mov	edx, DWORD PTR __Pnode$25287[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Parent@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Right@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Right
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR __Wherenode$[ebp], edx

; 1122 : 				if (_Color(_Wherenode) == _Red)

	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	call	?_Color@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Color
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN7@Insert

; 1123 : 					{	// parent has two red children, blacken both
; 1124 : 					_Color(_Parent(_Pnode)) = _Black;

	mov	edx, DWORD PTR __Pnode$25287[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Color@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 1125 : 					_Color(_Wherenode) = _Black;

	mov	ecx, DWORD PTR __Wherenode$[ebp]
	push	ecx
	call	?_Color@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 1126 : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

	mov	edx, DWORD PTR __Pnode$25287[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Parent@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Color@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 0

; 1127 : 					_Pnode = _Parent(_Parent(_Pnode));

	mov	edx, DWORD PTR __Pnode$25287[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Parent@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$25287[ebp], ecx

; 1128 : 					}
; 1129 : 				else

	jmp	$LN6@Insert
$LN7@Insert:

; 1130 : 					{	// parent has red and black children
; 1131 : 					if (_Pnode == _Right(_Parent(_Pnode)))

	mov	edx, DWORD PTR __Pnode$25287[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR __Pnode$25287[ebp]
	cmp	ecx, DWORD PTR [eax]
	jne	SHORT $LN5@Insert

; 1132 : 						{	// rotate right child to left
; 1133 : 						_Pnode = _Parent(_Pnode);

	mov	edx, DWORD PTR __Pnode$25287[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$25287[ebp], eax

; 1134 : 						_Lrotate(_Pnode);

	mov	ecx, DWORD PTR __Pnode$25287[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Lrotate
$LN5@Insert:

; 1135 : 						}
; 1136 : 					_Color(_Parent(_Pnode)) = _Black;	// propagate red up

	mov	edx, DWORD PTR __Pnode$25287[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Color@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 1137 : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

	mov	ecx, DWORD PTR __Pnode$25287[ebp]
	push	ecx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Parent
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Color@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 0

; 1138 : 					_Rrotate(_Parent(_Parent(_Pnode)));

	mov	ecx, DWORD PTR __Pnode$25287[ebp]
	push	ecx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Parent
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Rrotate
$LN6@Insert:

; 1139 : 					}
; 1140 : 				}
; 1141 : 			else

	jmp	$LN4@Insert
$LN8@Insert:

; 1142 : 				{	// fixup red-red in right subtree
; 1143 : 				_Wherenode = _Left(_Parent(_Parent(_Pnode)));

	mov	ecx, DWORD PTR __Pnode$25287[ebp]
	push	ecx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Parent
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Wherenode$[ebp], ecx

; 1144 : 				if (_Color(_Wherenode) == _Red)

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Color@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Color
	add	esp, 4
	movsx	eax, BYTE PTR [eax]
	test	eax, eax
	jne	SHORT $LN3@Insert

; 1145 : 					{	// parent has two red children, blacken both
; 1146 : 					_Color(_Parent(_Pnode)) = _Black;

	mov	ecx, DWORD PTR __Pnode$25287[ebp]
	push	ecx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Parent
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	push	edx
	call	?_Color@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 1147 : 					_Color(_Wherenode) = _Black;

	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	call	?_Color@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 1148 : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

	mov	ecx, DWORD PTR __Pnode$25287[ebp]
	push	ecx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Parent
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Color@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 0

; 1149 : 					_Pnode = _Parent(_Parent(_Pnode));

	mov	ecx, DWORD PTR __Pnode$25287[ebp]
	push	ecx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Parent
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$25287[ebp], eax

; 1150 : 					}
; 1151 : 				else

	jmp	$LN4@Insert
$LN3@Insert:

; 1152 : 					{	// parent has red and black children
; 1153 : 					if (_Pnode == _Left(_Parent(_Pnode)))

	mov	ecx, DWORD PTR __Pnode$25287[ebp]
	push	ecx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Parent
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	push	edx
	call	?_Left@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR __Pnode$25287[ebp]
	cmp	ecx, DWORD PTR [eax]
	jne	SHORT $LN1@Insert

; 1154 : 						{	// rotate left child to right
; 1155 : 						_Pnode = _Parent(_Pnode);

	mov	edx, DWORD PTR __Pnode$25287[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$25287[ebp], eax

; 1156 : 						_Rrotate(_Pnode);

	mov	ecx, DWORD PTR __Pnode$25287[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Rrotate
$LN1@Insert:

; 1157 : 						}
; 1158 : 					_Color(_Parent(_Pnode)) = _Black;	// propagate red up

	mov	edx, DWORD PTR __Pnode$25287[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Color@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 1159 : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

	mov	ecx, DWORD PTR __Pnode$25287[ebp]
	push	ecx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Parent
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Color@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 0

; 1160 : 					_Lrotate(_Parent(_Parent(_Pnode)));

	mov	ecx, DWORD PTR __Pnode$25287[ebp]
	push	ecx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Parent
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Lrotate
$LN4@Insert:

; 1161 : 					}
; 1162 : 				}

	jmp	$LN10@Insert
$LN9@Insert:

; 1163 : 
; 1164 : 		_Color(_Root()) = _Black;	// root is always black

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Root
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Color@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 1165 : 		return (_TREE_ITERATOR(_Newnode));

	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR __Newnode$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PBV12@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::iterator::iterator
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN19@Insert:

; 1166 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Insert@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@ABU?$pair@$$CBVCZString@Value@Json@@V23@@2@@Z$0:
	lea	ecx, DWORD PTR $T32006[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?_Insert@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@ABU?$pair@$$CBVCZString@Value@Json@@V23@@2@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-88]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Insert@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@ABU?$pair@$$CBVCZString@Value@Json@@V23@@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@ABU?$pair@$$CBVCZString@Value@Json@@V23@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Insert
PUBLIC	??_7length_error@std@@6B@			; std::length_error::`vftable'
PUBLIC	??_R4length_error@std@@6B@			; std::length_error::`RTTI Complete Object Locator'
PUBLIC	??_R3length_error@std@@8			; std::length_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2length_error@std@@8			; std::length_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@length_error@std@@8		; std::length_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_Elength_error@std@@UAEPAXI@Z:PROC		; std::length_error::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@length_error@std@@8
; File c:\program files (x86)\microsoft visual studio 8\vc\include\stdexcept
rdata$r	SEGMENT
??_R1A@?0A@EA@length_error@std@@8 DD FLAT:??_R0?AVlength_error@std@@@8 ; std::length_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2length_error@std@@8
rdata$r	SEGMENT
??_R2length_error@std@@8 DD FLAT:??_R1A@?0A@EA@length_error@std@@8 ; std::length_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@logic_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3length_error@std@@8
rdata$r	SEGMENT
??_R3length_error@std@@8 DD 00H				; std::length_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R4length_error@std@@6B@
rdata$r	SEGMENT
??_R4length_error@std@@6B@ DD 00H			; std::length_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	FLAT:??_R3length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_7length_error@std@@6B@
CONST	SEGMENT
??_7length_error@std@@6B@ DD FLAT:??_R4length_error@std@@6B@ ; std::length_error::`vftable'
	DD	FLAT:??_Elength_error@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Message$ = 8						; size = 4
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::length_error::length_error, COMDAT
; _this$ = ecx

; 106  : 		{	// construct from message string

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Message$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7length_error@std@@6B@

; 107  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::length_error::length_error
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1length_error@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1length_error@std@@UAE@XZ PROC			; std::length_error::~length_error, COMDAT
; _this$ = ecx

; 110  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7length_error@std@@6B@

; 111  : 		}

	mov	ecx, DWORD PTR _this$[ebp]
	call	??1logic_error@std@@UAE@XZ		; std::logic_error::~logic_error
	mov	esp, ebp
	pop	ebp
	ret	0
??1length_error@std@@UAE@XZ ENDP			; std::length_error::~length_error
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_Glength_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Glength_error@std@@UAEPAXI@Z PROC			; std::length_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1length_error@std@@UAE@XZ		; std::length_error::~length_error
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@8
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@8:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Glength_error@std@@UAEPAXI@Z ENDP			; std::length_error::`scalar deleting destructor'
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 8\vc\include\xtree
_TEXT	ENDS
;	COMDAT ?_Lbound@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@ABVCZString@Value@Json@@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Pnode$ = -8						; size = 4
__Wherenode$ = -4					; size = 4
__Keyval$ = 8						; size = 4
?_Lbound@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@ABVCZString@Value@Json@@@Z PROC ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Lbound, COMDAT
; _this$ = ecx

; 1169 : 		{	// find leftmost node not less than _Keyval

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1170 : 		_Nodeptr _Pnode = _Root();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Root
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], eax

; 1171 : 		_Nodeptr _Wherenode = _Myhead;	// end() if search fails

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR __Wherenode$[ebp], edx
$LN4@Lbound:

; 1172 : 
; 1173 : 		while (!_Isnil(_Pnode))

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Isnil
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN3@Lbound

; 1174 : 			if (_DEBUG_LT_PRED(this->comp, _Key(_Pnode), _Keyval))

	mov	edx, DWORD PTR __Keyval$[ebp]
	push	edx
	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Key@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAABVCZString@Value@Json@@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Key
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??R?$less@VCZString@Value@Json@@@std@@QBE_NABVCZString@Value@Json@@0@Z ; std::less<Json::Value::CZString>::operator()
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@Lbound

; 1175 : 				_Pnode = _Right(_Pnode);	// descend right subtree

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Right
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], eax

; 1176 : 			else

	jmp	SHORT $LN1@Lbound
$LN2@Lbound:

; 1177 : 				{	// _Pnode not less than _Keyval, remember it
; 1178 : 				_Wherenode = _Pnode;

	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR __Wherenode$[ebp], ecx

; 1179 : 				_Pnode = _Left(_Pnode);	// descend left subtree

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Left@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Left
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], eax
$LN1@Lbound:

; 1180 : 				}

	jmp	SHORT $LN4@Lbound
$LN3@Lbound:

; 1181 : 
; 1182 : 		return (_Wherenode);	// return best remembered candidate

	mov	eax, DWORD PTR __Wherenode$[ebp]

; 1183 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Lbound@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@ABVCZString@Value@Json@@@Z ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Lbound
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Lmost@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Lmost@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Lmost, COMDAT
; _this$ = ecx

; 1186 : 		{	// return leftmost node in nonmutable tree

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1187 : 		return (_Left(_Myhead));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?_Left@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Left
	add	esp, 4

; 1188 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Lmost@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Lmost
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Lrotate@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Pnode$ = -4						; size = 4
__Wherenode$ = 8					; size = 4
?_Lrotate@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Lrotate, COMDAT
; _this$ = ecx

; 1191 : 		{	// promote right node to root of subtree

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 1192 : 		_Nodeptr _Pnode = _Right(_Wherenode);

	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], ecx

; 1193 : 		_Right(_Wherenode) = _Left(_Pnode);

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Left@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Left
	add	esp, 4
	mov	esi, eax
	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [eax], ecx

; 1194 : 
; 1195 : 		if (!_Isnil(_Left(_Pnode)))

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Left@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Left
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Isnil
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN5@Lrotate

; 1196 : 			_Parent(_Left(_Pnode)) = _Wherenode;

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Left@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Left
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Parent@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	mov	DWORD PTR [eax], ecx
$LN5@Lrotate:

; 1197 : 		_Parent(_Pnode) = _Parent(_Wherenode);

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Parent
	add	esp, 4
	mov	esi, eax
	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Parent@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [eax], ecx

; 1198 : 
; 1199 : 		if (_Wherenode == _Root())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Root
	mov	edx, DWORD PTR __Wherenode$[ebp]
	cmp	edx, DWORD PTR [eax]
	jne	SHORT $LN4@Lrotate

; 1200 : 			_Root() = _Pnode;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Root
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx
	jmp	SHORT $LN3@Lrotate
$LN4@Lrotate:

; 1201 : 		else if (_Wherenode == _Left(_Parent(_Wherenode)))

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jne	SHORT $LN2@Lrotate

; 1202 : 			_Left(_Parent(_Wherenode)) = _Pnode;

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx

; 1203 : 		else

	jmp	SHORT $LN3@Lrotate
$LN2@Lrotate:

; 1204 : 			_Right(_Parent(_Wherenode)) = _Pnode;

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx
$LN3@Lrotate:

; 1205 : 
; 1206 : 		_Left(_Pnode) = _Wherenode;

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Left@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	mov	DWORD PTR [eax], ecx

; 1207 : 		_Parent(_Wherenode) = _Pnode;

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx

; 1208 : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?_Lrotate@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Lrotate
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Max@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Max@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Max, COMDAT

; 1211 : 		{	// return rightmost node in subtree at _Pnode

	push	ebp
	mov	ebp, esp
$LN2@Max:

; 1212 : 		while (!_Isnil(_Right(_Pnode)))

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Isnil
	add	esp, 4
	movsx	edx, BYTE PTR [eax]
	test	edx, edx
	jne	SHORT $LN1@Max

; 1213 : 			_Pnode = _Right(_Pnode);

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], ecx
	jmp	SHORT $LN2@Max
$LN1@Max:

; 1214 : 		return (_Pnode);

	mov	eax, DWORD PTR __Pnode$[ebp]

; 1215 : 		}

	pop	ebp
	ret	0
?_Max@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Max
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Min@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Min@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Min, COMDAT

; 1218 : 		{	// return leftmost node in subtree at _Pnode

	push	ebp
	mov	ebp, esp
$LN2@Min:

; 1219 : 		while (!_Isnil(_Left(_Pnode)))

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Isnil
	add	esp, 4
	movsx	edx, BYTE PTR [eax]
	test	edx, edx
	jne	SHORT $LN1@Min

; 1220 : 			_Pnode = _Left(_Pnode);

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], ecx
	jmp	SHORT $LN2@Min
$LN1@Min:

; 1221 : 		return (_Pnode);

	mov	eax, DWORD PTR __Pnode$[ebp]

; 1222 : 		}

	pop	ebp
	ret	0
?_Min@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Min
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Rmost@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Rmost@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Rmost, COMDAT
; _this$ = ecx

; 1225 : 		{	// return rightmost node in nonmutable tree

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1226 : 		return (_Right(_Myhead));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?_Right@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Right
	add	esp, 4

; 1227 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Rmost@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Rmost
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Root@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Root, COMDAT
; _this$ = ecx

; 1230 : 		{	// return root of nonmutable tree

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1231 : 		return (_Parent(_Myhead));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Parent
	add	esp, 4

; 1232 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Root@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Root
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Rrotate@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Pnode$ = -4						; size = 4
__Wherenode$ = 8					; size = 4
?_Rrotate@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Rrotate, COMDAT
; _this$ = ecx

; 1235 : 		{	// promote left node to root of subtree

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 1236 : 		_Nodeptr _Pnode = _Left(_Wherenode);

	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], ecx

; 1237 : 		_Left(_Wherenode) = _Right(_Pnode);

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Right
	add	esp, 4
	mov	esi, eax
	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [eax], ecx

; 1238 : 
; 1239 : 		if (!_Isnil(_Right(_Pnode)))

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Right
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Isnil
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN5@Rrotate

; 1240 : 			_Parent(_Right(_Pnode)) = _Wherenode;

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Right
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Parent@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	mov	DWORD PTR [eax], ecx
$LN5@Rrotate:

; 1241 : 		_Parent(_Pnode) = _Parent(_Wherenode);

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Parent
	add	esp, 4
	mov	esi, eax
	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Parent@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [eax], ecx

; 1242 : 
; 1243 : 		if (_Wherenode == _Root())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Root
	mov	edx, DWORD PTR __Wherenode$[ebp]
	cmp	edx, DWORD PTR [eax]
	jne	SHORT $LN4@Rrotate

; 1244 : 			_Root() = _Pnode;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Root
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx
	jmp	SHORT $LN3@Rrotate
$LN4@Rrotate:

; 1245 : 		else if (_Wherenode == _Right(_Parent(_Wherenode)))

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jne	SHORT $LN2@Rrotate

; 1246 : 			_Right(_Parent(_Wherenode)) = _Pnode;

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx

; 1247 : 		else

	jmp	SHORT $LN3@Rrotate
$LN2@Rrotate:

; 1248 : 			_Left(_Parent(_Wherenode)) = _Pnode;

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx
$LN3@Rrotate:

; 1249 : 
; 1250 : 		_Right(_Pnode) = _Wherenode;

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	mov	DWORD PTR [eax], ecx

; 1251 : 		_Parent(_Wherenode) = _Pnode;

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx

; 1252 : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?_Rrotate@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Rrotate
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Node *>::destroy
; Function compile flags: /Odtp
;	COMDAT ?_Tidy@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -28						; size = 4
$T32041 = -24						; size = 8
$T32040 = -16						; size = 8
$T32039 = -8						; size = 8
?_Tidy@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEXXZ PROC ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Tidy, COMDAT
; _this$ = ecx

; 1326 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 1327 : 		erase(begin(), end());

	lea	eax, DWORD PTR $T32039[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::end
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	lea	eax, DWORD PTR $T32040[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::begin
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	lea	eax, DWORD PTR $T32041[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@V312@0@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::erase

; 1328 : 		this->_Alptr.destroy(&_Left(_Myhead));

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	?_Left@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Left
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2
	call	?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Node *>::destroy

; 1329 : 		this->_Alptr.destroy(&_Parent(_Myhead));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Parent
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2
	call	?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Node *>::destroy

; 1330 : 		this->_Alptr.destroy(&_Right(_Myhead));

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Right
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2
	call	?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Node *>::destroy

; 1331 : 		this->_Alnod.deallocate(_Myhead, 1);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1
	call	?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Node>::deallocate

; 1332 : 		_Myhead = 0, _Mysize = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 0

; 1333 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Tidy
_TEXT	ENDS
PUBLIC	??0?$_Tree_ptr@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAE@ABU?$less@VCZString@Value@Json@@@1@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@1@@Z ; std::_Tree_ptr<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Tree_ptr<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >
; Function compile flags: /Odtp
;	COMDAT ??0?$_Tree_val@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAE@ABU?$less@VCZString@Value@Json@@@1@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 1
??0?$_Tree_val@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAE@ABU?$less@VCZString@Value@Json@@@1@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@1@@Z PROC ; std::_Tree_val<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Tree_val<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >, COMDAT
; _this$ = ecx

; 102  : 		{	// construct base, and allocator from _Al

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	call	??0?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >::allocator<std::pair<Json::Value::CZString const ,Json::Value> >
	mov	ecx, DWORD PTR __Parg$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Tree_ptr@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAE@ABU?$less@VCZString@Value@Json@@@1@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@1@@Z ; std::_Tree_ptr<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Tree_ptr<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >
	lea	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 3
	call	??0?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >::allocator<std::pair<Json::Value::CZString const ,Json::Value> >

; 103  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Tree_val@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAE@ABU?$less@VCZString@Value@Json@@@1@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@1@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Tree_val<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 8\vc\include\map
_TEXT	ENDS
;	COMDAT ?_Kfn@?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@SAABVCZString@Value@Json@@ABU?$pair@$$CBVCZString@Value@Json@@V23@@2@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?_Kfn@?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@SAABVCZString@Value@Json@@ABU?$pair@$$CBVCZString@Value@Json@@V23@@2@@Z PROC ; std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0>::_Kfn, COMDAT

; 68   : 		{	// extract key from element value

	push	ebp
	mov	ebp, esp

; 69   : 		return (_Val.first);

	mov	eax, DWORD PTR __Val$[ebp]

; 70   : 		}

	pop	ebp
	ret	0
?_Kfn@?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@SAABVCZString@Value@Json@@ABU?$pair@$$CBVCZString@Value@Json@@V23@@2@@Z ENDP ; std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0>::_Kfn
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 8\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@QAE@XZ PROC ; std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >::allocator<std::pair<Json::Value::CZString const ,Json::Value> >, COMDAT
; _this$ = ecx

; 120  : 	allocator() _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 121  : 		{	// construct default allocator (do nothing)
; 122  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@QAE@XZ ENDP ; std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >::allocator<std::pair<Json::Value::CZString const ,Json::Value> >
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 8\vc\include\functional
_TEXT	ENDS
;	COMDAT ??R?$less@VCZString@Value@Json@@@std@@QBE_NABVCZString@Value@Json@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??R?$less@VCZString@Value@Json@@@std@@QBE_NABVCZString@Value@Json@@0@Z PROC ; std::less<Json::Value::CZString>::operator(), COMDAT
; _this$ = ecx

; 142  : 		{	// apply operator< to operands

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 143  : 		return (_Left < _Right);

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Left$[ebp]
	call	??MCZString@Value@Json@@QBE_NABV012@@Z	; Json::Value::CZString::operator<

; 144  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??R?$less@VCZString@Value@Json@@@std@@QBE_NABVCZString@Value@Json@@0@Z ENDP ; std::less<Json::Value::CZString>::operator()
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 8\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@I@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Node>::deallocate, COMDAT
; _this$ = ecx

; 140  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 141  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 142  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@I@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Node>::deallocate
_TEXT	ENDS
PUBLIC	??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@@Z ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Node>
; Function compile flags: /Odtp
;	COMDAT ?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Node>::destroy, COMDAT
; _this$ = ecx

; 160  : 		{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 161  : 		_Destroy(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@@Z ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Node>
	add	esp, 4

; 162  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Node>::destroy
_TEXT	ENDS
PUBLIC	??0const_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PBV12@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator::const_iterator
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 8\vc\include\xtree
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PBV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PBV12@@Z PROC ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::iterator::iterator, COMDAT
; _this$ = ecx

; 437  : 			{	// construct with node pointer _Pnode

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Plist$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0const_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PBV12@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator::const_iterator

; 438  : 			}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PBV12@@Z ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::iterator::iterator
_TEXT	ENDS
PUBLIC	??0?$_Bidit@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@HPBU12@ABU12@@std@@QAE@XZ ; std::_Bidit<std::pair<Json::Value::CZString const ,Json::Value>,int,std::pair<Json::Value::CZString const ,Json::Value> const *,std::pair<Json::Value::CZString const ,Json::Value> const &>::_Bidit<std::pair<Json::Value::CZString const ,Json::Value>,int,std::pair<Json::Value::CZString const ,Json::Value> const *,std::pair<Json::Value::CZString const ,Json::Value> const &>
; Function compile flags: /Odtp
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0const_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator::const_iterator, COMDAT
; _this$ = ecx

; 207  : 			{	// construct with null node pointer

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Bidit@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@HPBU12@ABU12@@std@@QAE@XZ
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 208  : 			}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0const_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator::const_iterator
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Pnode$25375 = -4					; size = 4
?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator::_Dec, COMDAT
; _this$ = ecx

; 309  : 			{	// move to node with next smaller value

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 310  : 
; 311  :  #if _HAS_ITERATOR_DEBUGGING
; 312  : 			if (this->_Mycont == 0)
; 313  : 				{
; 314  : 				_DEBUG_ERROR("map/set iterator not decrementable");
; 315  : 				_SCL_SECURE_INVALID_ARGUMENT;
; 316  : 				}
; 317  :  #else
; 318  : 			_SCL_SECURE_VALIDATE(this->_Mycont != NULL);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN10@Dec
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN10@Dec:

; 319  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 320  : 
; 321  : 			if (_Isnil(_Ptr))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Isnil
	add	esp, 4
	movsx	eax, BYTE PTR [eax]
	test	eax, eax
	je	SHORT $LN9@Dec

; 322  : 			{
; 323  : 				_Ptr = _Right(_Ptr);	// end() ==> rightmost

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx+4], edx

; 324  :    				if (_Isnil(_Ptr))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Isnil
	add	esp, 4
	movsx	edx, BYTE PTR [eax]
	test	edx, edx
	je	SHORT $LN8@Dec

; 325  : #if _HAS_ITERATOR_DEBUGGING
; 326  : 				{
; 327  : 					_DEBUG_ERROR("map/set iterator not decrementable");
; 328  : 					_SCL_SECURE_OUT_OF_RANGE;
; 329  : 				}
; 330  : #elif _SECURE_SCL
; 331  : 				{
; 332  :     				_SCL_SECURE_OUT_OF_RANGE;

	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN8@Dec:

; 333  : 				}
; 334  : #else
; 335  : 				return;	// begin() shouldn't be incremented, don't move
; 336  : #endif
; 337  : 			}

	jmp	$LN11@Dec
$LN9@Dec:

; 338  : 			else if (!_Isnil(_Left(_Ptr)))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?_Left@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Left
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	push	edx
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Isnil
	add	esp, 4
	movsx	eax, BYTE PTR [eax]
	test	eax, eax
	jne	SHORT $LN4@Dec

; 339  : 				_Ptr = _Max(_Left(_Ptr));	// ==> largest of left subtree

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	?_Left@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Left
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Max@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Max
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 340  : 			else

	jmp	SHORT $LN11@Dec
$LN4@Dec:

; 341  : 				{	// climb looking for left subtree
; 342  : 				_Nodeptr _Pnode;
; 343  : 				while (!_Isnil(_Pnode = _Parent(_Ptr))
; 344  : 					&& _Ptr == _Left(_Pnode))

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?_Parent@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$25375[ebp], ecx
	mov	edx, DWORD PTR __Pnode$25375[ebp]
	push	edx
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Isnil
	add	esp, 4
	movsx	eax, BYTE PTR [eax]
	test	eax, eax
	jne	SHORT $LN3@Dec
	mov	ecx, DWORD PTR __Pnode$25375[ebp]
	push	ecx
	call	?_Left@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Left
	add	esp, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	cmp	ecx, DWORD PTR [eax]
	jne	SHORT $LN3@Dec

; 345  : 					_Ptr = _Pnode;	// ==> parent while left subtree

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Pnode$25375[ebp]
	mov	DWORD PTR [edx+4], eax
	jmp	SHORT $LN4@Dec
$LN3@Dec:

; 346  : 				if (_Isnil(_Ptr))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Isnil
	add	esp, 4
	movsx	eax, BYTE PTR [eax]
	test	eax, eax
	je	SHORT $LN2@Dec

; 347  :  #if _HAS_ITERATOR_DEBUGGING
; 348  :  					{
; 349  : 					_DEBUG_ERROR("map/set iterator not decrementable");
; 350  : 					_SCL_SECURE_OUT_OF_RANGE;
; 351  : 					}
; 352  :  #elif _SECURE_SCL
; 353  : 					{
; 354  : 					_SCL_SECURE_OUT_OF_RANGE;

	call	DWORD PTR __imp___invalid_parameter_noinfo

; 355  : 					}
; 356  :  #else
; 357  : 					return;	// begin() shouldn't be incremented, don't move
; 358  :  #endif
; 359  : 				else

	jmp	SHORT $LN11@Dec
$LN2@Dec:

; 360  : 					_Ptr = _Pnode;	// ==> parent if not head

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Pnode$25375[ebp]
	mov	DWORD PTR [ecx+4], edx
$LN11@Dec:

; 361  : 				}
; 362  : 			}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator::_Dec
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Pnode$25391 = -4					; size = 4
?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator::_Inc, COMDAT
; _this$ = ecx

; 365  : 			{	// move to node with next larger value

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 366  : 
; 367  :  #if _HAS_ITERATOR_DEBUGGING
; 368  : 			if (this->_Mycont == 0 || _Isnil(_Ptr))
; 369  : 				{
; 370  : 				_DEBUG_ERROR("map/set iterator not incrementable");
; 371  : 				_SCL_SECURE_OUT_OF_RANGE;
; 372  : 				}
; 373  :  #else
; 374  : 			_SCL_SECURE_VALIDATE(this->_Mycont != NULL);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN7@Inc
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN7@Inc:

; 375  : 			if (_Isnil(_Ptr))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Isnil
	add	esp, 4
	movsx	eax, BYTE PTR [eax]
	test	eax, eax
	je	SHORT $LN6@Inc

; 376  : 				{
; 377  : 				_SCL_SECURE_OUT_OF_RANGE;

	call	DWORD PTR __imp___invalid_parameter_noinfo
	jmp	$LN8@Inc
$LN6@Inc:

; 378  : 				// end() shouldn't be incremented, don't move if _SCL_SECURE is not turned on
; 379  : 				}
; 380  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 381  : 
; 382  : 			else if (!_Isnil(_Right(_Ptr)))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Right
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Isnil
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN2@Inc

; 383  : 				_Ptr = _Min(_Right(_Ptr));	// ==> smallest of right subtree

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Min@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Min
	add	esp, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], eax

; 384  : 			else

	jmp	SHORT $LN8@Inc
$LN2@Inc:

; 385  : 				{	// climb looking for right subtree
; 386  : 				_Nodeptr _Pnode;
; 387  : 				while (!_Isnil(_Pnode = _Parent(_Ptr))
; 388  : 					&& _Ptr == _Right(_Pnode))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Parent
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$25391[ebp], edx
	mov	eax, DWORD PTR __Pnode$25391[ebp]
	push	eax
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Isnil
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN1@Inc
	mov	edx, DWORD PTR __Pnode$25391[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR [eax]
	jne	SHORT $LN1@Inc

; 389  : 					_Ptr = _Pnode;	// ==> parent while right subtree

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Pnode$25391[ebp]
	mov	DWORD PTR [eax+4], ecx
	jmp	SHORT $LN2@Inc
$LN1@Inc:

; 390  : 				_Ptr = _Pnode;	// ==> parent (head if end())

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Pnode$25391[ebp]
	mov	DWORD PTR [edx+4], eax
$LN8@Inc:

; 391  : 				}
; 392  : 			}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator::_Inc
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@3@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@3@XZ PROC ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator::_Mynode, COMDAT
; _this$ = ecx

; 395  : 			{	// return node pointer

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 396  : 			return (_Ptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 397  : 			}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@3@XZ ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator::_Mynode
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 8\vc\include\vector
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ
_TEXT	SEGMENT
tv70 = -8						; size = 4
_this$ = -4						; size = 4
?capacity@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::capacity, COMDAT
; _this$ = ecx

; 621  : 		{	// return current length of allocated storage

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 622  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN3@capacity@3
	mov	DWORD PTR tv70[ebp], 0
	jmp	SHORT $LN4@capacity@3
$LN3@capacity@3:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx+4]
	cdq
	mov	ecx, 28					; 0000001cH
	idiv	ecx
	mov	DWORD PTR tv70[ebp], eax
$LN4@capacity@3:
	mov	eax, DWORD PTR tv70[ebp]

; 623  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?capacity@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::capacity
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PBU_Container_base@1@@Z ; std::_Vector_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Vector_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
; Function compile flags: /Odtp
;	COMDAT ?begin@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@XZ PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::begin, COMDAT
; _this$ = ecx

; 627  : 		{	// return iterator for beginning of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 628  : 		return (iterator(_Myfirst, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PBU_Container_base@1@@Z ; std::_Vector_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Vector_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 629  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@XZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::begin
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PBU_Container_base@1@@Z ; std::_Vector_const_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Vector_const_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
; Function compile flags: /Odtp
;	COMDAT ?begin@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBE?AV?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBE?AV?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@XZ PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::begin, COMDAT
; _this$ = ecx

; 632  : 		{	// return iterator for beginning of nonmutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 633  : 		return (const_iterator(_Myfirst, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PBU_Container_base@1@@Z ; std::_Vector_const_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Vector_const_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 634  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBE?AV?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@XZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::begin
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?end@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@XZ PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::end, COMDAT
; _this$ = ecx

; 637  : 		{	// return iterator for end of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 638  : 		return (iterator(_Mylast, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PBU_Container_base@1@@Z ; std::_Vector_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Vector_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 639  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@XZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::end
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?end@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBE?AV?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBE?AV?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@XZ PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::end, COMDAT
; _this$ = ecx

; 642  : 		{	// return iterator for end of nonmutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 643  : 		return (const_iterator(_Mylast, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PBU_Container_base@1@@Z ; std::_Vector_const_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Vector_const_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 644  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBE?AV?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@XZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::end
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?size@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ
_TEXT	SEGMENT
tv70 = -8						; size = 4
_this$ = -4						; size = 4
?size@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::size, COMDAT
; _this$ = ecx

; 702  : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 703  : 		return (_Myfirst == 0 ? 0 : _Mylast - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN3@size@4
	mov	DWORD PTR tv70[ebp], 0
	jmp	SHORT $LN4@size@4
$LN3@size@4:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	cdq
	mov	ecx, 28					; 0000001cH
	idiv	ecx
	mov	DWORD PTR tv70[ebp], eax
$LN4@size@4:
	mov	eax, DWORD PTR tv70[ebp]

; 704  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::size
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QBEIXZ ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::max_size
; Function compile flags: /Odtp
;	COMDAT ?max_size@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::max_size, COMDAT
; _this$ = ecx

; 707  : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 708  : 		return (this->_Alval.max_size());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QBEIXZ ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::max_size

; 709  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::max_size
_TEXT	ENDS
PUBLIC	??H?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::operator+
PUBLIC	?_Insert_n@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXV?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@IABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Insert_n
PUBLIC	??G?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEHABV?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@1@@Z ; std::_Vector_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::operator-
; Function compile flags: /Odtp
;	COMDAT ?insert@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V32@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
_TEXT	SEGMENT
tv73 = -28						; size = 4
_this$ = -24						; size = 4
$T32088 = -20						; size = 8
$T32085 = -12						; size = 8
__Off$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 8
__Val$ = 20						; size = 4
?insert@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V32@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::insert, COMDAT
; _this$ = ecx

; 852  : 		{	// insert _Val at _Where

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 853  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::size
	test	eax, eax
	jne	SHORT $LN3@insert@5
	mov	DWORD PTR tv73[ebp], 0
	jmp	SHORT $LN4@insert@5
$LN3@insert@5:
	lea	eax, DWORD PTR $T32085[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::begin
	push	eax
	lea	ecx, DWORD PTR __Where$[ebp]
	call	??G?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEHABV?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@1@@Z ; std::_Vector_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::operator-
	mov	DWORD PTR tv73[ebp], eax
$LN4@insert@5:
	mov	ecx, DWORD PTR tv73[ebp]
	mov	DWORD PTR __Off$[ebp], ecx

; 854  : 		_Insert_n(_Where, (size_type)1, _Val);

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	push	1
	mov	eax, DWORD PTR __Where$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert_n@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXV?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@IABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Insert_n

; 855  : 		return (begin() + _Off);

	mov	edx, DWORD PTR __Off$[ebp]
	push	edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T32088[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::begin
	mov	ecx, eax
	call	??H?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::operator+
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 856  : 		}

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?insert@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@V32@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::insert
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Buy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAE_NI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Capacity$ = 8						; size = 4
?_Buy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAE_NI@Z PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Buy, COMDAT
; _this$ = ecx

; 1066 : 		{	// allocate array with _Capacity elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1067 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], 0

; 1068 : 		if (_Capacity == 0)

	cmp	DWORD PTR __Capacity$[ebp], 0
	jne	SHORT $LN4@Buy@3

; 1069 : 			return (false);

	xor	al, al
	jmp	SHORT $LN5@Buy@3
	jmp	SHORT $LN3@Buy@3
$LN4@Buy@3:

; 1070 : 		else if (max_size() < _Capacity)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::max_size
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN2@Buy@3

; 1071 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@KAXXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Xlen

; 1072 : 		else

	jmp	SHORT $LN3@Buy@3
$LN2@Buy@3:

; 1073 : 			{	// nonempty array, allocate storage
; 1074 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	mov	eax, DWORD PTR __Capacity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?allocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::allocate
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 1075 : 			_Mylast = _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+8], ecx

; 1076 : 			_Myend = _Myfirst + _Capacity;

	mov	edx, DWORD PTR __Capacity$[ebp]
	imul	edx, 28					; 0000001cH
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], edx
$LN3@Buy@3:

; 1077 : 			}
; 1078 : 		return (true);

	mov	al, 1
$LN5@Buy@3:

; 1079 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Buy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAE_NI@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Buy
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Destroy_range<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
; Function compile flags: /Odtp
;	COMDAT ?_Destroy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Destroy, COMDAT
; _this$ = ecx

; 1082 : 		{	// destroy [_First, _Last) using allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1083 : 		_Destroy_range(_First, _Last, this->_Alval);

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Destroy_range<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
	add	esp, 12					; 0000000cH

; 1084 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Destroy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Destroy
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Tidy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXXZ PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Tidy, COMDAT
; _this$ = ecx

; 1087 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1088 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN1@Tidy@3

; 1089 : 			{	// something to free, destroy and deallocate it
; 1090 : 
; 1091 :  #if _HAS_ITERATOR_DEBUGGING
; 1092 : 			this->_Orphan_all();
; 1093 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1094 : 
; 1095 : 			_Destroy(_Myfirst, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Destroy

; 1096 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	sub	ecx, DWORD PTR [eax+4]
	mov	eax, ecx
	cdq
	mov	ecx, 28					; 0000001cH
	idiv	ecx
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?deallocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::deallocate
$LN1@Tidy@3:

; 1097 : 			}
; 1098 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0

; 1099 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXXZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Tidy
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_fill_n@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IABV12@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z ; stdext::unchecked_uninitialized_fill_n<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
; Function compile flags: /Odtp
;	COMDAT ?_Ufill@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@PAV32@IABV32@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Ufill@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@PAV32@IABV32@@Z PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Ufill, COMDAT
; _this$ = ecx

; 1207 : 		{	// copy initializing _Count * _Val, using allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1208 : 		_STDEXT unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??$unchecked_uninitialized_fill_n@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IABV12@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z ; stdext::unchecked_uninitialized_fill_n<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
	add	esp, 16					; 00000010H

; 1209 : 		return (_Ptr + _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	imul	eax, 28					; 0000001cH
	add	eax, DWORD PTR __Ptr$[ebp]

; 1210 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?_Ufill@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@PAV32@IABV32@@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Ufill
_TEXT	ENDS
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@KAXXZ$0
__ehfuncinfo$?_Xlen@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@KAXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@KAXXZ
_TEXT	SEGMENT
$T32100 = -80						; size = 28
$T32099 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@KAXXZ PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Xlen, COMDAT

; 1213 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Xlen@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1214 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T32100[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR $T32100[ebp]
	push	eax
	lea	ecx, DWORD PTR $T32099[ebp]
	call	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T32099[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T32100[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@Xlen:

; 1215 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T32100[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?_Xlen@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@KAXXZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Xlen
; Function compile flags: /Odtp
;	COMDAT ??0?$_Vector_val@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAE@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Al$ = 8						; size = 1
??0?$_Vector_val@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAE@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z PROC ; std::_Vector_val<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Vector_val<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT
; _this$ = ecx

; 412  : 		{	// construct allocator from _Al

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >

; 413  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_Vector_val@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAE@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z ENDP ; std::_Vector_val<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Vector_val<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 8\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@XZ PROC ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 120  : 	allocator() _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 121  : 		{	// construct default allocator (do nothing)
; 122  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@XZ ENDP ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@ABV01@@Z PROC ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 124  : 	allocator(const allocator<_Ty>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 125  : 		{	// construct by copying (do nothing)
; 126  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z PROC ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::deallocate, COMDAT
; _this$ = ecx

; 140  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 141  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 142  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z ENDP ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::deallocate
_TEXT	ENDS
PUBLIC	??$_Allocate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IPAV10@@Z ; std::_Allocate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
; Function compile flags: /Odtp
;	COMDAT ?allocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z PROC ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::allocate, COMDAT
; _this$ = ecx

; 145  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 146  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IPAV10@@Z ; std::_Allocate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
	add	esp, 8

; 147  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z ENDP ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::allocate
_TEXT	ENDS
PUBLIC	??0?$_Ranit@PBVPathArgument@Json@@HPBQBV12@ABQBV12@@std@@QAE@XZ ; std::_Ranit<Json::PathArgument const *,int,Json::PathArgument const * const *,Json::PathArgument const * const &>::_Ranit<Json::PathArgument const *,int,Json::PathArgument const * const *,Json::PathArgument const * const &>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 8\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QAE@PAPBVPathArgument@Json@@PBU_Container_base@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QAE@PAPBVPathArgument@Json@@PBU_Container_base@1@@Z PROC ; std::_Vector_const_iterator<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::_Vector_const_iterator<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >, COMDAT
; _this$ = ecx

; 77   : 	_Vector_const_iterator(_Tptr _Ptr, const _Container_base *_Pvector)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Ranit@PBVPathArgument@Json@@HPBQBV12@ABQBV12@@std@@QAE@XZ

; 78   : 		{	// construct with pointer _Ptr
; 79   : 		_SCL_SECURE_VALIDATE(_Pvector != NULL && ((_Myvec *)_Pvector)->_Myfirst <= _Ptr && _Ptr <= ((_Myvec *)_Pvector)->_Mylast);

	cmp	DWORD PTR __Pvector$[ebp], 0
	je	SHORT $LN1@Vector_con
	mov	eax, DWORD PTR __Pvector$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, DWORD PTR __Ptr$[ebp]
	ja	SHORT $LN1@Vector_con
	mov	edx, DWORD PTR __Pvector$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	cmp	eax, DWORD PTR [edx+8]
	jbe	SHORT $LN2@Vector_con
$LN1@Vector_con:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@Vector_con:

; 80   : 		this->_Mycont = _Pvector;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Pvector$[ebp]
	mov	DWORD PTR [ecx], edx

; 81   : 		_Myptr = _Ptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 82   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_const_iterator@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QAE@PAPBVPathArgument@Json@@PBU_Container_base@1@@Z ENDP ; std::_Vector_const_iterator<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::_Vector_const_iterator<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >
_TEXT	ENDS
PUBLIC	??0?$_Ranit@VPathArgument@Json@@HPBV12@ABV12@@std@@QAE@XZ ; std::_Ranit<Json::PathArgument,int,Json::PathArgument const *,Json::PathArgument const &>::_Ranit<Json::PathArgument,int,Json::PathArgument const *,Json::PathArgument const &>
; Function compile flags: /Odtp
;	COMDAT ??0?$_Vector_const_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAE@PAVPathArgument@Json@@PBU_Container_base@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAE@PAVPathArgument@Json@@PBU_Container_base@1@@Z PROC ; std::_Vector_const_iterator<Json::PathArgument,std::allocator<Json::PathArgument> >::_Vector_const_iterator<Json::PathArgument,std::allocator<Json::PathArgument> >, COMDAT
; _this$ = ecx

; 77   : 	_Vector_const_iterator(_Tptr _Ptr, const _Container_base *_Pvector)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Ranit@VPathArgument@Json@@HPBV12@ABV12@@std@@QAE@XZ

; 78   : 		{	// construct with pointer _Ptr
; 79   : 		_SCL_SECURE_VALIDATE(_Pvector != NULL && ((_Myvec *)_Pvector)->_Myfirst <= _Ptr && _Ptr <= ((_Myvec *)_Pvector)->_Mylast);

	cmp	DWORD PTR __Pvector$[ebp], 0
	je	SHORT $LN1@Vector_con@2
	mov	eax, DWORD PTR __Pvector$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, DWORD PTR __Ptr$[ebp]
	ja	SHORT $LN1@Vector_con@2
	mov	edx, DWORD PTR __Pvector$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	cmp	eax, DWORD PTR [edx+8]
	jbe	SHORT $LN2@Vector_con@2
$LN1@Vector_con@2:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@Vector_con@2:

; 80   : 		this->_Mycont = _Pvector;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Pvector$[ebp]
	mov	DWORD PTR [ecx], edx

; 81   : 		_Myptr = _Ptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 82   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_const_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAE@PAVPathArgument@Json@@PBU_Container_base@1@@Z ENDP ; std::_Vector_const_iterator<Json::PathArgument,std::allocator<Json::PathArgument> >::_Vector_const_iterator<Json::PathArgument,std::allocator<Json::PathArgument> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??8?$_Vector_const_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<Json::PathArgument,std::allocator<Json::PathArgument> >::operator==, COMDAT
; _this$ = ecx

; 190  : 		{	// test for iterator equality

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 191  : 
; 192  :  #if _HAS_ITERATOR_DEBUGGING
; 193  : 		_Compat(_Right);
; 194  :  #else
; 195  : 		_SCL_SECURE_VALIDATE(this->_Mycont != NULL && this->_Mycont == _Right._Mycont);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN1@operator@14
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [edx]
	je	SHORT $LN2@operator@14
$LN1@operator@14:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator@14:

; 196  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 197  : 
; 198  : 		return (_Myptr == _Right._Myptr);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx+4]
	sete	cl
	mov	al, cl

; 199  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??8?$_Vector_const_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<Json::PathArgument,std::allocator<Json::PathArgument> >::operator==
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0length_error@std@@QAE@ABV01@@Z PROC			; std::length_error::length_error, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0logic_error@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7length_error@std@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0length_error@std@@QAE@ABV01@@Z ENDP			; std::length_error::length_error
_TEXT	ENDS
PUBLIC	??0_Iterator_base@std@@QAE@XZ			; std::_Iterator_base::_Iterator_base
; Function compile flags: /Odtp
;	COMDAT ??0?$_Bidit@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@HPBU12@ABU12@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Bidit@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@HPBU12@ABU12@@std@@QAE@XZ PROC ; std::_Bidit<std::pair<Json::Value::CZString const ,Json::Value>,int,std::pair<Json::Value::CZString const ,Json::Value> const *,std::pair<Json::Value::CZString const ,Json::Value> const &>::_Bidit<std::pair<Json::Value::CZString const ,Json::Value>,int,std::pair<Json::Value::CZString const ,Json::Value> const *,std::pair<Json::Value::CZString const ,Json::Value> const &>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Iterator_base@std@@QAE@XZ		; std::_Iterator_base::_Iterator_base
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Bidit@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@HPBU12@ABU12@@std@@QAE@XZ ENDP ; std::_Bidit<std::pair<Json::Value::CZString const ,Json::Value>,int,std::pair<Json::Value::CZString const ,Json::Value> const *,std::pair<Json::Value::CZString const ,Json::Value> const &>::_Bidit<std::pair<Json::Value::CZString const ,Json::Value>,int,std::pair<Json::Value::CZString const ,Json::Value> const *,std::pair<Json::Value::CZString const ,Json::Value> const &>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 8\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??0_Iterator_base@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_Iterator_base@std@@QAE@XZ PROC			; std::_Iterator_base::_Iterator_base, COMDAT
; _this$ = ecx

; 403  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 404  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_Iterator_base@std@@QAE@XZ ENDP			; std::_Iterator_base::_Iterator_base
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0?$_Ranit@PBVPathArgument@Json@@HPBQBV12@ABQBV12@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Ranit@PBVPathArgument@Json@@HPBQBV12@ABQBV12@@std@@QAE@XZ PROC ; std::_Ranit<Json::PathArgument const *,int,Json::PathArgument const * const *,Json::PathArgument const * const &>::_Ranit<Json::PathArgument const *,int,Json::PathArgument const * const *,Json::PathArgument const * const &>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Iterator_base@std@@QAE@XZ		; std::_Iterator_base::_Iterator_base
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Ranit@PBVPathArgument@Json@@HPBQBV12@ABQBV12@@std@@QAE@XZ ENDP ; std::_Ranit<Json::PathArgument const *,int,Json::PathArgument const * const *,Json::PathArgument const * const &>::_Ranit<Json::PathArgument const *,int,Json::PathArgument const * const *,Json::PathArgument const * const &>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0?$_Ranit@VPathArgument@Json@@HPBV12@ABV12@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Ranit@VPathArgument@Json@@HPBV12@ABV12@@std@@QAE@XZ PROC ; std::_Ranit<Json::PathArgument,int,Json::PathArgument const *,Json::PathArgument const &>::_Ranit<Json::PathArgument,int,Json::PathArgument const *,Json::PathArgument const &>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Iterator_base@std@@QAE@XZ		; std::_Iterator_base::_Iterator_base
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Ranit@VPathArgument@Json@@HPBV12@ABV12@@std@@QAE@XZ ENDP ; std::_Ranit<Json::PathArgument,int,Json::PathArgument const *,Json::PathArgument const &>::_Ranit<Json::PathArgument,int,Json::PathArgument const *,Json::PathArgument const &>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 8\vc\include\vector
_TEXT	ENDS
;	COMDAT ?begin@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QAE?AV?$_Vector_iterator@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QAE?AV?$_Vector_iterator@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@2@XZ PROC ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::begin, COMDAT
; _this$ = ecx

; 627  : 		{	// return iterator for beginning of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 628  : 		return (iterator(_Myfirst, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QAE@PAPBVPathArgument@Json@@PBU_Container_base@1@@Z ; std::_Vector_iterator<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::_Vector_iterator<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 629  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QAE?AV?$_Vector_iterator@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@2@XZ ENDP ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::begin
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@PBVPathArgument@Json@@@std@@QBEIXZ ; std::allocator<Json::PathArgument const *>::max_size
; Function compile flags: /Odtp
;	COMDAT ?max_size@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QBEIXZ PROC ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::max_size, COMDAT
; _this$ = ecx

; 707  : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 708  : 		return (this->_Alval.max_size());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$allocator@PBVPathArgument@Json@@@std@@QBEIXZ ; std::allocator<Json::PathArgument const *>::max_size

; 709  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QBEIXZ ENDP ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::max_size
_TEXT	ENDS
PUBLIC	??$_Destroy_range@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@YAXPAPBVPathArgument@Json@@0AAV?$allocator@PBVPathArgument@Json@@@0@@Z ; std::_Destroy_range<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >
; Function compile flags: /Odtp
;	COMDAT ?_Destroy@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IAEXPAPBVPathArgument@Json@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IAEXPAPBVPathArgument@Json@@0@Z PROC ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::_Destroy, COMDAT
; _this$ = ecx

; 1082 : 		{	// destroy [_First, _Last) using allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1083 : 		_Destroy_range(_First, _Last, this->_Alval);

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@YAXPAPBVPathArgument@Json@@0AAV?$allocator@PBVPathArgument@Json@@@0@@Z ; std::_Destroy_range<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >
	add	esp, 12					; 0000000cH

; 1084 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Destroy@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IAEXPAPBVPathArgument@Json@@0@Z ENDP ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::_Destroy
_TEXT	ENDS
PUBLIC	??$_Unchecked_move_backward@PAPBVPathArgument@Json@@PAPBV12@@stdext@@YAPAPBVPathArgument@Json@@PAPBV12@00@Z ; stdext::_Unchecked_move_backward<Json::PathArgument const * *,Json::PathArgument const * *>
PUBLIC	??$fill@PAPBVPathArgument@Json@@PBV12@@std@@YAXPAPBVPathArgument@Json@@0ABQBV12@@Z ; std::fill<Json::PathArgument const * *,Json::PathArgument const *>
PUBLIC	??$_Umove@PAPBVPathArgument@Json@@@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IAEPAPBVPathArgument@Json@@PAPBV23@00@Z ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::_Umove<Json::PathArgument const * *>
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Insert_n@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IAEXV?$_Vector_iterator@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@2@IABQBVPathArgument@Json@@@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IAEXV?$_Vector_iterator@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@2@IABQBVPathArgument@Json@@@Z$2
__catchsym$?_Insert_n@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IAEXV?$_Vector_iterator@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@2@IABQBVPathArgument@Json@@@Z$4 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IAEXV?$_Vector_iterator@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@2@IABQBVPathArgument@Json@@@Z$0
__unwindtable$?_Insert_n@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IAEXV?$_Vector_iterator@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@2@IABQBVPathArgument@Json@@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$?_Insert_n@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IAEXV?$_Vector_iterator@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@2@IABQBVPathArgument@Json@@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Insert_n@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IAEXV?$_Vector_iterator@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@2@IABQBVPathArgument@Json@@@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Insert_n@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IAEXV?$_Vector_iterator@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@2@IABQBVPathArgument@Json@@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Insert_n@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IAEXV?$_Vector_iterator@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@2@IABQBVPathArgument@Json@@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IAEXV?$_Vector_iterator@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@2@IABQBVPathArgument@Json@@@Z$4
	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IAEXV?$_Vector_iterator@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@2@IABQBVPathArgument@Json@@@Z$5
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IAEXV?$_Vector_iterator@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@2@IABQBVPathArgument@Json@@@Z
_TEXT	SEGMENT
tv239 = -52						; size = 4
tv238 = -48						; size = 4
tv84 = -44						; size = 4
_this$ = -40						; size = 4
__Oldend$25801 = -36					; size = 4
__Newvec$25780 = -32					; size = 4
__Ptr$25781 = -28					; size = 4
__Capacity$ = -24					; size = 4
__Tmp$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Where$ = 8						; size = 8
__Count$ = 16						; size = 4
__Val$ = 20						; size = 4
?_Insert_n@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IAEXV?$_Vector_iterator@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@2@IABQBVPathArgument@Json@@@Z PROC ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::_Insert_n, COMDAT
; _this$ = ecx

; 1117 : 		{	// insert _Count * _Val at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Insert_n@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IAEXV?$_Vector_iterator@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@2@IABQBVPathArgument@Json@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 36					; 00000024H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1118 : 
; 1119 :  #if _HAS_ITERATOR_DEBUGGING
; 1120 : 		if (_Where._Mycont != this
; 1121 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1122 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1123 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1124 : 
; 1125 : 		_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Tmp$[ebp], ecx

; 1126 : 		size_type _Capacity = capacity();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?capacity@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QBEIXZ ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::capacity
	mov	DWORD PTR __Capacity$[ebp], eax

; 1127 : 
; 1128 : 		if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN12@Insert_n
	jmp	$LN14@Insert_n
$LN12@Insert_n:

; 1129 : 			;
; 1130 : 		else if (max_size() - size() < _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QBEIXZ ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QBEIXZ ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::max_size
	sub	eax, esi
	cmp	eax, DWORD PTR __Count$[ebp]
	jae	SHORT $LN10@Insert_n

; 1131 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@KAXXZ ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::_Xlen
	jmp	$LN14@Insert_n
$LN10@Insert_n:

; 1132 : 		else if (_Capacity < size() + _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QBEIXZ ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::size
	add	eax, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], eax
	jae	$LN8@Insert_n

; 1133 : 			{	// not enough room, reallocate
; 1134 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1135 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	esi, DWORD PTR __Capacity$[ebp]
	shr	esi, 1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QBEIXZ ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::max_size
	sub	eax, esi
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN15@Insert_n
	mov	DWORD PTR tv84[ebp], 0
	jmp	SHORT $LN16@Insert_n
$LN15@Insert_n:
	mov	edx, DWORD PTR __Capacity$[ebp]
	shr	edx, 1
	add	edx, DWORD PTR __Capacity$[ebp]
	mov	DWORD PTR tv84[ebp], edx
$LN16@Insert_n:
	mov	eax, DWORD PTR tv84[ebp]
	mov	DWORD PTR __Capacity$[ebp], eax

; 1136 : 			if (_Capacity < size() + _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QBEIXZ ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::size
	add	eax, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], eax
	jae	SHORT $LN7@Insert_n

; 1137 : 				_Capacity = size() + _Count;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QBEIXZ ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::size
	add	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Capacity$[ebp], eax
$LN7@Insert_n:

; 1138 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

	mov	ecx, DWORD PTR __Capacity$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?allocate@?$allocator@PBVPathArgument@Json@@@std@@QAEPAPBVPathArgument@Json@@I@Z ; std::allocator<Json::PathArgument const *>::allocate
	mov	DWORD PTR __Newvec$25780[ebp], eax

; 1139 : 			pointer _Ptr = _Newvec;

	mov	edx, DWORD PTR __Newvec$25780[ebp]
	mov	DWORD PTR __Ptr$25781[ebp], edx

; 1140 : 
; 1141 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1142 : 			_Ptr = _Umove(_Myfirst, _VEC_ITER_BASE(_Where),
; 1143 : 				_Newvec);	// copy prefix

	mov	eax, DWORD PTR __Newvec$25780[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAPBVPathArgument@Json@@@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IAEPAPBVPathArgument@Json@@PAPBV23@00@Z ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::_Umove<Json::PathArgument const * *>
	mov	DWORD PTR tv238[ebp], eax
	mov	ecx, DWORD PTR tv238[ebp]
	mov	DWORD PTR __Ptr$25781[ebp], ecx

; 1144 : 			_Ptr = _Ufill(_Ptr, _Count, _Tmp);	// add new stuff

	lea	edx, DWORD PTR __Tmp$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$25781[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Ufill@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IAEPAPBVPathArgument@Json@@PAPBV34@IABQBV34@@Z ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::_Ufill
	mov	DWORD PTR tv239[ebp], eax
	mov	edx, DWORD PTR tv239[ebp]
	mov	DWORD PTR __Ptr$25781[ebp], edx

; 1145 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast, _Ptr);	// copy suffix

	mov	eax, DWORD PTR __Ptr$25781[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR __Where$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAPBVPathArgument@Json@@@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IAEPAPBVPathArgument@Json@@PAPBV23@00@Z ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::_Umove<Json::PathArgument const * *>
	jmp	SHORT $LN17@Insert_n
__catch$?_Insert_n@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IAEXV?$_Vector_iterator@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@2@IABQBVPathArgument@Json@@@Z$0:

; 1146 : 			_CATCH_ALL
; 1147 : 			_Destroy(_Newvec, _Ptr);

	mov	ecx, DWORD PTR __Ptr$25781[ebp]
	push	ecx
	mov	edx, DWORD PTR __Newvec$25780[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IAEXPAPBVPathArgument@Json@@0@Z ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::_Destroy

; 1148 : 			this->_Alval.deallocate(_Newvec, _Capacity);

	mov	eax, DWORD PTR __Capacity$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Newvec$25780[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?deallocate@?$allocator@PBVPathArgument@Json@@@std@@QAEXPAPBVPathArgument@Json@@I@Z ; std::allocator<Json::PathArgument const *>::deallocate

; 1149 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
	mov	eax, __tryend$?_Insert_n@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IAEXV?$_Vector_iterator@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@2@IABQBVPathArgument@Json@@@Z$1
	ret	0
$LN17@Insert_n:

; 1150 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Insert_n@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IAEXV?$_Vector_iterator@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@2@IABQBVPathArgument@Json@@@Z$1:

; 1151 : 
; 1152 : 			_Count += size();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QBEIXZ ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::size
	add	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Count$[ebp], eax

; 1153 : 			if (_Myfirst != 0)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+4], 0
	je	SHORT $LN5@Insert_n

; 1154 : 				{	// destroy and deallocate old array
; 1155 : 				_Destroy(_Myfirst, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IAEXPAPBVPathArgument@Json@@0@Z ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::_Destroy

; 1156 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?deallocate@?$allocator@PBVPathArgument@Json@@@std@@QAEXPAPBVPathArgument@Json@@I@Z ; std::allocator<Json::PathArgument const *>::deallocate
$LN5@Insert_n:

; 1157 : 				}
; 1158 : 
; 1159 :  #if _HAS_ITERATOR_DEBUGGING
; 1160 : 			this->_Orphan_all();
; 1161 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1162 : 
; 1163 : 			_Myend = _Newvec + _Capacity;

	mov	eax, DWORD PTR __Capacity$[ebp]
	mov	ecx, DWORD PTR __Newvec$25780[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], edx

; 1164 : 			_Mylast = _Newvec + _Count;

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Newvec$25780[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 1165 : 			_Myfirst = _Newvec;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Newvec$25780[ebp]
	mov	DWORD PTR [edx+4], eax
	jmp	$LN14@Insert_n
$LN8@Insert_n:

; 1166 : 			}
; 1167 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	sub	edx, DWORD PTR __Where$[ebp+4]
	sar	edx, 2
	cmp	edx, DWORD PTR __Count$[ebp]
	jae	$LN3@Insert_n

; 1168 : 			{	// new stuff spills off end
; 1169 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1170 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	mov	eax, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR __Where$[ebp+4]
	lea	edx, DWORD PTR [ecx+eax*4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp+4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAPBVPathArgument@Json@@@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IAEPAPBVPathArgument@Json@@PAPBV23@00@Z ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::_Umove<Json::PathArgument const * *>

; 1171 : 
; 1172 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 2

; 1173 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1174 : 				_Tmp);	// insert new stuff off end

	lea	eax, DWORD PTR __Tmp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	sub	edx, DWORD PTR __Where$[ebp+4]
	sar	edx, 2
	mov	eax, DWORD PTR __Count$[ebp]
	sub	eax, edx
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Ufill@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IAEPAPBVPathArgument@Json@@PAPBV34@IABQBV34@@Z ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::_Ufill
	jmp	SHORT $LN19@Insert_n
__catch$?_Insert_n@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IAEXV?$_Vector_iterator@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@2@IABQBVPathArgument@Json@@@Z$2:

; 1175 : 			_CATCH_ALL
; 1176 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR __Count$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Where$[ebp+4]
	lea	eax, DWORD PTR [edx+ecx*4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IAEXPAPBVPathArgument@Json@@0@Z ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::_Destroy

; 1177 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
	mov	eax, __tryend$?_Insert_n@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IAEXV?$_Vector_iterator@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@2@IABQBVPathArgument@Json@@@Z$3
	ret	0
$LN19@Insert_n:

; 1178 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Insert_n@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IAEXV?$_Vector_iterator@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@2@IABQBVPathArgument@Json@@@Z$3:

; 1179 : 
; 1180 : 			_Mylast += _Count;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR __Count$[ebp]
	lea	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 1181 : 
; 1182 :  #if _HAS_ITERATOR_DEBUGGING
; 1183 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1184 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1185 : 
; 1186 : 			fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1187 : 				_Tmp);	// insert up to old end

	lea	eax, DWORD PTR __Tmp$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 2
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	sub	eax, ecx
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	call	??$fill@PAPBVPathArgument@Json@@PBV12@@std@@YAXPAPBVPathArgument@Json@@0ABQBV12@@Z ; std::fill<Json::PathArgument const * *,Json::PathArgument const *>
	add	esp, 12					; 0000000cH

; 1188 : 			}
; 1189 : 		else

	jmp	SHORT $LN14@Insert_n
$LN3@Insert_n:

; 1190 : 			{	// new stuff can all be assigned
; 1191 : 			pointer _Oldend = _Mylast;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR __Oldend$25801[ebp], eax

; 1192 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1193 : 				_Mylast);	// copy suffix

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR __Oldend$25801[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 2
	mov	edx, DWORD PTR __Oldend$25801[ebp]
	sub	edx, ecx
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAPBVPathArgument@Json@@@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IAEPAPBVPathArgument@Json@@PAPBV23@00@Z ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::_Umove<Json::PathArgument const * *>
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 1194 : 
; 1195 :  #if _HAS_ITERATOR_DEBUGGING
; 1196 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1197 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1198 : 
; 1199 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1200 : 				_Oldend);	// copy hole

	mov	edx, DWORD PTR __Oldend$25801[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	mov	ecx, DWORD PTR __Oldend$25801[ebp]
	sub	ecx, eax
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp+4]
	push	edx
	call	??$_Unchecked_move_backward@PAPBVPathArgument@Json@@PAPBV12@@stdext@@YAPAPBVPathArgument@Json@@PAPBV12@00@Z ; stdext::_Unchecked_move_backward<Json::PathArgument const * *,Json::PathArgument const * *>
	add	esp, 12					; 0000000cH

; 1201 : 			fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1202 : 				_Tmp);	// insert into hole

	lea	eax, DWORD PTR __Tmp$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Where$[ebp+4]
	lea	eax, DWORD PTR [edx+ecx*4]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	call	??$fill@PAPBVPathArgument@Json@@PBV12@@std@@YAXPAPBVPathArgument@Json@@0ABQBV12@@Z ; std::fill<Json::PathArgument const * *,Json::PathArgument const *>
	add	esp, 12					; 0000000cH
$LN14@Insert_n:

; 1203 : 			}
; 1204 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Insert_n@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IAEXV?$_Vector_iterator@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@2@IABQBVPathArgument@Json@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-56]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Insert_n@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IAEXV?$_Vector_iterator@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@2@IABQBVPathArgument@Json@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert_n@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IAEXV?$_Vector_iterator@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@2@IABQBVPathArgument@Json@@@Z ENDP ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::_Insert_n
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@KAXXZ$0
__ehfuncinfo$?_Xlen@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@KAXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T32165 = -80						; size = 28
$T32164 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@KAXXZ PROC ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::_Xlen, COMDAT

; 1213 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Xlen@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1214 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T32165[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR $T32165[ebp]
	push	eax
	lea	ecx, DWORD PTR $T32164[ebp]
	call	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T32164[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T32165[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@Xlen@2:

; 1215 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T32165[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?_Xlen@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@KAXXZ ENDP ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::_Xlen
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 8\vc\include\xmemory
;	COMDAT ??0?$allocator@PBVPathArgument@Json@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@PBVPathArgument@Json@@@std@@QAE@ABV01@@Z PROC ; std::allocator<Json::PathArgument const *>::allocator<Json::PathArgument const *>, COMDAT
; _this$ = ecx

; 124  : 	allocator(const allocator<_Ty>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 125  : 		{	// construct by copying (do nothing)
; 126  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$allocator@PBVPathArgument@Json@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<Json::PathArgument const *>::allocator<Json::PathArgument const *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@PBVPathArgument@Json@@@std@@QAEXPAPBVPathArgument@Json@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PBVPathArgument@Json@@@std@@QAEXPAPBVPathArgument@Json@@I@Z PROC ; std::allocator<Json::PathArgument const *>::deallocate, COMDAT
; _this$ = ecx

; 140  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 141  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 142  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@PBVPathArgument@Json@@@std@@QAEXPAPBVPathArgument@Json@@I@Z ENDP ; std::allocator<Json::PathArgument const *>::deallocate
_TEXT	ENDS
PUBLIC	??$_Allocate@PBVPathArgument@Json@@@std@@YAPAPBVPathArgument@Json@@IPAPBV12@@Z ; std::_Allocate<Json::PathArgument const *>
; Function compile flags: /Odtp
;	COMDAT ?allocate@?$allocator@PBVPathArgument@Json@@@std@@QAEPAPBVPathArgument@Json@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@PBVPathArgument@Json@@@std@@QAEPAPBVPathArgument@Json@@I@Z PROC ; std::allocator<Json::PathArgument const *>::allocate, COMDAT
; _this$ = ecx

; 145  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 146  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@PBVPathArgument@Json@@@std@@YAPAPBVPathArgument@Json@@IPAPBV12@@Z ; std::_Allocate<Json::PathArgument const *>
	add	esp, 8

; 147  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@PBVPathArgument@Json@@@std@@QAEPAPBVPathArgument@Json@@I@Z ENDP ; std::allocator<Json::PathArgument const *>::allocate
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 8\vc\include\vector
_TEXT	ENDS
;	COMDAT ?begin@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAE?AV?$_Vector_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAE?AV?$_Vector_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@2@XZ PROC ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::begin, COMDAT
; _this$ = ecx

; 627  : 		{	// return iterator for beginning of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 628  : 		return (iterator(_Myfirst, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAE@PAVPathArgument@Json@@PBU_Container_base@1@@Z ; std::_Vector_iterator<Json::PathArgument,std::allocator<Json::PathArgument> >::_Vector_iterator<Json::PathArgument,std::allocator<Json::PathArgument> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 629  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAE?AV?$_Vector_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@2@XZ ENDP ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::begin
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@VPathArgument@Json@@@std@@QBEIXZ ; std::allocator<Json::PathArgument>::max_size
; Function compile flags: /Odtp
;	COMDAT ?max_size@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBEIXZ PROC ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::max_size, COMDAT
; _this$ = ecx

; 707  : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 708  : 		return (this->_Alval.max_size());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$allocator@VPathArgument@Json@@@std@@QBEIXZ ; std::allocator<Json::PathArgument>::max_size

; 709  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBEIXZ ENDP ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::max_size
_TEXT	ENDS
PUBLIC	??$_Destroy_range@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@YAXPAVPathArgument@Json@@0AAV?$allocator@VPathArgument@Json@@@0@@Z ; std::_Destroy_range<Json::PathArgument,std::allocator<Json::PathArgument> >
; Function compile flags: /Odtp
;	COMDAT ?_Destroy@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAEXPAVPathArgument@Json@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAEXPAVPathArgument@Json@@0@Z PROC ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::_Destroy, COMDAT
; _this$ = ecx

; 1082 : 		{	// destroy [_First, _Last) using allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1083 : 		_Destroy_range(_First, _Last, this->_Alval);

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@YAXPAVPathArgument@Json@@0AAV?$allocator@VPathArgument@Json@@@0@@Z ; std::_Destroy_range<Json::PathArgument,std::allocator<Json::PathArgument> >
	add	esp, 12					; 0000000cH

; 1084 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Destroy@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAEXPAVPathArgument@Json@@0@Z ENDP ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::_Destroy
_TEXT	ENDS
PUBLIC	??$_Unchecked_move_backward@PAVPathArgument@Json@@PAV12@@stdext@@YAPAVPathArgument@Json@@PAV12@00@Z ; stdext::_Unchecked_move_backward<Json::PathArgument *,Json::PathArgument *>
PUBLIC	??$fill@PAVPathArgument@Json@@V12@@std@@YAXPAVPathArgument@Json@@0ABV12@@Z ; std::fill<Json::PathArgument *,Json::PathArgument>
PUBLIC	??$_Umove@PAVPathArgument@Json@@@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAEPAVPathArgument@Json@@PAV23@00@Z ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::_Umove<Json::PathArgument *>
PUBLIC	??0PathArgument@Json@@QAE@ABV01@@Z		; Json::PathArgument::PathArgument
PUBLIC	__$ArrayPad$
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Insert_n@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAEXV?$_Vector_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@2@IABVPathArgument@Json@@@Z$6 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAEXV?$_Vector_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@2@IABVPathArgument@Json@@@Z$2
__catchsym$?_Insert_n@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAEXV?$_Vector_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@2@IABVPathArgument@Json@@@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAEXV?$_Vector_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@2@IABVPathArgument@Json@@@Z$0
__ehfuncinfo$?_Insert_n@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAEXV?$_Vector_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@2@IABVPathArgument@Json@@@Z DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$?_Insert_n@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAEXV?$_Vector_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@2@IABVPathArgument@Json@@@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Insert_n@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAEXV?$_Vector_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@2@IABVPathArgument@Json@@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Insert_n@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAEXV?$_Vector_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@2@IABVPathArgument@Json@@@Z DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAEXV?$_Vector_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@2@IABVPathArgument@Json@@@Z$5
	DD	03H
	DD	03H
	DD	04H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAEXV?$_Vector_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@2@IABVPathArgument@Json@@@Z$6
__unwindtable$?_Insert_n@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAEXV?$_Vector_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@2@IABVPathArgument@Json@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Insert_n@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAEXV?$_Vector_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@2@IABVPathArgument@Json@@@Z$4
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAEXV?$_Vector_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@2@IABVPathArgument@Json@@@Z
_TEXT	SEGMENT
tv243 = -88						; size = 4
tv65 = -84						; size = 4
tv88 = -80						; size = 4
_this$ = -76						; size = 4
__Oldend$25871 = -72					; size = 4
__Newvec$25850 = -68					; size = 4
__Ptr$25851 = -64					; size = 4
__Capacity$ = -60					; size = 4
__Tmp$ = -56						; size = 36
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Where$ = 8						; size = 8
__Count$ = 16						; size = 4
__Val$ = 20						; size = 4
?_Insert_n@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAEXV?$_Vector_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@2@IABVPathArgument@Json@@@Z PROC ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::_Insert_n, COMDAT
; _this$ = ecx

; 1117 : 		{	// insert _Count * _Val at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Insert_n@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAEXV?$_Vector_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@2@IABVPathArgument@Json@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 72					; 00000048H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1118 : 
; 1119 :  #if _HAS_ITERATOR_DEBUGGING
; 1120 : 		if (_Where._Mycont != this
; 1121 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1122 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1123 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1124 : 
; 1125 : 		_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Tmp$[ebp]
	call	??0PathArgument@Json@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1126 : 		size_type _Capacity = capacity();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?capacity@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBEIXZ ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::capacity
	mov	DWORD PTR __Capacity$[ebp], eax

; 1127 : 
; 1128 : 		if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN12@Insert_n@2
	jmp	$LN11@Insert_n@2
$LN12@Insert_n@2:

; 1129 : 			;
; 1130 : 		else if (max_size() - size() < _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBEIXZ ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBEIXZ ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::max_size
	sub	eax, esi
	cmp	eax, DWORD PTR __Count$[ebp]
	jae	SHORT $LN10@Insert_n@2

; 1131 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@KAXXZ ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::_Xlen
	jmp	$LN11@Insert_n@2
$LN10@Insert_n@2:

; 1132 : 		else if (_Capacity < size() + _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBEIXZ ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::size
	add	eax, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], eax
	jae	$LN8@Insert_n@2

; 1133 : 			{	// not enough room, reallocate
; 1134 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1135 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	esi, DWORD PTR __Capacity$[ebp]
	shr	esi, 1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBEIXZ ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::max_size
	sub	eax, esi
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN15@Insert_n@2
	mov	DWORD PTR tv88[ebp], 0
	jmp	SHORT $LN16@Insert_n@2
$LN15@Insert_n@2:
	mov	ecx, DWORD PTR __Capacity$[ebp]
	shr	ecx, 1
	add	ecx, DWORD PTR __Capacity$[ebp]
	mov	DWORD PTR tv88[ebp], ecx
$LN16@Insert_n@2:
	mov	edx, DWORD PTR tv88[ebp]
	mov	DWORD PTR __Capacity$[ebp], edx

; 1136 : 			if (_Capacity < size() + _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBEIXZ ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::size
	add	eax, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], eax
	jae	SHORT $LN7@Insert_n@2

; 1137 : 				_Capacity = size() + _Count;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBEIXZ ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::size
	add	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Capacity$[ebp], eax
$LN7@Insert_n@2:

; 1138 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

	mov	eax, DWORD PTR __Capacity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?allocate@?$allocator@VPathArgument@Json@@@std@@QAEPAVPathArgument@Json@@I@Z ; std::allocator<Json::PathArgument>::allocate
	mov	DWORD PTR __Newvec$25850[ebp], eax

; 1139 : 			pointer _Ptr = _Newvec;

	mov	ecx, DWORD PTR __Newvec$25850[ebp]
	mov	DWORD PTR __Ptr$25851[ebp], ecx

; 1140 : 
; 1141 : 			_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 1

; 1142 : 			_Ptr = _Umove(_Myfirst, _VEC_ITER_BASE(_Where),
; 1143 : 				_Newvec);	// copy prefix

	mov	edx, DWORD PTR __Newvec$25850[ebp]
	push	edx
	mov	eax, DWORD PTR __Where$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAVPathArgument@Json@@@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAEPAVPathArgument@Json@@PAV23@00@Z ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::_Umove<Json::PathArgument *>
	mov	DWORD PTR tv65[ebp], eax
	mov	eax, DWORD PTR tv65[ebp]
	mov	DWORD PTR __Ptr$25851[ebp], eax

; 1144 : 			_Ptr = _Ufill(_Ptr, _Count, _Tmp);	// add new stuff

	lea	ecx, DWORD PTR __Tmp$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Ptr$25851[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Ufill@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAEPAVPathArgument@Json@@PAV34@IABV34@@Z ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::_Ufill
	mov	DWORD PTR tv243[ebp], eax
	mov	ecx, DWORD PTR tv243[ebp]
	mov	DWORD PTR __Ptr$25851[ebp], ecx

; 1145 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast, _Ptr);	// copy suffix

	mov	edx, DWORD PTR __Ptr$25851[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp+4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAVPathArgument@Json@@@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAEPAVPathArgument@Json@@PAV23@00@Z ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::_Umove<Json::PathArgument *>
	jmp	SHORT $LN17@Insert_n@2
__catch$?_Insert_n@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAEXV?$_Vector_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@2@IABVPathArgument@Json@@@Z$0:

; 1146 : 			_CATCH_ALL
; 1147 : 			_Destroy(_Newvec, _Ptr);

	mov	eax, DWORD PTR __Ptr$25851[ebp]
	push	eax
	mov	ecx, DWORD PTR __Newvec$25850[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAEXPAVPathArgument@Json@@0@Z ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::_Destroy

; 1148 : 			this->_Alval.deallocate(_Newvec, _Capacity);

	mov	edx, DWORD PTR __Capacity$[ebp]
	push	edx
	mov	eax, DWORD PTR __Newvec$25850[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?deallocate@?$allocator@VPathArgument@Json@@@std@@QAEXPAVPathArgument@Json@@I@Z ; std::allocator<Json::PathArgument>::deallocate

; 1149 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
	mov	eax, __tryend$?_Insert_n@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAEXV?$_Vector_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@2@IABVPathArgument@Json@@@Z$1
	ret	0
$LN17@Insert_n@2:

; 1150 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], 0
__tryend$?_Insert_n@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAEXV?$_Vector_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@2@IABVPathArgument@Json@@@Z$1:

; 1151 : 
; 1152 : 			_Count += size();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBEIXZ ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::size
	add	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Count$[ebp], eax

; 1153 : 			if (_Myfirst != 0)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+4], 0
	je	SHORT $LN5@Insert_n@2

; 1154 : 				{	// destroy and deallocate old array
; 1155 : 				_Destroy(_Myfirst, _Mylast);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAEXPAVPathArgument@Json@@0@Z ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::_Destroy

; 1156 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+12]
	sub	eax, DWORD PTR [ecx+4]
	cdq
	mov	ecx, 36					; 00000024H
	idiv	ecx
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?deallocate@?$allocator@VPathArgument@Json@@@std@@QAEXPAVPathArgument@Json@@I@Z ; std::allocator<Json::PathArgument>::deallocate
$LN5@Insert_n@2:

; 1157 : 				}
; 1158 : 
; 1159 :  #if _HAS_ITERATOR_DEBUGGING
; 1160 : 			this->_Orphan_all();
; 1161 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1162 : 
; 1163 : 			_Myend = _Newvec + _Capacity;

	mov	ecx, DWORD PTR __Capacity$[ebp]
	imul	ecx, 36					; 00000024H
	add	ecx, DWORD PTR __Newvec$25850[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], ecx

; 1164 : 			_Mylast = _Newvec + _Count;

	mov	eax, DWORD PTR __Count$[ebp]
	imul	eax, 36					; 00000024H
	add	eax, DWORD PTR __Newvec$25850[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 1165 : 			_Myfirst = _Newvec;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Newvec$25850[ebp]
	mov	DWORD PTR [edx+4], eax
	jmp	$LN11@Insert_n@2
$LN8@Insert_n@2:

; 1166 : 			}
; 1167 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR __Where$[ebp+4]
	cdq
	mov	ecx, 36					; 00000024H
	idiv	ecx
	cmp	eax, DWORD PTR __Count$[ebp]
	jae	$LN3@Insert_n@2

; 1168 : 			{	// new stuff spills off end
; 1169 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1170 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	mov	edx, DWORD PTR __Count$[ebp]
	imul	edx, 36					; 00000024H
	add	edx, DWORD PTR __Where$[ebp+4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp+4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAVPathArgument@Json@@@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAEPAVPathArgument@Json@@PAV23@00@Z ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::_Umove<Json::PathArgument *>

; 1171 : 
; 1172 : 			_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 3

; 1173 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1174 : 				_Tmp);	// insert new stuff off end

	lea	eax, DWORD PTR __Tmp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR __Where$[ebp+4]
	cdq
	mov	ecx, 36					; 00000024H
	idiv	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	sub	edx, eax
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Ufill@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAEPAVPathArgument@Json@@PAV34@IABV34@@Z ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::_Ufill
	jmp	SHORT $LN19@Insert_n@2
__catch$?_Insert_n@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAEXV?$_Vector_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@2@IABVPathArgument@Json@@@Z$2:

; 1175 : 			_CATCH_ALL
; 1176 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);

	mov	edx, DWORD PTR __Count$[ebp]
	imul	edx, 36					; 00000024H
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+8]
	push	edx
	mov	ecx, DWORD PTR __Count$[ebp]
	imul	ecx, 36					; 00000024H
	add	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAEXPAVPathArgument@Json@@0@Z ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::_Destroy

; 1177 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
	mov	eax, __tryend$?_Insert_n@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAEXV?$_Vector_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@2@IABVPathArgument@Json@@@Z$3
	ret	0
$LN19@Insert_n@2:

; 1178 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], 0
__tryend$?_Insert_n@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAEXV?$_Vector_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@2@IABVPathArgument@Json@@@Z$3:

; 1179 : 
; 1180 : 			_Mylast += _Count;

	mov	edx, DWORD PTR __Count$[ebp]
	imul	edx, 36					; 00000024H
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], edx

; 1181 : 
; 1182 :  #if _HAS_ITERATOR_DEBUGGING
; 1183 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1184 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1185 : 
; 1186 : 			fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1187 : 				_Tmp);	// insert up to old end

	lea	edx, DWORD PTR __Tmp$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	imul	eax, 36					; 00000024H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	sub	edx, eax
	push	edx
	mov	eax, DWORD PTR __Where$[ebp+4]
	push	eax
	call	??$fill@PAVPathArgument@Json@@V12@@std@@YAXPAVPathArgument@Json@@0ABV12@@Z ; std::fill<Json::PathArgument *,Json::PathArgument>
	add	esp, 12					; 0000000cH

; 1188 : 			}
; 1189 : 		else

	jmp	SHORT $LN11@Insert_n@2
$LN3@Insert_n@2:

; 1190 : 			{	// new stuff can all be assigned
; 1191 : 			pointer _Oldend = _Mylast;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR __Oldend$25871[ebp], edx

; 1192 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1193 : 				_Mylast);	// copy suffix

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR __Oldend$25871[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	imul	eax, 36					; 00000024H
	mov	ecx, DWORD PTR __Oldend$25871[ebp]
	sub	ecx, eax
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAVPathArgument@Json@@@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAEPAVPathArgument@Json@@PAV23@00@Z ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::_Umove<Json::PathArgument *>
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], eax

; 1194 : 
; 1195 :  #if _HAS_ITERATOR_DEBUGGING
; 1196 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1197 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1198 : 
; 1199 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1200 : 				_Oldend);	// copy hole

	mov	eax, DWORD PTR __Oldend$25871[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	imul	ecx, 36					; 00000024H
	mov	edx, DWORD PTR __Oldend$25871[ebp]
	sub	edx, ecx
	push	edx
	mov	eax, DWORD PTR __Where$[ebp+4]
	push	eax
	call	??$_Unchecked_move_backward@PAVPathArgument@Json@@PAV12@@stdext@@YAPAVPathArgument@Json@@PAV12@00@Z ; stdext::_Unchecked_move_backward<Json::PathArgument *,Json::PathArgument *>
	add	esp, 12					; 0000000cH

; 1201 : 			fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1202 : 				_Tmp);	// insert into hole

	lea	ecx, DWORD PTR __Tmp$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	imul	edx, 36					; 00000024H
	add	edx, DWORD PTR __Where$[ebp+4]
	push	edx
	mov	eax, DWORD PTR __Where$[ebp+4]
	push	eax
	call	??$fill@PAVPathArgument@Json@@V12@@std@@YAXPAVPathArgument@Json@@0ABV12@@Z ; std::fill<Json::PathArgument *,Json::PathArgument>
	add	esp, 12					; 0000000cH
$LN11@Insert_n@2:

; 1203 : 			}
; 1204 : 		}

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	lea	ecx, DWORD PTR __Tmp$[ebp]
	call	??1PathArgument@Json@@QAE@XZ
$LN14@Insert_n@2:
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Insert_n@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAEXV?$_Vector_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@2@IABVPathArgument@Json@@@Z$4:
	lea	ecx, DWORD PTR __Tmp$[ebp]
	jmp	??1PathArgument@Json@@QAE@XZ
__ehhandler$?_Insert_n@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAEXV?$_Vector_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@2@IABVPathArgument@Json@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-92]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Insert_n@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAEXV?$_Vector_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@2@IABVPathArgument@Json@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert_n@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAEXV?$_Vector_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@2@IABVPathArgument@Json@@@Z ENDP ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::_Insert_n
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@KAXXZ$0
__ehfuncinfo$?_Xlen@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@KAXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T32211 = -80						; size = 28
$T32210 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@KAXXZ PROC ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::_Xlen, COMDAT

; 1213 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Xlen@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1214 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T32211[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR $T32211[ebp]
	push	eax
	lea	ecx, DWORD PTR $T32210[ebp]
	call	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T32210[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T32211[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@Xlen@3:

; 1215 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T32211[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?_Xlen@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@KAXXZ ENDP ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::_Xlen
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 8\vc\include\xmemory
;	COMDAT ??0?$allocator@VPathArgument@Json@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@VPathArgument@Json@@@std@@QAE@ABV01@@Z PROC ; std::allocator<Json::PathArgument>::allocator<Json::PathArgument>, COMDAT
; _this$ = ecx

; 124  : 	allocator(const allocator<_Ty>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 125  : 		{	// construct by copying (do nothing)
; 126  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$allocator@VPathArgument@Json@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<Json::PathArgument>::allocator<Json::PathArgument>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@VPathArgument@Json@@@std@@QAEXPAVPathArgument@Json@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@VPathArgument@Json@@@std@@QAEXPAVPathArgument@Json@@I@Z PROC ; std::allocator<Json::PathArgument>::deallocate, COMDAT
; _this$ = ecx

; 140  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 141  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 142  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@VPathArgument@Json@@@std@@QAEXPAVPathArgument@Json@@I@Z ENDP ; std::allocator<Json::PathArgument>::deallocate
_TEXT	ENDS
PUBLIC	??$_Allocate@VPathArgument@Json@@@std@@YAPAVPathArgument@Json@@IPAV12@@Z ; std::_Allocate<Json::PathArgument>
; Function compile flags: /Odtp
;	COMDAT ?allocate@?$allocator@VPathArgument@Json@@@std@@QAEPAVPathArgument@Json@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@VPathArgument@Json@@@std@@QAEPAVPathArgument@Json@@I@Z PROC ; std::allocator<Json::PathArgument>::allocate, COMDAT
; _this$ = ecx

; 145  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 146  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@VPathArgument@Json@@@std@@YAPAVPathArgument@Json@@IPAV12@@Z ; std::_Allocate<Json::PathArgument>
	add	esp, 8

; 147  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@VPathArgument@Json@@@std@@QAEPAVPathArgument@Json@@I@Z ENDP ; std::allocator<Json::PathArgument>::allocate
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@QBEIXZ ; std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >::max_size
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 8\vc\include\xtree
;	COMDAT ?max_size@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBEIXZ PROC ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::max_size, COMDAT
; _this$ = ecx

; 586  : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 587  : 		return (this->_Alval.max_size());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 3
	call	?max_size@?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@QBEIXZ ; std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >::max_size

; 588  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::max_size
_TEXT	ENDS
PUBLIC	?_Ubound@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@ABVCZString@Value@Json@@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Ubound
; Function compile flags: /Odtp
;	COMDAT ?upper_bound@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@ABVCZString@Value@Json@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
?upper_bound@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@ABVCZString@Value@Json@@@Z PROC ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::upper_bound, COMDAT
; _this$ = ecx

; 996  : 		{	// find leftmost node greater than _Keyval in mutable tree

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 997  : 		return (_TREE_ITERATOR(_Ubound(_Keyval)));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Keyval$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Ubound@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@ABVCZString@Value@Json@@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Ubound
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PBV12@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::iterator::iterator
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 998  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?upper_bound@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@ABVCZString@Value@Json@@@Z ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::upper_bound
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Copy@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@0@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@0@Z$0
__unwindtable$?_Copy@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@0@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Copy@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@0@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@0@Z$2
__ehfuncinfo$?_Copy@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@0@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Copy@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@0@Z
	DD	01H
	DD	FLAT:__tryblocktable$?_Copy@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@0@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Copy@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@0@Z
_TEXT	SEGMENT
tv144 = -52						; size = 4
tv143 = -48						; size = 4
tv142 = -44						; size = 4
tv141 = -40						; size = 4
tv140 = -36						; size = 4
tv139 = -32						; size = 4
_this$ = -28						; size = 4
__Pnode$25905 = -24					; size = 4
__Newroot$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Rootnode$ = 8						; size = 4
__Wherenode$ = 12					; size = 4
?_Copy@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@0@Z PROC ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Copy, COMDAT
; _this$ = ecx

; 1049 : 		{	// copy entire subtree, recursively

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Copy@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@0@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 36					; 00000024H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1050 : 		_Nodeptr _Newroot = _Myhead;	// point at nil node

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR __Newroot$[ebp], ecx

; 1051 : 
; 1052 : 		if (!_Isnil(_Rootnode))

	mov	edx, DWORD PTR __Rootnode$[ebp]
	push	edx
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Isnil
	add	esp, 4
	movsx	eax, BYTE PTR [eax]
	test	eax, eax
	jne	$LN3@Copy@2

; 1053 : 			{	// copy a node, then any subtrees
; 1054 : 			_Nodeptr _Pnode = _Buynode(_Myhead, _Wherenode, _Myhead,
; 1055 : 				_Myval(_Rootnode), _Color(_Rootnode));

	mov	ecx, DWORD PTR __Rootnode$[ebp]
	push	ecx
	call	?_Color@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Color
	add	esp, 4
	mov	dl, BYTE PTR [eax]
	push	edx
	mov	eax, DWORD PTR __Rootnode$[ebp]
	push	eax
	call	?_Myval@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAU?$pair@$$CBVCZString@Value@Json@@V23@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Myval
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buynode@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBVCZString@Value@Json@@V23@@2@D@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Buynode
	mov	DWORD PTR __Pnode$25905[ebp], eax

; 1056 : 			if (_Isnil(_Newroot))

	mov	eax, DWORD PTR __Newroot$[ebp]
	push	eax
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Isnil
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN2@Copy@2

; 1057 : 				_Newroot = _Pnode;	// memorize new root

	mov	edx, DWORD PTR __Pnode$25905[ebp]
	mov	DWORD PTR __Newroot$[ebp], edx
$LN2@Copy@2:

; 1058 : 
; 1059 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1060 : 			_Left(_Pnode) = _Copy(_Left(_Rootnode), _Pnode);

	mov	eax, DWORD PTR __Rootnode$[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Left
	add	esp, 4
	mov	DWORD PTR tv139[ebp], eax
	mov	ecx, DWORD PTR __Pnode$25905[ebp]
	push	ecx
	mov	edx, DWORD PTR tv139[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Copy@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@0@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Copy
	mov	DWORD PTR tv140[ebp], eax
	mov	ecx, DWORD PTR __Pnode$25905[ebp]
	push	ecx
	call	?_Left@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Left
	add	esp, 4
	mov	DWORD PTR tv141[ebp], eax
	mov	edx, DWORD PTR tv141[ebp]
	mov	eax, DWORD PTR tv140[ebp]
	mov	DWORD PTR [edx], eax

; 1061 : 			_Right(_Pnode) = _Copy(_Right(_Rootnode), _Pnode);

	mov	ecx, DWORD PTR __Rootnode$[ebp]
	push	ecx
	call	?_Right@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Right
	add	esp, 4
	mov	DWORD PTR tv142[ebp], eax
	mov	edx, DWORD PTR __Pnode$25905[ebp]
	push	edx
	mov	eax, DWORD PTR tv142[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Copy@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@0@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Copy
	mov	DWORD PTR tv143[ebp], eax
	mov	edx, DWORD PTR __Pnode$25905[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Right
	add	esp, 4
	mov	DWORD PTR tv144[ebp], eax
	mov	eax, DWORD PTR tv144[ebp]
	mov	ecx, DWORD PTR tv143[ebp]
	mov	DWORD PTR [eax], ecx
	jmp	SHORT $LN6@Copy@2
__catch$?_Copy@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@0@Z$0:

; 1062 : 			_CATCH_ALL
; 1063 : 			_Erase(_Newroot);	// subtree copy failed, bail out

	mov	edx, DWORD PTR __Newroot$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Erase@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Erase

; 1064 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
	mov	eax, $LN3@Copy@2
	ret	0
$LN6@Copy@2:

; 1065 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
$LN3@Copy@2:

; 1066 : 			}
; 1067 : 
; 1068 : 		return (_Newroot);	// return newly constructed tree

	mov	eax, DWORD PTR __Newroot$[ebp]
$LN5@Copy@2:

; 1069 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Copy@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@0@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-56]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Copy@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@0@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Copy@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@0@Z ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Copy
PUBLIC	?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@ABQAU342@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Node *>::construct
PUBLIC	?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Node>::allocate
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Buynode@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@XZ$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Buynode@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@XZ$0
__unwindtable$?_Buynode@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@XZ DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Buynode@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@XZ DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Buynode@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@XZ$2
__ehfuncinfo$?_Buynode@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Buynode@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@XZ
	DD	01H
	DD	FLAT:__tryblocktable$?_Buynode@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@XZ
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Buynode@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@XZ
_TEXT	SEGMENT
tv145 = -52						; size = 4
tv144 = -48						; size = 4
tv143 = -44						; size = 4
_this$ = -40						; size = 4
$T32247 = -36						; size = 4
$T32246 = -32						; size = 4
$T32245 = -28						; size = 4
__Wherenode$ = -24					; size = 4
__Linkcnt$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
?_Buynode@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Buynode, COMDAT
; _this$ = ecx

; 1289 : 		{	// allocate a head/nil node

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Buynode@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 36					; 00000024H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1290 : 		_Nodeptr _Wherenode = this->_Alnod.allocate(1);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1
	call	?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Node>::allocate
	mov	DWORD PTR __Wherenode$[ebp], eax

; 1291 : 		int _Linkcnt = 0;

	mov	DWORD PTR __Linkcnt$[ebp], 0

; 1292 : 
; 1293 : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1294 : 		this->_Alptr.construct(&_Left(_Wherenode), 0);

	mov	DWORD PTR $T32245[ebp], 0
	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Left
	add	esp, 4
	mov	DWORD PTR tv143[ebp], eax
	lea	ecx, DWORD PTR $T32245[ebp]
	push	ecx
	mov	edx, DWORD PTR tv143[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2
	call	?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@ABQAU342@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Node *>::construct

; 1295 : 		++_Linkcnt;

	mov	eax, DWORD PTR __Linkcnt$[ebp]
	add	eax, 1
	mov	DWORD PTR __Linkcnt$[ebp], eax

; 1296 : 		this->_Alptr.construct(&_Parent(_Wherenode), 0);

	mov	DWORD PTR $T32246[ebp], 0
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	push	ecx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Parent
	add	esp, 4
	mov	DWORD PTR tv144[ebp], eax
	lea	edx, DWORD PTR $T32246[ebp]
	push	edx
	mov	eax, DWORD PTR tv144[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2
	call	?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@ABQAU342@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Node *>::construct

; 1297 : 		++_Linkcnt;

	mov	ecx, DWORD PTR __Linkcnt$[ebp]
	add	ecx, 1
	mov	DWORD PTR __Linkcnt$[ebp], ecx

; 1298 : 		this->_Alptr.construct(&_Right(_Wherenode), 0);

	mov	DWORD PTR $T32247[ebp], 0
	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Right
	add	esp, 4
	mov	DWORD PTR tv145[ebp], eax
	lea	eax, DWORD PTR $T32247[ebp]
	push	eax
	mov	ecx, DWORD PTR tv145[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2
	call	?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@ABQAU342@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Node *>::construct
	jmp	SHORT $LN6@Buynode
__catch$?_Buynode@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@XZ$0:

; 1299 : 		_CATCH_ALL
; 1300 : 		if (1 < _Linkcnt)

	cmp	DWORD PTR __Linkcnt$[ebp], 1
	jle	SHORT $LN2@Buynode

; 1301 : 			this->_Alptr.destroy(&_Parent(_Wherenode));

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Parent
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2
	call	?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Node *>::destroy
$LN2@Buynode:

; 1302 : 		if (0 < _Linkcnt)

	cmp	DWORD PTR __Linkcnt$[ebp], 0
	jle	SHORT $LN1@Buynode

; 1303 : 			this->_Alptr.destroy(&_Left(_Wherenode));

	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Left
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2
	call	?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Node *>::destroy
$LN1@Buynode:

; 1304 : 		this->_Alnod.deallocate(_Wherenode, 1);

	push	1
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1
	call	?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Node>::deallocate

; 1305 : 		_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
	mov	eax, __tryend$?_Buynode@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@XZ$1
	ret	0
$LN6@Buynode:

; 1306 : 		_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Buynode@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@XZ$1:

; 1307 : 		_Color(_Wherenode) = _Black;

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Color@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 1308 : 		_Isnil(_Wherenode) = false;

	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Isnil
	add	esp, 4
	mov	BYTE PTR [eax], 0

; 1309 : 		return (_Wherenode);

	mov	eax, DWORD PTR __Wherenode$[ebp]
$LN5@Buynode:

; 1310 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Buynode@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-56]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Buynode@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Buynode@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Buynode
PUBLIC	??3@YAXPAX0@Z					; operator delete
PUBLIC	??0_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBVCZString@Value@Json@@V23@@2@D@Z ; std::_Tree_nod<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Node::_Node
PUBLIC	??2@YAPAXIPAX@Z					; operator new
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Buynode@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBVCZString@Value@Json@@V23@@2@D@Z$3 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Buynode@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBVCZString@Value@Json@@V23@@2@D@Z$0
__tryblocktable$?_Buynode@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBVCZString@Value@Json@@V23@@2@D@Z DD 00H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$?_Buynode@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBVCZString@Value@Json@@V23@@2@D@Z$3
__unwindtable$?_Buynode@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBVCZString@Value@Json@@V23@@2@D@Z DD 0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$?_Buynode@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBVCZString@Value@Json@@V23@@2@D@Z$2
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$?_Buynode@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBVCZString@Value@Json@@V23@@2@D@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?_Buynode@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBVCZString@Value@Json@@V23@@2@D@Z
	DD	01H
	DD	FLAT:__tryblocktable$?_Buynode@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBVCZString@Value@Json@@V23@@2@D@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Buynode@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBVCZString@Value@Json@@V23@@2@D@Z
_TEXT	SEGMENT
tv82 = -40						; size = 4
tv93 = -36						; size = 4
_this$ = -32						; size = 4
$T32263 = -28						; size = 4
$T32262 = -24						; size = 4
__Wherenode$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Larg$ = 8						; size = 4
__Parg$ = 12						; size = 4
__Rarg$ = 16						; size = 4
__Val$ = 20						; size = 4
__Carg$ = 24						; size = 1
?_Buynode@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBVCZString@Value@Json@@V23@@2@D@Z PROC ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Buynode, COMDAT
; _this$ = ecx

; 1314 : 		{	// allocate a node with pointers, value, and color

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Buynode@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBVCZString@Value@Json@@V23@@2@D@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 24					; 00000018H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1315 : 		_Nodeptr _Wherenode = this->_Alnod.allocate(1);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1
	call	?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Node>::allocate
	mov	DWORD PTR __Wherenode$[ebp], eax

; 1316 : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1317 : 		new (_Wherenode) _Node(_Larg, _Parg, _Rarg, _Val, _Carg);

	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	push	48					; 00000030H
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T32263[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	cmp	DWORD PTR $T32263[ebp], 0
	je	SHORT $LN4@Buynode@2
	mov	cl, BYTE PTR __Carg$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR __Rarg$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Parg$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Larg$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T32263[ebp]
	call	??0_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBVCZString@Value@Json@@V23@@2@D@Z ; std::_Tree_nod<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Node::_Node
	mov	DWORD PTR tv93[ebp], eax
	mov	eax, DWORD PTR tv93[ebp]
	mov	DWORD PTR tv82[ebp], eax
	jmp	SHORT $LN5@Buynode@2
$LN4@Buynode@2:
	mov	DWORD PTR tv82[ebp], 0
$LN5@Buynode@2:
	mov	ecx, DWORD PTR tv82[ebp]
	mov	DWORD PTR $T32262[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+12], 0
	jmp	SHORT $LN6@Buynode@2
__catch$?_Buynode@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBVCZString@Value@Json@@V23@@2@D@Z$0:

; 1318 : 		_CATCH_ALL
; 1319 : 		this->_Alnod.deallocate(_Wherenode, 1);

	push	1
	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1
	call	?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Node>::deallocate

; 1320 : 		_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
	mov	eax, __tryend$?_Buynode@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBVCZString@Value@Json@@V23@@2@D@Z$1
	ret	0
$LN6@Buynode@2:

; 1321 : 		_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Buynode@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBVCZString@Value@Json@@V23@@2@D@Z$1:

; 1322 : 		return (_Wherenode);

	mov	eax, DWORD PTR __Wherenode$[ebp]
$LN3@Buynode@2:

; 1323 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Buynode@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBVCZString@Value@Json@@V23@@2@D@Z$2:
	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T32263[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$?_Buynode@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBVCZString@Value@Json@@V23@@2@D@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-44]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Buynode@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBVCZString@Value@Json@@V23@@2@D@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Buynode@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBVCZString@Value@Json@@V23@@2@D@Z ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Buynode
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 8\vc\include\new
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 59   : 	{	// construct array with placement at _Where

	push	ebp
	mov	ebp, esp

; 60   : 	return (_Where);

	mov	eax, DWORD PTR __Where$[ebp]

; 61   : 	}

	pop	ebp
	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 64   : 	{	// delete if placement new fails

	push	ebp
	mov	ebp, esp

; 65   : 	}

	pop	ebp
	ret	0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
PUBLIC	??$?0U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@1@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Node *>::allocator<std::_Tree_nod<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Node *><std::pair<Json::Value::CZString const ,Json::Value> >
PUBLIC	??0?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAE@ABU?$less@VCZString@Value@Json@@@1@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@1@@Z ; std::_Tree_nod<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Tree_nod<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 8\vc\include\xtree
;	COMDAT ??0?$_Tree_ptr@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAE@ABU?$less@VCZString@Value@Json@@@1@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 1
??0?$_Tree_ptr@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAE@ABU?$less@VCZString@Value@Json@@@1@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@1@@Z PROC ; std::_Tree_ptr<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Tree_ptr<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >, COMDAT
; _this$ = ecx

; 83   : 		{	// construct base, and allocator from _Al

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	call	??0?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >::allocator<std::pair<Json::Value::CZString const ,Json::Value> >
	mov	ecx, DWORD PTR __Parg$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAE@ABU?$less@VCZString@Value@Json@@@1@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@1@@Z ; std::_Tree_nod<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Tree_nod<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >
	lea	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2
	call	??$?0U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@1@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Node *>::allocator<std::_Tree_nod<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Node *><std::pair<Json::Value::CZString const ,Json::Value> >

; 84   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Tree_ptr@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAE@ABU?$less@VCZString@Value@Json@@@1@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@1@@Z ENDP ; std::_Tree_ptr<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Tree_ptr<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 8\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@QAE@ABV01@@Z PROC ; std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >::allocator<std::pair<Json::Value::CZString const ,Json::Value> >, COMDAT
; _this$ = ecx

; 124  : 	allocator(const allocator<_Ty>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 125  : 		{	// construct by copying (do nothing)
; 126  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >::allocator<std::pair<Json::Value::CZString const ,Json::Value> >
_TEXT	ENDS
PUBLIC	??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@@Z ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Node *>
; Function compile flags: /Odtp
;	COMDAT ?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Node *>::destroy, COMDAT
; _this$ = ecx

; 160  : 		{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 161  : 		_Destroy(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@@Z ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Node *>
	add	esp, 4

; 162  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Node *>::destroy
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 8\vc\include\xtree
_TEXT	ENDS
;	COMDAT ??Eiterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AV012@H@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Tmp$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??Eiterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AV012@H@Z PROC ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::iterator::operator++, COMDAT
; _this$ = ecx

; 466  : 			{	// postincrement

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 467  : 			iterator _Tmp = *this;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$[ebp], ecx
	mov	DWORD PTR __Tmp$[ebp+4], edx

; 468  : 			++*this;

	mov	ecx, DWORD PTR _this$[ebp]
	call	??Eiterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::iterator::operator++

; 469  : 			return (_Tmp);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR __Tmp$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR __Tmp$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 470  : 			}

	mov	esp, ebp
	pop	ebp
	ret	8
??Eiterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AV012@H@Z ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::iterator::operator++
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PBV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0const_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PBV12@@Z PROC ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator::const_iterator, COMDAT
; _this$ = ecx

; 224  : 			{	// construct with node pointer _Pnode

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Bidit@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@HPBU12@ABU12@@std@@QAE@XZ
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 225  : 			_SCL_SECURE_VALIDATE(_Plist != NULL);

	cmp	DWORD PTR __Plist$[ebp], 0
	jne	SHORT $LN1@const_iter
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN1@const_iter:

; 226  : 			this->_Mycont =_Plist;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Plist$[ebp]
	mov	DWORD PTR [edx], eax

; 227  : 			}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0const_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PBV12@@Z ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator::const_iterator
_TEXT	ENDS
PUBLIC	??$_Unchecked_move_backward@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@stdext@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@00@Z ; stdext::_Unchecked_move_backward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
PUBLIC	??$fill@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0ABV10@@Z ; std::fill<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??$_Umove@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PAV21@00@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Umove<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
PUBLIC	__$ArrayPad$
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 8\vc\include\vector
xdata$x	SEGMENT
__catchsym$?_Insert_n@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXV?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@IABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z$6 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXV?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@IABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z$2
__catchsym$?_Insert_n@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXV?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@IABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXV?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@IABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z$0
__ehfuncinfo$?_Insert_n@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXV?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@IABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$?_Insert_n@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXV?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@IABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Insert_n@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXV?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@IABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Insert_n@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXV?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@IABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXV?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@IABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z$5
	DD	03H
	DD	03H
	DD	04H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXV?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@IABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z$6
__unwindtable$?_Insert_n@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXV?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@IABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Insert_n@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXV?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@IABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z$4
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXV?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@IABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
_TEXT	SEGMENT
tv243 = -80						; size = 4
tv65 = -76						; size = 4
tv88 = -72						; size = 4
_this$ = -68						; size = 4
__Oldend$25983 = -64					; size = 4
__Newvec$25962 = -60					; size = 4
__Ptr$25963 = -56					; size = 4
__Capacity$ = -52					; size = 4
__Tmp$ = -48						; size = 28
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Where$ = 8						; size = 8
__Count$ = 16						; size = 4
__Val$ = 20						; size = 4
?_Insert_n@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXV?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@IABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Insert_n, COMDAT
; _this$ = ecx

; 1117 : 		{	// insert _Count * _Val at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Insert_n@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXV?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@IABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 64					; 00000040H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1118 : 
; 1119 :  #if _HAS_ITERATOR_DEBUGGING
; 1120 : 		if (_Where._Mycont != this
; 1121 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1122 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1123 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1124 : 
; 1125 : 		_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Tmp$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1126 : 		size_type _Capacity = capacity();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?capacity@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::capacity
	mov	DWORD PTR __Capacity$[ebp], eax

; 1127 : 
; 1128 : 		if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN12@Insert_n@3
	jmp	$LN11@Insert_n@3
$LN12@Insert_n@3:

; 1129 : 			;
; 1130 : 		else if (max_size() - size() < _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::max_size
	sub	eax, esi
	cmp	eax, DWORD PTR __Count$[ebp]
	jae	SHORT $LN10@Insert_n@3

; 1131 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@KAXXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Xlen
	jmp	$LN11@Insert_n@3
$LN10@Insert_n@3:

; 1132 : 		else if (_Capacity < size() + _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::size
	add	eax, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], eax
	jae	$LN8@Insert_n@3

; 1133 : 			{	// not enough room, reallocate
; 1134 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1135 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	esi, DWORD PTR __Capacity$[ebp]
	shr	esi, 1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::max_size
	sub	eax, esi
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN15@Insert_n@3
	mov	DWORD PTR tv88[ebp], 0
	jmp	SHORT $LN16@Insert_n@3
$LN15@Insert_n@3:
	mov	ecx, DWORD PTR __Capacity$[ebp]
	shr	ecx, 1
	add	ecx, DWORD PTR __Capacity$[ebp]
	mov	DWORD PTR tv88[ebp], ecx
$LN16@Insert_n@3:
	mov	edx, DWORD PTR tv88[ebp]
	mov	DWORD PTR __Capacity$[ebp], edx

; 1136 : 			if (_Capacity < size() + _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::size
	add	eax, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], eax
	jae	SHORT $LN7@Insert_n@3

; 1137 : 				_Capacity = size() + _Count;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::size
	add	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Capacity$[ebp], eax
$LN7@Insert_n@3:

; 1138 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

	mov	eax, DWORD PTR __Capacity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?allocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::allocate
	mov	DWORD PTR __Newvec$25962[ebp], eax

; 1139 : 			pointer _Ptr = _Newvec;

	mov	ecx, DWORD PTR __Newvec$25962[ebp]
	mov	DWORD PTR __Ptr$25963[ebp], ecx

; 1140 : 
; 1141 : 			_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 1

; 1142 : 			_Ptr = _Umove(_Myfirst, _VEC_ITER_BASE(_Where),
; 1143 : 				_Newvec);	// copy prefix

	mov	edx, DWORD PTR __Newvec$25962[ebp]
	push	edx
	mov	eax, DWORD PTR __Where$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PAV21@00@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Umove<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
	mov	DWORD PTR tv65[ebp], eax
	mov	eax, DWORD PTR tv65[ebp]
	mov	DWORD PTR __Ptr$25963[ebp], eax

; 1144 : 			_Ptr = _Ufill(_Ptr, _Count, _Tmp);	// add new stuff

	lea	ecx, DWORD PTR __Tmp$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Ptr$25963[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Ufill@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@PAV32@IABV32@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Ufill
	mov	DWORD PTR tv243[ebp], eax
	mov	ecx, DWORD PTR tv243[ebp]
	mov	DWORD PTR __Ptr$25963[ebp], ecx

; 1145 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast, _Ptr);	// copy suffix

	mov	edx, DWORD PTR __Ptr$25963[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp+4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PAV21@00@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Umove<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
	jmp	SHORT $LN17@Insert_n@3
__catch$?_Insert_n@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXV?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@IABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z$0:

; 1146 : 			_CATCH_ALL
; 1147 : 			_Destroy(_Newvec, _Ptr);

	mov	eax, DWORD PTR __Ptr$25963[ebp]
	push	eax
	mov	ecx, DWORD PTR __Newvec$25962[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Destroy

; 1148 : 			this->_Alval.deallocate(_Newvec, _Capacity);

	mov	edx, DWORD PTR __Capacity$[ebp]
	push	edx
	mov	eax, DWORD PTR __Newvec$25962[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?deallocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::deallocate

; 1149 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
	mov	eax, __tryend$?_Insert_n@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXV?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@IABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z$1
	ret	0
$LN17@Insert_n@3:

; 1150 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], 0
__tryend$?_Insert_n@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXV?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@IABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z$1:

; 1151 : 
; 1152 : 			_Count += size();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::size
	add	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Count$[ebp], eax

; 1153 : 			if (_Myfirst != 0)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+4], 0
	je	SHORT $LN5@Insert_n@3

; 1154 : 				{	// destroy and deallocate old array
; 1155 : 				_Destroy(_Myfirst, _Mylast);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Destroy

; 1156 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+12]
	sub	eax, DWORD PTR [ecx+4]
	cdq
	mov	ecx, 28					; 0000001cH
	idiv	ecx
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?deallocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::deallocate
$LN5@Insert_n@3:

; 1157 : 				}
; 1158 : 
; 1159 :  #if _HAS_ITERATOR_DEBUGGING
; 1160 : 			this->_Orphan_all();
; 1161 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1162 : 
; 1163 : 			_Myend = _Newvec + _Capacity;

	mov	ecx, DWORD PTR __Capacity$[ebp]
	imul	ecx, 28					; 0000001cH
	add	ecx, DWORD PTR __Newvec$25962[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], ecx

; 1164 : 			_Mylast = _Newvec + _Count;

	mov	eax, DWORD PTR __Count$[ebp]
	imul	eax, 28					; 0000001cH
	add	eax, DWORD PTR __Newvec$25962[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 1165 : 			_Myfirst = _Newvec;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Newvec$25962[ebp]
	mov	DWORD PTR [edx+4], eax
	jmp	$LN11@Insert_n@3
$LN8@Insert_n@3:

; 1166 : 			}
; 1167 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR __Where$[ebp+4]
	cdq
	mov	ecx, 28					; 0000001cH
	idiv	ecx
	cmp	eax, DWORD PTR __Count$[ebp]
	jae	$LN3@Insert_n@3

; 1168 : 			{	// new stuff spills off end
; 1169 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1170 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	mov	edx, DWORD PTR __Count$[ebp]
	imul	edx, 28					; 0000001cH
	add	edx, DWORD PTR __Where$[ebp+4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp+4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PAV21@00@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Umove<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>

; 1171 : 
; 1172 : 			_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 3

; 1173 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1174 : 				_Tmp);	// insert new stuff off end

	lea	eax, DWORD PTR __Tmp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR __Where$[ebp+4]
	cdq
	mov	ecx, 28					; 0000001cH
	idiv	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	sub	edx, eax
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Ufill@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@PAV32@IABV32@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Ufill
	jmp	SHORT $LN19@Insert_n@3
__catch$?_Insert_n@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXV?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@IABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z$2:

; 1175 : 			_CATCH_ALL
; 1176 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);

	mov	edx, DWORD PTR __Count$[ebp]
	imul	edx, 28					; 0000001cH
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+8]
	push	edx
	mov	ecx, DWORD PTR __Count$[ebp]
	imul	ecx, 28					; 0000001cH
	add	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Destroy

; 1177 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
	mov	eax, __tryend$?_Insert_n@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXV?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@IABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z$3
	ret	0
$LN19@Insert_n@3:

; 1178 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], 0
__tryend$?_Insert_n@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXV?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@IABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z$3:

; 1179 : 
; 1180 : 			_Mylast += _Count;

	mov	edx, DWORD PTR __Count$[ebp]
	imul	edx, 28					; 0000001cH
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], edx

; 1181 : 
; 1182 :  #if _HAS_ITERATOR_DEBUGGING
; 1183 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1184 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1185 : 
; 1186 : 			fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1187 : 				_Tmp);	// insert up to old end

	lea	edx, DWORD PTR __Tmp$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	imul	eax, 28					; 0000001cH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	sub	edx, eax
	push	edx
	mov	eax, DWORD PTR __Where$[ebp+4]
	push	eax
	call	??$fill@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0ABV10@@Z ; std::fill<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
	add	esp, 12					; 0000000cH

; 1188 : 			}
; 1189 : 		else

	jmp	SHORT $LN11@Insert_n@3
$LN3@Insert_n@3:

; 1190 : 			{	// new stuff can all be assigned
; 1191 : 			pointer _Oldend = _Mylast;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR __Oldend$25983[ebp], edx

; 1192 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1193 : 				_Mylast);	// copy suffix

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR __Oldend$25983[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	imul	eax, 28					; 0000001cH
	mov	ecx, DWORD PTR __Oldend$25983[ebp]
	sub	ecx, eax
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PAV21@00@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Umove<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], eax

; 1194 : 
; 1195 :  #if _HAS_ITERATOR_DEBUGGING
; 1196 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1197 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1198 : 
; 1199 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1200 : 				_Oldend);	// copy hole

	mov	eax, DWORD PTR __Oldend$25983[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	imul	ecx, 28					; 0000001cH
	mov	edx, DWORD PTR __Oldend$25983[ebp]
	sub	edx, ecx
	push	edx
	mov	eax, DWORD PTR __Where$[ebp+4]
	push	eax
	call	??$_Unchecked_move_backward@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@stdext@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@00@Z ; stdext::_Unchecked_move_backward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
	add	esp, 12					; 0000000cH

; 1201 : 			fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1202 : 				_Tmp);	// insert into hole

	lea	ecx, DWORD PTR __Tmp$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	imul	edx, 28					; 0000001cH
	add	edx, DWORD PTR __Where$[ebp+4]
	push	edx
	mov	eax, DWORD PTR __Where$[ebp+4]
	push	eax
	call	??$fill@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0ABV10@@Z ; std::fill<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
	add	esp, 12					; 0000000cH
$LN11@Insert_n@3:

; 1203 : 			}
; 1204 : 		}

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	lea	ecx, DWORD PTR __Tmp$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN14@Insert_n@3:
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Insert_n@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXV?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@IABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z$4:
	lea	ecx, DWORD PTR __Tmp$[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?_Insert_n@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXV?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@IABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-84]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Insert_n@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXV?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@IABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert_n@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXV?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@IABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Insert_n
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 8\vc\include\xmemory
;	COMDAT ?max_size@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
tv65 = -12						; size = 4
_this$ = -8						; size = 4
__Count$ = -4						; size = 4
?max_size@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QBEIXZ PROC ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::max_size, COMDAT
; _this$ = ecx

; 165  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 166  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);

	mov	DWORD PTR __Count$[ebp], 153391689	; 09249249H

; 167  : 		return (0 < _Count ? _Count : 1);

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN3@max_size
	mov	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR tv65[ebp], eax
	jmp	SHORT $LN4@max_size
$LN3@max_size:
	mov	DWORD PTR tv65[ebp], 1
$LN4@max_size:
	mov	eax, DWORD PTR tv65[ebp]

; 168  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QBEIXZ ENDP ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::max_size
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 8\vc\include\vector
_TEXT	ENDS
;	COMDAT ??0?$_Vector_iterator@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QAE@PAPBVPathArgument@Json@@PBU_Container_base@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QAE@PAPBVPathArgument@Json@@PBU_Container_base@1@@Z PROC ; std::_Vector_iterator<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::_Vector_iterator<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >, COMDAT
; _this$ = ecx

; 314  : 		{	// construct with pointer _Ptr

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Pvector$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_const_iterator@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QAE@PAPBVPathArgument@Json@@PBU_Container_base@1@@Z ; std::_Vector_const_iterator<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::_Vector_const_iterator<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >

; 315  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_iterator@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QAE@PAPBVPathArgument@Json@@PBU_Container_base@1@@Z ENDP ; std::_Vector_iterator<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::_Vector_iterator<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >
_TEXT	ENDS
PUBLIC	??Y?$_Vector_iterator@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::operator+=
; Function compile flags: /Odtp
;	COMDAT ??H?$_Vector_iterator@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Tmp$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::operator+, COMDAT
; _this$ = ecx

; 367  : 		{	// return this + integer

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 368  : 		_Myt _Tmp = *this;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$[ebp], ecx
	mov	DWORD PTR __Tmp$[ebp+4], edx

; 369  : 		return (_Tmp += _Off);

	mov	eax, DWORD PTR __Off$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Tmp$[ebp]
	call	??Y?$_Vector_iterator@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::operator+=
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 370  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??H?$_Vector_iterator@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::operator+
_TEXT	ENDS
PUBLIC	??G?$_Vector_const_iterator@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QBEHABV01@@Z ; std::_Vector_const_iterator<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::operator-
; Function compile flags: /Odtp
;	COMDAT ??G?$_Vector_iterator@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QBEHABV?$_Vector_const_iterator@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??G?$_Vector_iterator@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QBEHABV?$_Vector_const_iterator@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@1@@Z PROC ; std::_Vector_iterator<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::operator-, COMDAT
; _this$ = ecx

; 384  : 		{	// return difference of iterators

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 385  : 		return (*(_Mybase *)this - _Right);

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??G?$_Vector_const_iterator@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QBEHABV01@@Z ; std::_Vector_const_iterator<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::operator-

; 386  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??G?$_Vector_iterator@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QBEHABV?$_Vector_const_iterator@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@1@@Z ENDP ; std::_Vector_iterator<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::operator-
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0?$_Vector_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAE@PAVPathArgument@Json@@PBU_Container_base@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAE@PAVPathArgument@Json@@PBU_Container_base@1@@Z PROC ; std::_Vector_iterator<Json::PathArgument,std::allocator<Json::PathArgument> >::_Vector_iterator<Json::PathArgument,std::allocator<Json::PathArgument> >, COMDAT
; _this$ = ecx

; 314  : 		{	// construct with pointer _Ptr

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Pvector$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_const_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAE@PAVPathArgument@Json@@PBU_Container_base@1@@Z ; std::_Vector_const_iterator<Json::PathArgument,std::allocator<Json::PathArgument> >::_Vector_const_iterator<Json::PathArgument,std::allocator<Json::PathArgument> >

; 315  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAE@PAVPathArgument@Json@@PBU_Container_base@1@@Z ENDP ; std::_Vector_iterator<Json::PathArgument,std::allocator<Json::PathArgument> >::_Vector_iterator<Json::PathArgument,std::allocator<Json::PathArgument> >
_TEXT	ENDS
PUBLIC	??Y?$_Vector_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<Json::PathArgument,std::allocator<Json::PathArgument> >::operator+=
; Function compile flags: /Odtp
;	COMDAT ??H?$_Vector_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Tmp$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<Json::PathArgument,std::allocator<Json::PathArgument> >::operator+, COMDAT
; _this$ = ecx

; 367  : 		{	// return this + integer

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 368  : 		_Myt _Tmp = *this;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$[ebp], ecx
	mov	DWORD PTR __Tmp$[ebp+4], edx

; 369  : 		return (_Tmp += _Off);

	mov	eax, DWORD PTR __Off$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Tmp$[ebp]
	call	??Y?$_Vector_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<Json::PathArgument,std::allocator<Json::PathArgument> >::operator+=
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 370  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??H?$_Vector_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<Json::PathArgument,std::allocator<Json::PathArgument> >::operator+
_TEXT	ENDS
PUBLIC	??G?$_Vector_const_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBEHABV01@@Z ; std::_Vector_const_iterator<Json::PathArgument,std::allocator<Json::PathArgument> >::operator-
; Function compile flags: /Odtp
;	COMDAT ??G?$_Vector_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBEHABV?$_Vector_const_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??G?$_Vector_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBEHABV?$_Vector_const_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@1@@Z PROC ; std::_Vector_iterator<Json::PathArgument,std::allocator<Json::PathArgument> >::operator-, COMDAT
; _this$ = ecx

; 384  : 		{	// return difference of iterators

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 385  : 		return (*(_Mybase *)this - _Right);

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??G?$_Vector_const_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBEHABV01@@Z ; std::_Vector_const_iterator<Json::PathArgument,std::allocator<Json::PathArgument> >::operator-

; 386  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??G?$_Vector_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBEHABV?$_Vector_const_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@1@@Z ENDP ; std::_Vector_iterator<Json::PathArgument,std::allocator<Json::PathArgument> >::operator-
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 8\vc\include\utility
_TEXT	ENDS
;	COMDAT ??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@1@AB_N@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@1@AB_N@Z PROC ; std::pair<std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::iterator,bool>::pair<std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::iterator,bool>, COMDAT
; _this$ = ecx

; 37   : 		{	// construct from specified values

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Val1$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Val2$[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR [ecx+8], al

; 38   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@1@AB_N@Z ENDP ; std::pair<std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::iterator,bool>::pair<std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::iterator,bool>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@V123@@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@1@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@V123@@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@1@0@Z PROC ; std::pair<std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::iterator,std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::iterator>::pair<std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::iterator,std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::iterator>, COMDAT
; _this$ = ecx

; 37   : 		{	// construct from specified values

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Val1$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR __Val2$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], edx
	mov	DWORD PTR [ecx+12], eax

; 38   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@V123@@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@1@0@Z ENDP ; std::pair<std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::iterator,std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::iterator>::pair<std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::iterator,std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::iterator>
_TEXT	ENDS
PUBLIC	??0?$_Ranit@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HPBV12@ABV12@@std@@QAE@XZ ; std::_Ranit<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::basic_string<char,std::char_traits<char>,std::allocator<char> > const *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>::_Ranit<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::basic_string<char,std::char_traits<char>,std::allocator<char> > const *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 8\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PBU_Container_base@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PBU_Container_base@1@@Z PROC ; std::_Vector_const_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Vector_const_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT
; _this$ = ecx

; 77   : 	_Vector_const_iterator(_Tptr _Ptr, const _Container_base *_Pvector)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Ranit@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HPBV12@ABV12@@std@@QAE@XZ

; 78   : 		{	// construct with pointer _Ptr
; 79   : 		_SCL_SECURE_VALIDATE(_Pvector != NULL && ((_Myvec *)_Pvector)->_Myfirst <= _Ptr && _Ptr <= ((_Myvec *)_Pvector)->_Mylast);

	cmp	DWORD PTR __Pvector$[ebp], 0
	je	SHORT $LN1@Vector_con@3
	mov	eax, DWORD PTR __Pvector$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, DWORD PTR __Ptr$[ebp]
	ja	SHORT $LN1@Vector_con@3
	mov	edx, DWORD PTR __Pvector$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	cmp	eax, DWORD PTR [edx+8]
	jbe	SHORT $LN2@Vector_con@3
$LN1@Vector_con@3:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@Vector_con@3:

; 80   : 		this->_Mycont = _Pvector;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Pvector$[ebp]
	mov	DWORD PTR [ecx], edx

; 81   : 		_Myptr = _Ptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 82   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PBU_Container_base@1@@Z ENDP ; std::_Vector_const_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Vector_const_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PBU_Container_base@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PBU_Container_base@1@@Z PROC ; std::_Vector_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Vector_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT
; _this$ = ecx

; 314  : 		{	// construct with pointer _Ptr

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Pvector$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PBU_Container_base@1@@Z ; std::_Vector_const_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Vector_const_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >

; 315  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PBU_Container_base@1@@Z ENDP ; std::_Vector_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Vector_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
PUBLIC	??Y?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::operator+=
; Function compile flags: /Odtp
;	COMDAT ??H?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Tmp$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::operator+, COMDAT
; _this$ = ecx

; 367  : 		{	// return this + integer

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 368  : 		_Myt _Tmp = *this;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$[ebp], ecx
	mov	DWORD PTR __Tmp$[ebp+4], edx

; 369  : 		return (_Tmp += _Off);

	mov	eax, DWORD PTR __Off$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Tmp$[ebp]
	call	??Y?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::operator+=
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 370  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??H?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::operator+
_TEXT	ENDS
PUBLIC	??G?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEHABV01@@Z ; std::_Vector_const_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::operator-
; Function compile flags: /Odtp
;	COMDAT ??G?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEHABV?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??G?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEHABV?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@1@@Z PROC ; std::_Vector_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::operator-, COMDAT
; _this$ = ecx

; 384  : 		{	// return difference of iterators

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 385  : 		return (*(_Mybase *)this - _Right);

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??G?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEHABV01@@Z ; std::_Vector_const_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::operator-

; 386  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??G?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEHABV?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@1@@Z ENDP ; std::_Vector_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::operator-
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0PathArgument@Json@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0PathArgument@Json@@QAE@ABV01@@Z PROC			; Json::PathArgument::PathArgument, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	DWORD PTR [ecx+28], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	DWORD PTR [ecx+32], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0PathArgument@Json@@QAE@ABV01@@Z ENDP			; Json::PathArgument::PathArgument
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0?$_Ranit@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HPBV12@ABV12@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Ranit@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HPBV12@ABV12@@std@@QAE@XZ PROC ; std::_Ranit<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::basic_string<char,std::char_traits<char>,std::allocator<char> > const *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>::_Ranit<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::basic_string<char,std::char_traits<char>,std::allocator<char> > const *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Iterator_base@std@@QAE@XZ		; std::_Iterator_base::_Iterator_base
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Ranit@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@HPBV12@ABV12@@std@@QAE@XZ ENDP ; std::_Ranit<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::basic_string<char,std::char_traits<char>,std::allocator<char> > const *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>::_Ranit<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int,std::basic_string<char,std::char_traits<char>,std::allocator<char> > const *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 8\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@PBVPathArgument@Json@@@std@@QBEIXZ
_TEXT	SEGMENT
tv65 = -12						; size = 4
_this$ = -8						; size = 4
__Count$ = -4						; size = 4
?max_size@?$allocator@PBVPathArgument@Json@@@std@@QBEIXZ PROC ; std::allocator<Json::PathArgument const *>::max_size, COMDAT
; _this$ = ecx

; 165  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 166  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);

	mov	DWORD PTR __Count$[ebp], 1073741823	; 3fffffffH

; 167  : 		return (0 < _Count ? _Count : 1);

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN3@max_size@2
	mov	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR tv65[ebp], eax
	jmp	SHORT $LN4@max_size@2
$LN3@max_size@2:
	mov	DWORD PTR tv65[ebp], 1
$LN4@max_size@2:
	mov	eax, DWORD PTR tv65[ebp]

; 168  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator@PBVPathArgument@Json@@@std@@QBEIXZ ENDP ; std::allocator<Json::PathArgument const *>::max_size
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@VPathArgument@Json@@@std@@QBEIXZ
_TEXT	SEGMENT
tv65 = -12						; size = 4
_this$ = -8						; size = 4
__Count$ = -4						; size = 4
?max_size@?$allocator@VPathArgument@Json@@@std@@QBEIXZ PROC ; std::allocator<Json::PathArgument>::max_size, COMDAT
; _this$ = ecx

; 165  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 166  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);

	mov	DWORD PTR __Count$[ebp], 119304647	; 071c71c7H

; 167  : 		return (0 < _Count ? _Count : 1);

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN3@max_size@3
	mov	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR tv65[ebp], eax
	jmp	SHORT $LN4@max_size@3
$LN3@max_size@3:
	mov	DWORD PTR tv65[ebp], 1
$LN4@max_size@3:
	mov	eax, DWORD PTR tv65[ebp]

; 168  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator@VPathArgument@Json@@@std@@QBEIXZ ENDP ; std::allocator<Json::PathArgument>::max_size
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 8\vc\include\xtree
_TEXT	ENDS
;	COMDAT ?_Ubound@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@ABVCZString@Value@Json@@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Pnode$ = -8						; size = 4
__Wherenode$ = -4					; size = 4
__Keyval$ = 8						; size = 4
?_Ubound@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@ABVCZString@Value@Json@@@Z PROC ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Ubound, COMDAT
; _this$ = ecx

; 1255 : 		{	// find leftmost node greater than _Keyval

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1256 : 		_Nodeptr _Pnode = _Root();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Root
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], eax

; 1257 : 		_Nodeptr _Wherenode = _Myhead;	// end() if search fails

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR __Wherenode$[ebp], edx
$LN4@Ubound:

; 1258 : 
; 1259 : 		while (!_Isnil(_Pnode))

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Isnil
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN3@Ubound

; 1260 : 			if (_DEBUG_LT_PRED(this->comp, _Keyval, _Key(_Pnode)))

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Key@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAABVCZString@Value@Json@@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Key
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR __Keyval$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??R?$less@VCZString@Value@Json@@@std@@QBE_NABVCZString@Value@Json@@0@Z ; std::less<Json::Value::CZString>::operator()
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@Ubound

; 1261 : 				{	// _Pnode greater than _Keyval, remember it
; 1262 : 				_Wherenode = _Pnode;

	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR __Wherenode$[ebp], edx

; 1263 : 				_Pnode = _Left(_Pnode);	// descend left subtree

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], ecx

; 1264 : 				}
; 1265 : 			else

	jmp	SHORT $LN1@Ubound
$LN2@Ubound:

; 1266 : 				_Pnode = _Right(_Pnode);	// descend right subtree

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Right
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], eax
$LN1@Ubound:
	jmp	SHORT $LN4@Ubound
$LN3@Ubound:

; 1267 : 
; 1268 : 		return (_Wherenode);	// return best remembered candidate

	mov	eax, DWORD PTR __Wherenode$[ebp]

; 1269 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Ubound@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@ABVCZString@Value@Json@@@Z ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Ubound
_TEXT	ENDS
PUBLIC	??$?0U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@1@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Node><std::pair<Json::Value::CZString const ,Json::Value> >
PUBLIC	??0?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@QAE@U?$less@VCZString@Value@Json@@@1@@Z ; std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0>::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0>
; Function compile flags: /Odtp
;	COMDAT ??0?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAE@ABU?$less@VCZString@Value@Json@@@1@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 1
??0?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAE@ABU?$less@VCZString@Value@Json@@@1@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@1@@Z PROC ; std::_Tree_nod<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Tree_nod<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >, COMDAT
; _this$ = ecx

; 57   : 		{	// construct traits from _Parg and allocator from _Al

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Parg$[ebp]
	mov	cl, BYTE PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@QAE@U?$less@VCZString@Value@Json@@@1@@Z ; std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0>::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0>
	lea	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1
	call	??$?0U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@1@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Node><std::pair<Json::Value::CZString const ,Json::Value> >

; 58   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAE@ABU?$less@VCZString@Value@Json@@@1@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@1@@Z ENDP ; std::_Tree_nod<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Tree_nod<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 8\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
tv65 = -12						; size = 4
_this$ = -8						; size = 4
__Count$ = -4						; size = 4
?max_size@?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@QBEIXZ PROC ; std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >::max_size, COMDAT
; _this$ = ecx

; 165  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 166  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);

	mov	DWORD PTR __Count$[ebp], 178956970	; 0aaaaaaaH

; 167  : 		return (0 < _Count ? _Count : 1);

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN3@max_size@4
	mov	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR tv65[ebp], eax
	jmp	SHORT $LN4@max_size@4
$LN3@max_size@4:
	mov	DWORD PTR tv65[ebp], 1
$LN4@max_size@4:
	mov	eax, DWORD PTR tv65[ebp]

; 168  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@QBEIXZ ENDP ; std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >::max_size
_TEXT	ENDS
PUBLIC	??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@IPAU120@@Z ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Node>
; Function compile flags: /Odtp
;	COMDAT ?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@I@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Node>::allocate, COMDAT
; _this$ = ecx

; 145  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 146  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@IPAU120@@Z ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Node>
	add	esp, 8

; 147  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@I@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Node>::allocate
_TEXT	ENDS
PUBLIC	??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@ABQAU120@@Z ; std::_Construct<std::_Tree_nod<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Node *,std::_Tree_nod<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Node *>
; Function compile flags: /Odtp
;	COMDAT ?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@ABQAU342@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@ABQAU342@@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Node *>::construct, COMDAT
; _this$ = ecx

; 155  : 		{	// construct object at _Ptr with value _Val

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 156  : 		_Construct(_Ptr, _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	call	??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@ABQAU120@@Z ; std::_Construct<std::_Tree_nod<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Node *,std::_Tree_nod<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Node *>
	add	esp, 8

; 157  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@ABQAU342@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Node *>::construct
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 8\vc\include\vector
_TEXT	ENDS
;	COMDAT ??G?$_Vector_const_iterator@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QBEHABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??G?$_Vector_const_iterator@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QBEHABV01@@Z PROC ; std::_Vector_const_iterator<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::operator-, COMDAT
; _this$ = ecx

; 173  : 		{	// return difference of iterators

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 174  : 
; 175  :  #if _HAS_ITERATOR_DEBUGGING
; 176  : 		_Compat(_Right);
; 177  :  #else
; 178  : 		_SCL_SECURE_VALIDATE(this->_Mycont != NULL && this->_Mycont == _Right._Mycont);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN1@operator@15
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [edx]
	je	SHORT $LN2@operator@15
$LN1@operator@15:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator@15:

; 179  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 180  : 
; 181  : 		return (_Myptr - _Right._Myptr);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	sub	eax, DWORD PTR [edx+4]
	sar	eax, 2

; 182  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??G?$_Vector_const_iterator@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QBEHABV01@@Z ENDP ; std::_Vector_const_iterator<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::operator-
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??G?$_Vector_const_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBEHABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??G?$_Vector_const_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBEHABV01@@Z PROC ; std::_Vector_const_iterator<Json::PathArgument,std::allocator<Json::PathArgument> >::operator-, COMDAT
; _this$ = ecx

; 173  : 		{	// return difference of iterators

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 174  : 
; 175  :  #if _HAS_ITERATOR_DEBUGGING
; 176  : 		_Compat(_Right);
; 177  :  #else
; 178  : 		_SCL_SECURE_VALIDATE(this->_Mycont != NULL && this->_Mycont == _Right._Mycont);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN1@operator@16
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [edx]
	je	SHORT $LN2@operator@16
$LN1@operator@16:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator@16:

; 179  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 180  : 
; 181  : 		return (_Myptr - _Right._Myptr);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	sub	eax, DWORD PTR [edx+4]
	cdq
	mov	ecx, 36					; 00000024H
	idiv	ecx

; 182  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??G?$_Vector_const_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBEHABV01@@Z ENDP ; std::_Vector_const_iterator<Json::PathArgument,std::allocator<Json::PathArgument> >::operator-
_TEXT	ENDS
PUBLIC	??Y?$_Vector_const_iterator@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::operator+=
; Function compile flags: /Odtp
;	COMDAT ??Y?$_Vector_iterator@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::operator+=, COMDAT
; _this$ = ecx

; 361  : 		{	// increment by integer

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 362  : 		(*(_Mybase *)this) += _Off;

	mov	eax, DWORD PTR __Off$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??Y?$_Vector_const_iterator@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::operator+=

; 363  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 364  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??Y?$_Vector_iterator@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::operator+=
_TEXT	ENDS
PUBLIC	??Y?$_Vector_const_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<Json::PathArgument,std::allocator<Json::PathArgument> >::operator+=
; Function compile flags: /Odtp
;	COMDAT ??Y?$_Vector_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<Json::PathArgument,std::allocator<Json::PathArgument> >::operator+=, COMDAT
; _this$ = ecx

; 361  : 		{	// increment by integer

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 362  : 		(*(_Mybase *)this) += _Off;

	mov	eax, DWORD PTR __Off$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??Y?$_Vector_const_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<Json::PathArgument,std::allocator<Json::PathArgument> >::operator+=

; 363  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 364  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??Y?$_Vector_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<Json::PathArgument,std::allocator<Json::PathArgument> >::operator+=
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??G?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEHABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??G?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEHABV01@@Z PROC ; std::_Vector_const_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::operator-, COMDAT
; _this$ = ecx

; 173  : 		{	// return difference of iterators

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 174  : 
; 175  :  #if _HAS_ITERATOR_DEBUGGING
; 176  : 		_Compat(_Right);
; 177  :  #else
; 178  : 		_SCL_SECURE_VALIDATE(this->_Mycont != NULL && this->_Mycont == _Right._Mycont);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN1@operator@17
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [edx]
	je	SHORT $LN2@operator@17
$LN1@operator@17:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator@17:

; 179  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 180  : 
; 181  : 		return (_Myptr - _Right._Myptr);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	sub	eax, DWORD PTR [edx+4]
	cdq
	mov	ecx, 28					; 0000001cH
	idiv	ecx

; 182  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??G?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEHABV01@@Z ENDP ; std::_Vector_const_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::operator-
_TEXT	ENDS
PUBLIC	??Y?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::operator+=
; Function compile flags: /Odtp
;	COMDAT ??Y?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::operator+=, COMDAT
; _this$ = ecx

; 361  : 		{	// increment by integer

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 362  : 		(*(_Mybase *)this) += _Off;

	mov	eax, DWORD PTR __Off$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??Y?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::operator+=

; 363  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 364  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??Y?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::operator+=
_TEXT	ENDS
PUBLIC	??0?$pair@$$CBVCZString@Value@Json@@V23@@std@@QAE@ABU01@@Z ; std::pair<Json::Value::CZString const ,Json::Value>::pair<Json::Value::CZString const ,Json::Value>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 8\vc\include\xtree
;	COMDAT ??0_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBVCZString@Value@Json@@V23@@2@D@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Larg$ = 8						; size = 4
__Parg$ = 12						; size = 4
__Rarg$ = 16						; size = 4
__Val$ = 20						; size = 4
__Carg$ = 24						; size = 1
??0_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBVCZString@Value@Json@@V23@@2@D@Z PROC ; std::_Tree_nod<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Node::_Node, COMDAT
; _this$ = ecx

; 43   : 			{	// construct a node with value

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Larg$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Parg$[ebp]
	mov	DWORD PTR [edx+4], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Rarg$[ebp]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??0?$pair@$$CBVCZString@Value@Json@@V23@@std@@QAE@ABU01@@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR __Carg$[ebp]
	mov	BYTE PTR [ecx+40], dl
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+41], 0

; 44   : 			}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
??0_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBVCZString@Value@Json@@V23@@2@D@Z ENDP ; std::_Tree_nod<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Node::_Node
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$pair@$$CBVCZString@Value@Json@@V23@@std@@QAE@ABU01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$pair@$$CBVCZString@Value@Json@@V23@@std@@QAE@ABU01@@Z$0
__ehfuncinfo$??0?$pair@$$CBVCZString@Value@Json@@V23@@std@@QAE@ABU01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$pair@$$CBVCZString@Value@Json@@V23@@std@@QAE@ABU01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$pair@$$CBVCZString@Value@Json@@V23@@std@@QAE@ABU01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0?$pair@$$CBVCZString@Value@Json@@V23@@std@@QAE@ABU01@@Z PROC ; std::pair<Json::Value::CZString const ,Json::Value>::pair<Json::Value::CZString const ,Json::Value>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$pair@$$CBVCZString@Value@Json@@V23@@std@@QAE@ABU01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0CZString@Value@Json@@QAE@ABV012@@Z	; Json::Value::CZString::CZString
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, 8
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??0Value@Json@@QAE@ABV01@@Z		; Json::Value::Value
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$pair@$$CBVCZString@Value@Json@@V23@@std@@QAE@ABU01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1CZString@Value@Json@@QAE@XZ		; Json::Value::CZString::~CZString
__ehhandler$??0?$pair@$$CBVCZString@Value@Json@@V23@@std@@QAE@ABU01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$pair@$$CBVCZString@Value@Json@@V23@@std@@QAE@ABU01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$pair@$$CBVCZString@Value@Json@@V23@@std@@QAE@ABU01@@Z ENDP ; std::pair<Json::Value::CZString const ,Json::Value>::pair<Json::Value::CZString const ,Json::Value>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 8\vc\include\map
;	COMDAT ??0?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@QAE@U?$less@VCZString@Value@Json@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Parg$ = 8						; size = 1
??0?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@QAE@U?$less@VCZString@Value@Json@@@1@@Z PROC ; std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0>::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0>, COMDAT
; _this$ = ecx

; 43   : 		{	// construct with specified comparator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 44   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@QAE@U?$less@VCZString@Value@Json@@@1@@Z ENDP ; std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0>::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 8\vc\include\vector
_TEXT	ENDS
;	COMDAT ??Y?$_Vector_const_iterator@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::operator+=, COMDAT
; _this$ = ecx

; 146  : 		{	// increment by integer

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 147  : 		_SCL_SECURE_VALIDATE(this->_Mycont != NULL);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN3@operator@18
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN3@operator@18:

; 148  : 		_SCL_SECURE_VALIDATE_RANGE(

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR __Off$[ebp]
	lea	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	cmp	ecx, DWORD PTR [eax+8]
	ja	SHORT $LN1@operator@18
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR __Off$[ebp]
	lea	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	cmp	ecx, DWORD PTR [eax+4]
	jae	SHORT $LN2@operator@18
$LN1@operator@18:

; 149  : 			_Myptr + _Off <= ((_Myvec *)(this->_Mycont))->_Mylast &&
; 150  : 			_Myptr + _Off >= ((_Myvec *)(this->_Mycont))->_Myfirst);

	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator@18:

; 151  : 		_Myptr += _Off;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR __Off$[ebp]
	lea	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 152  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 153  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??Y?$_Vector_const_iterator@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::operator+=
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??Y?$_Vector_const_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<Json::PathArgument,std::allocator<Json::PathArgument> >::operator+=, COMDAT
; _this$ = ecx

; 146  : 		{	// increment by integer

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 147  : 		_SCL_SECURE_VALIDATE(this->_Mycont != NULL);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN3@operator@19
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN3@operator@19:

; 148  : 		_SCL_SECURE_VALIDATE_RANGE(

	mov	ecx, DWORD PTR __Off$[ebp]
	imul	ecx, 36					; 00000024H
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR [edx+8]
	ja	SHORT $LN1@operator@19
	mov	eax, DWORD PTR __Off$[ebp]
	imul	eax, 36					; 00000024H
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	cmp	eax, DWORD PTR [ecx+4]
	jae	SHORT $LN2@operator@19
$LN1@operator@19:

; 149  : 			_Myptr + _Off <= ((_Myvec *)(this->_Mycont))->_Mylast &&
; 150  : 			_Myptr + _Off >= ((_Myvec *)(this->_Mycont))->_Myfirst);

	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator@19:

; 151  : 		_Myptr += _Off;

	mov	edx, DWORD PTR __Off$[ebp]
	imul	edx, 36					; 00000024H
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], edx

; 152  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 153  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??Y?$_Vector_const_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<Json::PathArgument,std::allocator<Json::PathArgument> >::operator+=
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??Y?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::operator+=, COMDAT
; _this$ = ecx

; 146  : 		{	// increment by integer

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 147  : 		_SCL_SECURE_VALIDATE(this->_Mycont != NULL);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN3@operator@20
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN3@operator@20:

; 148  : 		_SCL_SECURE_VALIDATE_RANGE(

	mov	ecx, DWORD PTR __Off$[ebp]
	imul	ecx, 28					; 0000001cH
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR [edx+8]
	ja	SHORT $LN1@operator@20
	mov	eax, DWORD PTR __Off$[ebp]
	imul	eax, 28					; 0000001cH
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx]
	cmp	eax, DWORD PTR [ecx+4]
	jae	SHORT $LN2@operator@20
$LN1@operator@20:

; 149  : 			_Myptr + _Off <= ((_Myvec *)(this->_Mycont))->_Mylast &&
; 150  : 			_Myptr + _Off >= ((_Myvec *)(this->_Mycont))->_Myfirst);

	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator@20:

; 151  : 		_Myptr += _Off;

	mov	edx, DWORD PTR __Off$[ebp]
	imul	edx, 28					; 0000001cH
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], edx

; 152  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 153  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??Y?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::operator+=
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 8\vc\include\utility
_TEXT	ENDS
;	COMDAT ??$swap@PBD@std@@YAXAAPBD0@Z
_TEXT	SEGMENT
__Tmp$ = -4						; size = 4
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@PBD@std@@YAXAAPBD0@Z PROC			; std::swap<char const *>, COMDAT

; 17   : 	{	// exchange values stored at _Left and _Right

	push	ebp
	mov	ebp, esp
	push	ecx

; 18   : 	_Ty _Tmp = _Left;

	mov	eax, DWORD PTR __Left$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Tmp$[ebp], ecx

; 19   : 	_Left = _Right, _Right = _Tmp;

	mov	edx, DWORD PTR __Left$[ebp]
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR __Tmp$[ebp]
	mov	DWORD PTR [edx], eax

; 20   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$swap@PBD@std@@YAXAAPBD0@Z ENDP			; std::swap<char const *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$swap@H@std@@YAXAAH0@Z
_TEXT	SEGMENT
__Tmp$ = -4						; size = 4
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@H@std@@YAXAAH0@Z PROC				; std::swap<int>, COMDAT

; 17   : 	{	// exchange values stored at _Left and _Right

	push	ebp
	mov	ebp, esp
	push	ecx

; 18   : 	_Ty _Tmp = _Left;

	mov	eax, DWORD PTR __Left$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Tmp$[ebp], ecx

; 19   : 	_Left = _Right, _Right = _Tmp;

	mov	edx, DWORD PTR __Left$[ebp]
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR __Tmp$[ebp]
	mov	DWORD PTR [edx], eax

; 20   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$swap@H@std@@YAXAAH0@Z ENDP				; std::swap<int>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$swap@TValueHolder@Value@Json@@@std@@YAXAATValueHolder@Value@Json@@0@Z
_TEXT	SEGMENT
__Tmp$ = -8						; size = 8
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@TValueHolder@Value@Json@@@std@@YAXAATValueHolder@Value@Json@@0@Z PROC ; std::swap<Json::Value::ValueHolder>, COMDAT

; 17   : 	{	// exchange values stored at _Left and _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 18   : 	_Ty _Tmp = _Left;

	mov	eax, DWORD PTR __Left$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$[ebp], ecx
	mov	DWORD PTR __Tmp$[ebp+4], edx

; 19   : 	_Left = _Right, _Right = _Tmp;

	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR __Left$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR __Tmp$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR __Tmp$[ebp+4]
	mov	DWORD PTR [ecx+4], eax

; 20   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$swap@TValueHolder@Value@Json@@@std@@YAXAATValueHolder@Value@Json@@0@Z ENDP ; std::swap<Json::Value::ValueHolder>
_TEXT	ENDS
PUBLIC	??$lexicographical_compare@Vconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@V123@@std@@YA_NVconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@000@Z ; std::lexicographical_compare<std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator,std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator>
PUBLIC	?begin@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBE?AVconst_iterator@12@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::begin
PUBLIC	?end@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBE?AVconst_iterator@12@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::end
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 8\vc\include\xtree
;	COMDAT ??$?MV?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@YA_NABV?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@0@Z
_TEXT	SEGMENT
$T32414 = -32						; size = 8
$T32413 = -24						; size = 8
$T32412 = -16						; size = 8
$T32411 = -8						; size = 8
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$?MV?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@YA_NABV?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@0@Z PROC ; std::operator<<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >, COMDAT

; 1373 : 	{	// test if _Less < _Right for _Trees

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H

; 1374 : 	return (lexicographical_compare(_Left.begin(), _Left.end(),
; 1375 : 		_Right.begin(), _Right.end()));

	lea	eax, DWORD PTR $T32411[ebp]
	push	eax
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?end@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBE?AVconst_iterator@12@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::end
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	lea	eax, DWORD PTR $T32412[ebp]
	push	eax
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?begin@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBE?AVconst_iterator@12@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::begin
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	lea	eax, DWORD PTR $T32413[ebp]
	push	eax
	mov	ecx, DWORD PTR __Left$[ebp]
	call	?end@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBE?AVconst_iterator@12@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::end
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	lea	eax, DWORD PTR $T32414[ebp]
	push	eax
	mov	ecx, DWORD PTR __Left$[ebp]
	call	?begin@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBE?AVconst_iterator@12@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::begin
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	call	??$lexicographical_compare@Vconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@V123@@std@@YA_NVconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@000@Z ; std::lexicographical_compare<std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator,std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator>
	add	esp, 32					; 00000020H

; 1376 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$?MV?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@YA_NABV?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@0@Z ENDP ; std::operator<<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >
_TEXT	ENDS
PUBLIC	??$equal@Vconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@V123@@std@@YA_NVconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@00@Z ; std::equal<std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator,std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator>
; Function compile flags: /Odtp
;	COMDAT ??$?8V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@YA_NABV?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@0@Z
_TEXT	SEGMENT
tv84 = -28						; size = 4
$T32419 = -24						; size = 8
$T32418 = -16						; size = 8
$T32417 = -8						; size = 8
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$?8V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@YA_NABV?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@0@Z PROC ; std::operator==<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >, COMDAT

; 1360 : 	{	// test for _Tree equality

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	push	esi

; 1361 : 	return (_Left.size() == _Right.size()
; 1362 : 		&& equal(_Left.begin(), _Left.end(), _Right.begin()));

	mov	ecx, DWORD PTR __Left$[ebp]
	call	?size@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::size
	mov	esi, eax
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::size
	cmp	esi, eax
	jne	SHORT $LN3@operator@21
	lea	eax, DWORD PTR $T32417[ebp]
	push	eax
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?begin@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBE?AVconst_iterator@12@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::begin
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	lea	eax, DWORD PTR $T32418[ebp]
	push	eax
	mov	ecx, DWORD PTR __Left$[ebp]
	call	?end@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBE?AVconst_iterator@12@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::end
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	lea	eax, DWORD PTR $T32419[ebp]
	push	eax
	mov	ecx, DWORD PTR __Left$[ebp]
	call	?begin@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBE?AVconst_iterator@12@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::begin
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	call	??$equal@Vconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@V123@@std@@YA_NVconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@00@Z ; std::equal<std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator,std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator>
	add	esp, 24					; 00000018H
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@operator@21
	mov	DWORD PTR tv84[ebp], 1
	jmp	SHORT $LN4@operator@21
$LN3@operator@21:
	mov	DWORD PTR tv84[ebp], 0
$LN4@operator@21:
	mov	al, BYTE PTR tv84[ebp]

; 1363 : 	}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$?8V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@YA_NABV?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@0@Z ENDP ; std::operator==<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 8\vc\include\utility
_TEXT	ENDS
;	COMDAT ??$swap@D@std@@YAXAAD0@Z
_TEXT	SEGMENT
__Tmp$ = -1						; size = 1
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@D@std@@YAXAAD0@Z PROC				; std::swap<char>, COMDAT

; 17   : 	{	// exchange values stored at _Left and _Right

	push	ebp
	mov	ebp, esp
	push	ecx

; 18   : 	_Ty _Tmp = _Left;

	mov	eax, DWORD PTR __Left$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR __Tmp$[ebp], cl

; 19   : 	_Left = _Right, _Right = _Tmp;

	mov	edx, DWORD PTR __Left$[ebp]
	mov	eax, DWORD PTR __Right$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR [edx], cl
	mov	edx, DWORD PTR __Right$[ebp]
	mov	al, BYTE PTR __Tmp$[ebp]
	mov	BYTE PTR [edx], al

; 20   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$swap@D@std@@YAXAAD0@Z ENDP				; std::swap<char>
_TEXT	ENDS
PUBLIC	??$_Distance2@Viterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@I@std@@YAXViterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@0AAIUbidirectional_iterator_tag@0@@Z ; std::_Distance2<std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::iterator,unsigned int>
PUBLIC	??$_Iter_cat@Viterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@std@@YA?AUbidirectional_iterator_tag@0@ABViterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@@Z ; std::_Iter_cat<std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::iterator>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 8\vc\include\xutility
;	COMDAT ??$_Distance@Viterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@I@std@@YAXViterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@0AAI@Z
_TEXT	SEGMENT
$T32426 = -1						; size = 1
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
__Off$ = 24						; size = 4
??$_Distance@Viterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@I@std@@YAXViterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@0AAI@Z PROC ; std::_Distance<std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::iterator,unsigned int>, COMDAT

; 1663 : 	{	// add to _Off distance between iterators

	push	ebp
	mov	ebp, esp
	push	ecx

; 1664 : 	_Distance2(_First, _Last, _Off, _Iter_cat(_First));

	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T32426[ebp]
	push	ecx
	call	??$_Iter_cat@Viterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@std@@YA?AUbidirectional_iterator_tag@0@ABViterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@@Z ; std::_Iter_cat<std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::iterator>
	add	esp, 8
	mov	dl, BYTE PTR [eax]
	push	edx
	mov	eax, DWORD PTR __Off$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Distance2@Viterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@I@std@@YAXViterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@0AAIUbidirectional_iterator_tag@0@@Z ; std::_Distance2<std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::iterator,unsigned int>
	add	esp, 24					; 00000018H

; 1665 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Distance@Viterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@I@std@@YAXViterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@0AAI@Z ENDP ; std::_Distance<std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::iterator,unsigned int>
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@0PAV12@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 8\vc\include\vector
;	COMDAT ??$_Ucopy@V?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@V?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@1@0PAV21@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
__Ptr$ = 24						; size = 4
??$_Ucopy@V?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@V?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@1@0PAV21@@Z PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Ucopy<std::_Vector_const_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >, COMDAT
; _this$ = ecx

; 1102 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1103 : 		{	// copy initializing [_First, _Last), using allocator
; 1104 : 		return (_STDEXT unchecked_uninitialized_copy(_First, _Last,
; 1105 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp+4]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@0PAV12@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
	add	esp, 24					; 00000018H

; 1106 : 		}

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
??$_Ucopy@V?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@V?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@1@0PAV21@@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Ucopy<std::_Vector_const_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
_TEXT	ENDS
PUBLIC	??$_Unchecked_uninitialized_move@V?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@0PAV12@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z ; stdext::_Unchecked_uninitialized_move<std::_Vector_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
; Function compile flags: /Odtp
;	COMDAT ??$_Umove@V?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@V?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@1@0PAV21@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
__Ptr$ = 24						; size = 4
??$_Umove@V?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@V?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@1@0PAV21@@Z PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Umove<std::_Vector_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >, COMDAT
; _this$ = ecx

; 1109 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1110 : 		{	// move initializing [_First, _Last), using allocator
; 1111 : 		return (_STDEXT _Unchecked_uninitialized_move(_First, _Last,
; 1112 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp+4]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Unchecked_uninitialized_move@V?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@0PAV12@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z ; stdext::_Unchecked_uninitialized_move<std::_Vector_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
	add	esp, 24					; 00000018H

; 1113 : 		}

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
??$_Umove@V?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@V?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@1@0PAV21@@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Umove<std::_Vector_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
_TEXT	ENDS
PUBLIC	??$_Uninit_fill_n@PAPBVPathArgument@Json@@IPBV12@V?$allocator@PBVPathArgument@Json@@@std@@@std@@YAXPAPBVPathArgument@Json@@IABQBV12@AAV?$allocator@PBVPathArgument@Json@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<Json::PathArgument const * *,unsigned int,Json::PathArgument const *,std::allocator<Json::PathArgument const *> >
PUBLIC	??$_Ptr_cat@PAPBVPathArgument@Json@@PAPBV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPBVPathArgument@Json@@0@Z ; std::_Ptr_cat<Json::PathArgument const * *,Json::PathArgument const * *>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 8\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_fill_n@PAPBVPathArgument@Json@@IPBV12@V?$allocator@PBVPathArgument@Json@@@std@@@stdext@@YAXPAPBVPathArgument@Json@@IABQBV12@AAV?$allocator@PBVPathArgument@Json@@@std@@@Z
_TEXT	SEGMENT
$T32434 = -2						; size = 1
$T32433 = -1						; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_fill_n@PAPBVPathArgument@Json@@IPBV12@V?$allocator@PBVPathArgument@Json@@@std@@@stdext@@YAXPAPBVPathArgument@Json@@IABQBV12@AAV?$allocator@PBVPathArgument@Json@@@std@@@Z PROC ; stdext::unchecked_uninitialized_fill_n<Json::PathArgument const * *,unsigned int,Json::PathArgument const *,std::allocator<Json::PathArgument const *> >, COMDAT

; 729  : 	{	// copy _Count *_Val to raw _First, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 730  : 		_STD _Uninit_fill_n(_First, _Count, _Val, _Al,
; 731  : 			_STD _Ptr_cat(_First, _First), _STD _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T32433[ebp], al
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAPBVPathArgument@Json@@PAPBV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPBVPathArgument@Json@@0@Z ; std::_Ptr_cat<Json::PathArgument const * *,Json::PathArgument const * *>
	add	esp, 8
	mov	BYTE PTR $T32434[ebp], al
	mov	al, BYTE PTR $T32433[ebp]
	push	eax
	mov	cl, BYTE PTR $T32434[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Uninit_fill_n@PAPBVPathArgument@Json@@IPBV12@V?$allocator@PBVPathArgument@Json@@@std@@@std@@YAXPAPBVPathArgument@Json@@IABQBV12@AAV?$allocator@PBVPathArgument@Json@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<Json::PathArgument const * *,unsigned int,Json::PathArgument const *,std::allocator<Json::PathArgument const *> >
	add	esp, 24					; 00000018H

; 732  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_fill_n@PAPBVPathArgument@Json@@IPBV12@V?$allocator@PBVPathArgument@Json@@@std@@@stdext@@YAXPAPBVPathArgument@Json@@IABQBV12@AAV?$allocator@PBVPathArgument@Json@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_fill_n<Json::PathArgument const * *,unsigned int,Json::PathArgument const *,std::allocator<Json::PathArgument const *> >
_TEXT	ENDS
PUBLIC	??$_Uninit_fill_n@PAVPathArgument@Json@@IV12@V?$allocator@VPathArgument@Json@@@std@@@std@@YAXPAVPathArgument@Json@@IABV12@AAV?$allocator@VPathArgument@Json@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<Json::PathArgument *,unsigned int,Json::PathArgument,std::allocator<Json::PathArgument> >
PUBLIC	??$_Ptr_cat@PAVPathArgument@Json@@PAV12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVPathArgument@Json@@0@Z ; std::_Ptr_cat<Json::PathArgument *,Json::PathArgument *>
; Function compile flags: /Odtp
;	COMDAT ??$unchecked_uninitialized_fill_n@PAVPathArgument@Json@@IV12@V?$allocator@VPathArgument@Json@@@std@@@stdext@@YAXPAVPathArgument@Json@@IABV12@AAV?$allocator@VPathArgument@Json@@@std@@@Z
_TEXT	SEGMENT
$T32438 = -2						; size = 1
$T32437 = -1						; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_fill_n@PAVPathArgument@Json@@IV12@V?$allocator@VPathArgument@Json@@@std@@@stdext@@YAXPAVPathArgument@Json@@IABV12@AAV?$allocator@VPathArgument@Json@@@std@@@Z PROC ; stdext::unchecked_uninitialized_fill_n<Json::PathArgument *,unsigned int,Json::PathArgument,std::allocator<Json::PathArgument> >, COMDAT

; 729  : 	{	// copy _Count *_Val to raw _First, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 730  : 		_STD _Uninit_fill_n(_First, _Count, _Val, _Al,
; 731  : 			_STD _Ptr_cat(_First, _First), _STD _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T32437[ebp], al
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAVPathArgument@Json@@PAV12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVPathArgument@Json@@0@Z ; std::_Ptr_cat<Json::PathArgument *,Json::PathArgument *>
	add	esp, 8
	mov	BYTE PTR $T32438[ebp], al
	mov	al, BYTE PTR $T32437[ebp]
	push	eax
	mov	cl, BYTE PTR $T32438[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Uninit_fill_n@PAVPathArgument@Json@@IV12@V?$allocator@VPathArgument@Json@@@std@@@std@@YAXPAVPathArgument@Json@@IABV12@AAV?$allocator@VPathArgument@Json@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<Json::PathArgument *,unsigned int,Json::PathArgument,std::allocator<Json::PathArgument> >
	add	esp, 24					; 00000018H

; 732  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_fill_n@PAVPathArgument@Json@@IV12@V?$allocator@VPathArgument@Json@@@std@@@stdext@@YAXPAVPathArgument@Json@@IABV12@AAV?$allocator@VPathArgument@Json@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_fill_n<Json::PathArgument *,unsigned int,Json::PathArgument,std::allocator<Json::PathArgument> >
_TEXT	ENDS
PUBLIC	??_G_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAEPAXI@Z ; std::_Tree_nod<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Node::`scalar deleting destructor'
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 8\vc\include\xmemory
;	COMDAT ??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@@Z PROC ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Node>, COMDAT

; 59   : 	{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp

; 60   : 	_DESTRUCTOR(_Ty, _Ptr);

	push	0
	mov	ecx, DWORD PTR __Ptr$[ebp]
	call	??_G_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAEPAXI@Z

; 61   : 	}

	pop	ebp
	ret	0
??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@@Z ENDP ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Node>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	??$_Ptr_cat@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ; std::_Ptr_cat<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
; Function compile flags: /Odtp
;	COMDAT ??$_Destroy_range@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z
_TEXT	SEGMENT
$T32443 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z PROC ; std::_Destroy_range<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT

; 225  : 	{	// destroy [_First, _Last)

	push	ebp
	mov	ebp, esp
	push	ecx

; 226  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Ptr_cat@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ; std::_Ptr_cat<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
	add	esp, 8
	mov	BYTE PTR $T32443[ebp], al
	mov	dl, BYTE PTR $T32443[ebp]
	push	edx
	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
	add	esp, 16					; 00000010H

; 227  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Destroy_range@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ENDP ; std::_Destroy_range<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
PUBLIC	??$_Uninit_fill_n@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IABV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 8\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_fill_n@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IABV12@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z
_TEXT	SEGMENT
$T32447 = -2						; size = 1
$T32446 = -1						; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_fill_n@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IABV12@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z PROC ; stdext::unchecked_uninitialized_fill_n<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT

; 729  : 	{	// copy _Count *_Val to raw _First, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 730  : 		_STD _Uninit_fill_n(_First, _Count, _Val, _Al,
; 731  : 			_STD _Ptr_cat(_First, _First), _STD _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T32446[ebp], al
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ; std::_Ptr_cat<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
	add	esp, 8
	mov	BYTE PTR $T32447[ebp], al
	mov	al, BYTE PTR $T32446[ebp]
	push	eax
	mov	cl, BYTE PTR $T32447[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Uninit_fill_n@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IABV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
	add	esp, 24					; 00000018H

; 732  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_fill_n@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IABV12@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z ENDP ; stdext::unchecked_uninitialized_fill_n<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
PUBLIC	__TI2?AVbad_alloc@std@@
PUBLIC	??0bad_alloc@std@@QAE@PBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
PUBLIC	__CTA2?AVbad_alloc@std@@
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
;	COMDAT ??_R0?AVbad_alloc@std@@@8
; File c:\program files (x86)\microsoft visual studio 8\vc\include\xmemory
_DATA	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_alloc@std@@
xdata$x	SEGMENT
__CTA2?AVbad_alloc@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVbad_alloc@std@@
xdata$x	SEGMENT
__TI2?AVbad_alloc@std@@ DD 00H
	DD	FLAT:??1bad_alloc@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_alloc@std@@
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??$_Allocate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IPAV10@@Z
_TEXT	SEGMENT
$T32450 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IPAV10@@Z PROC ; std::_Allocate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT

; 37   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 38   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate

; 39   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate
$LN3@Allocate:

; 40   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 28					; 0000001cH
	jae	SHORT $LN2@Allocate

; 41   : 		_THROW_NCEE(std::bad_alloc, NULL);

	push	0
	lea	ecx, DWORD PTR $T32450[ebp]
	call	??0bad_alloc@std@@QAE@PBD@Z		; std::bad_alloc::bad_alloc
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	eax, DWORD PTR $T32450[ebp]
	push	eax
	call	__CxxThrowException@8
$LN2@Allocate:

; 42   : 
; 43   : 		// allocate storage for _Count elements of type _Ty
; 44   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	ecx, DWORD PTR __Count$[ebp]
	imul	ecx, 28					; 0000001cH
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate:

; 45   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IPAV10@@Z ENDP ; std::_Allocate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	__imp_??0exception@std@@QAE@ABQBD@Z:PROC
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	?what@exception@std@@UBEPBDXZ:PROC		; std::exception::what
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
; File c:\program files (x86)\microsoft visual studio 8\vc\include\exception
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@PBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Message$ = 8						; size = 4
??0bad_alloc@std@@QAE@PBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx

; 339  : 		{	// construct from message string

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR __Message$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@

; 340  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0bad_alloc@std@@QAE@PBD@Z ENDP			; std::bad_alloc::bad_alloc
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx

; 348  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@

; 349  : 		}

	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1bad_alloc@std@@UAE@XZ		; std::bad_alloc::~bad_alloc
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@9
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@9:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??$_Destroy_range@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@YAXPAPBVPathArgument@Json@@0AAV?$allocator@PBVPathArgument@Json@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 8\vc\include\xmemory
;	COMDAT ??$_Destroy_range@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@YAXPAPBVPathArgument@Json@@0AAV?$allocator@PBVPathArgument@Json@@@0@@Z
_TEXT	SEGMENT
$T32459 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@YAXPAPBVPathArgument@Json@@0AAV?$allocator@PBVPathArgument@Json@@@0@@Z PROC ; std::_Destroy_range<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >, COMDAT

; 225  : 	{	// destroy [_First, _Last)

	push	ebp
	mov	ebp, esp
	push	ecx

; 226  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Ptr_cat@PAPBVPathArgument@Json@@PAPBV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPBVPathArgument@Json@@0@Z ; std::_Ptr_cat<Json::PathArgument const * *,Json::PathArgument const * *>
	add	esp, 8
	mov	BYTE PTR $T32459[ebp], al
	mov	dl, BYTE PTR $T32459[ebp]
	push	edx
	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@YAXPAPBVPathArgument@Json@@0AAV?$allocator@PBVPathArgument@Json@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >
	add	esp, 16					; 00000010H

; 227  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Destroy_range@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@YAXPAPBVPathArgument@Json@@0AAV?$allocator@PBVPathArgument@Json@@@0@@Z ENDP ; std::_Destroy_range<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >
_TEXT	ENDS
PUBLIC	??$_Unchecked_uninitialized_move@PAPBVPathArgument@Json@@PAPBV12@V?$allocator@PBVPathArgument@Json@@@std@@@stdext@@YAPAPBVPathArgument@Json@@PAPBV12@00AAV?$allocator@PBVPathArgument@Json@@@std@@@Z ; stdext::_Unchecked_uninitialized_move<Json::PathArgument const * *,Json::PathArgument const * *,std::allocator<Json::PathArgument const *> >
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 8\vc\include\vector
;	COMDAT ??$_Umove@PAPBVPathArgument@Json@@@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IAEPAPBVPathArgument@Json@@PAPBV23@00@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Umove@PAPBVPathArgument@Json@@@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IAEPAPBVPathArgument@Json@@PAPBV23@00@Z PROC ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::_Umove<Json::PathArgument const * *>, COMDAT
; _this$ = ecx

; 1109 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1110 : 		{	// move initializing [_First, _Last), using allocator
; 1111 : 		return (_STDEXT _Unchecked_uninitialized_move(_First, _Last,
; 1112 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Unchecked_uninitialized_move@PAPBVPathArgument@Json@@PAPBV12@V?$allocator@PBVPathArgument@Json@@@std@@@stdext@@YAPAPBVPathArgument@Json@@PAPBV12@00AAV?$allocator@PBVPathArgument@Json@@@std@@@Z ; stdext::_Unchecked_uninitialized_move<Json::PathArgument const * *,Json::PathArgument const * *,std::allocator<Json::PathArgument const *> >
	add	esp, 16					; 00000010H

; 1113 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??$_Umove@PAPBVPathArgument@Json@@@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IAEPAPBVPathArgument@Json@@PAPBV23@00@Z ENDP ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::_Umove<Json::PathArgument const * *>
_TEXT	ENDS
PUBLIC	??$_Fill@PAPBVPathArgument@Json@@PBV12@@std@@YAXPAPBVPathArgument@Json@@0ABQBV12@@Z ; std::_Fill<Json::PathArgument const * *,Json::PathArgument const *>
PUBLIC	??$_Checked_base@PAPBVPathArgument@Json@@@std@@YAPAPBVPathArgument@Json@@AAPAPBV12@@Z ; std::_Checked_base<Json::PathArgument const * *>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 8\vc\include\xutility
;	COMDAT ??$fill@PAPBVPathArgument@Json@@PBV12@@std@@YAXPAPBVPathArgument@Json@@0ABQBV12@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$fill@PAPBVPathArgument@Json@@PBV12@@std@@YAXPAPBVPathArgument@Json@@0ABQBV12@@Z PROC ; std::fill<Json::PathArgument const * *,Json::PathArgument const *>, COMDAT

; 2753 : 	{	// copy _Val through [_First, _Last)

	push	ebp
	mov	ebp, esp

; 2754 : 	_Fill(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAPBVPathArgument@Json@@@std@@YAPAPBVPathArgument@Json@@AAPAPBV12@@Z ; std::_Checked_base<Json::PathArgument const * *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAPBVPathArgument@Json@@@std@@YAPAPBVPathArgument@Json@@AAPAPBV12@@Z ; std::_Checked_base<Json::PathArgument const * *>
	add	esp, 4
	push	eax
	call	??$_Fill@PAPBVPathArgument@Json@@PBV12@@std@@YAXPAPBVPathArgument@Json@@0ABQBV12@@Z ; std::_Fill<Json::PathArgument const * *,Json::PathArgument const *>
	add	esp, 12					; 0000000cH

; 2755 : 	}

	pop	ebp
	ret	0
??$fill@PAPBVPathArgument@Json@@PBV12@@std@@YAXPAPBVPathArgument@Json@@0ABQBV12@@Z ENDP ; std::fill<Json::PathArgument const * *,Json::PathArgument const *>
_TEXT	ENDS
PUBLIC	??$_Move_backward_opt@PAPBVPathArgument@Json@@PAPBV12@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@4@@std@@YAPAPBVPathArgument@Json@@PAPBV12@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<Json::PathArgument const * *,Json::PathArgument const * *,std::random_access_iterator_tag,std::_Undefined_move_tag>
PUBLIC	??$_Iter_random@PAPBVPathArgument@Json@@PAPBV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPBVPathArgument@Json@@0@Z ; std::_Iter_random<Json::PathArgument const * *,Json::PathArgument const * *>
PUBLIC	??$_Move_cat@PAPBVPathArgument@Json@@@std@@YA?AU_Undefined_move_tag@0@ABQAPBVPathArgument@Json@@@Z ; std::_Move_cat<Json::PathArgument const * *>
; Function compile flags: /Odtp
;	COMDAT ??$_Unchecked_move_backward@PAPBVPathArgument@Json@@PAPBV12@@stdext@@YAPAPBVPathArgument@Json@@PAPBV12@00@Z
_TEXT	SEGMENT
$T32468 = -3						; size = 1
$T32467 = -2						; size = 1
$T32466 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Unchecked_move_backward@PAPBVPathArgument@Json@@PAPBV12@@stdext@@YAPAPBVPathArgument@Json@@PAPBV12@00@Z PROC ; stdext::_Unchecked_move_backward<Json::PathArgument const * *,Json::PathArgument const * *>, COMDAT

; 3022 : 	{	// move [_First, _Last) backwards to [..., _Dest)

	push	ebp
	mov	ebp, esp
	push	ecx

; 3023 : 		return (_STD _Move_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3024 : 			_STD _Iter_random(_First, _Dest), _STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T32466[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	??$_Move_cat@PAPBVPathArgument@Json@@@std@@YA?AU_Undefined_move_tag@0@ABQAPBVPathArgument@Json@@@Z ; std::_Move_cat<Json::PathArgument const * *>
	add	esp, 4
	mov	BYTE PTR $T32467[ebp], al
	mov	dl, BYTE PTR $T32466[ebp]
	push	edx
	mov	al, BYTE PTR $T32467[ebp]
	push	eax
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	lea	eax, DWORD PTR $T32468[ebp]
	push	eax
	call	??$_Iter_random@PAPBVPathArgument@Json@@PAPBV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPBVPathArgument@Json@@0@Z ; std::_Iter_random<Json::PathArgument const * *,Json::PathArgument const * *>
	add	esp, 12					; 0000000cH
	mov	cl, BYTE PTR [eax]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	call	??$_Checked_base@PAPBVPathArgument@Json@@@std@@YAPAPBVPathArgument@Json@@AAPAPBV12@@Z ; std::_Checked_base<Json::PathArgument const * *>
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Checked_base@PAPBVPathArgument@Json@@@std@@YAPAPBVPathArgument@Json@@AAPAPBV12@@Z ; std::_Checked_base<Json::PathArgument const * *>
	add	esp, 4
	push	eax
	call	??$_Move_backward_opt@PAPBVPathArgument@Json@@PAPBV12@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@4@@std@@YAPAPBVPathArgument@Json@@PAPBV12@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<Json::PathArgument const * *,Json::PathArgument const * *,std::random_access_iterator_tag,std::_Undefined_move_tag>
	add	esp, 24					; 00000018H

; 3025 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Unchecked_move_backward@PAPBVPathArgument@Json@@PAPBV12@@stdext@@YAPAPBVPathArgument@Json@@PAPBV12@00@Z ENDP ; stdext::_Unchecked_move_backward<Json::PathArgument const * *,Json::PathArgument const * *>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 8\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Allocate@PBVPathArgument@Json@@@std@@YAPAPBVPathArgument@Json@@IPAPBV12@@Z
_TEXT	SEGMENT
$T32471 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@PBVPathArgument@Json@@@std@@YAPAPBVPathArgument@Json@@IPAPBV12@@Z PROC ; std::_Allocate<Json::PathArgument const *>, COMDAT

; 37   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 38   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate@2

; 39   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate@2
$LN3@Allocate@2:

; 40   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 4
	jae	SHORT $LN2@Allocate@2

; 41   : 		_THROW_NCEE(std::bad_alloc, NULL);

	push	0
	lea	ecx, DWORD PTR $T32471[ebp]
	call	??0bad_alloc@std@@QAE@PBD@Z		; std::bad_alloc::bad_alloc
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	eax, DWORD PTR $T32471[ebp]
	push	eax
	call	__CxxThrowException@8
$LN2@Allocate@2:

; 42   : 
; 43   : 		// allocate storage for _Count elements of type _Ty
; 44   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 2
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate@2:

; 45   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@PBVPathArgument@Json@@@std@@YAPAPBVPathArgument@Json@@IPAPBV12@@Z ENDP ; std::_Allocate<Json::PathArgument const *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@YAXPAVPathArgument@Json@@0AAV?$allocator@VPathArgument@Json@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<Json::PathArgument,std::allocator<Json::PathArgument> >
; Function compile flags: /Odtp
;	COMDAT ??$_Destroy_range@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@YAXPAVPathArgument@Json@@0AAV?$allocator@VPathArgument@Json@@@0@@Z
_TEXT	SEGMENT
$T32474 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@YAXPAVPathArgument@Json@@0AAV?$allocator@VPathArgument@Json@@@0@@Z PROC ; std::_Destroy_range<Json::PathArgument,std::allocator<Json::PathArgument> >, COMDAT

; 225  : 	{	// destroy [_First, _Last)

	push	ebp
	mov	ebp, esp
	push	ecx

; 226  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Ptr_cat@PAVPathArgument@Json@@PAV12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVPathArgument@Json@@0@Z ; std::_Ptr_cat<Json::PathArgument *,Json::PathArgument *>
	add	esp, 8
	mov	BYTE PTR $T32474[ebp], al
	mov	dl, BYTE PTR $T32474[ebp]
	push	edx
	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@YAXPAVPathArgument@Json@@0AAV?$allocator@VPathArgument@Json@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<Json::PathArgument,std::allocator<Json::PathArgument> >
	add	esp, 16					; 00000010H

; 227  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Destroy_range@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@YAXPAVPathArgument@Json@@0AAV?$allocator@VPathArgument@Json@@@0@@Z ENDP ; std::_Destroy_range<Json::PathArgument,std::allocator<Json::PathArgument> >
_TEXT	ENDS
PUBLIC	??$_Unchecked_uninitialized_move@PAVPathArgument@Json@@PAV12@V?$allocator@VPathArgument@Json@@@std@@@stdext@@YAPAVPathArgument@Json@@PAV12@00AAV?$allocator@VPathArgument@Json@@@std@@@Z ; stdext::_Unchecked_uninitialized_move<Json::PathArgument *,Json::PathArgument *,std::allocator<Json::PathArgument> >
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 8\vc\include\vector
;	COMDAT ??$_Umove@PAVPathArgument@Json@@@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAEPAVPathArgument@Json@@PAV23@00@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Umove@PAVPathArgument@Json@@@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAEPAVPathArgument@Json@@PAV23@00@Z PROC ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::_Umove<Json::PathArgument *>, COMDAT
; _this$ = ecx

; 1109 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1110 : 		{	// move initializing [_First, _Last), using allocator
; 1111 : 		return (_STDEXT _Unchecked_uninitialized_move(_First, _Last,
; 1112 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Unchecked_uninitialized_move@PAVPathArgument@Json@@PAV12@V?$allocator@VPathArgument@Json@@@std@@@stdext@@YAPAVPathArgument@Json@@PAV12@00AAV?$allocator@VPathArgument@Json@@@std@@@Z ; stdext::_Unchecked_uninitialized_move<Json::PathArgument *,Json::PathArgument *,std::allocator<Json::PathArgument> >
	add	esp, 16					; 00000010H

; 1113 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??$_Umove@PAVPathArgument@Json@@@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAEPAVPathArgument@Json@@PAV23@00@Z ENDP ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::_Umove<Json::PathArgument *>
_TEXT	ENDS
PUBLIC	??$_Fill@PAVPathArgument@Json@@V12@@std@@YAXPAVPathArgument@Json@@0ABV12@@Z ; std::_Fill<Json::PathArgument *,Json::PathArgument>
PUBLIC	??$_Checked_base@PAVPathArgument@Json@@@std@@YAPAVPathArgument@Json@@AAPAV12@@Z ; std::_Checked_base<Json::PathArgument *>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 8\vc\include\xutility
;	COMDAT ??$fill@PAVPathArgument@Json@@V12@@std@@YAXPAVPathArgument@Json@@0ABV12@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$fill@PAVPathArgument@Json@@V12@@std@@YAXPAVPathArgument@Json@@0ABV12@@Z PROC ; std::fill<Json::PathArgument *,Json::PathArgument>, COMDAT

; 2753 : 	{	// copy _Val through [_First, _Last)

	push	ebp
	mov	ebp, esp

; 2754 : 	_Fill(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAVPathArgument@Json@@@std@@YAPAVPathArgument@Json@@AAPAV12@@Z ; std::_Checked_base<Json::PathArgument *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAVPathArgument@Json@@@std@@YAPAVPathArgument@Json@@AAPAV12@@Z ; std::_Checked_base<Json::PathArgument *>
	add	esp, 4
	push	eax
	call	??$_Fill@PAVPathArgument@Json@@V12@@std@@YAXPAVPathArgument@Json@@0ABV12@@Z ; std::_Fill<Json::PathArgument *,Json::PathArgument>
	add	esp, 12					; 0000000cH

; 2755 : 	}

	pop	ebp
	ret	0
??$fill@PAVPathArgument@Json@@V12@@std@@YAXPAVPathArgument@Json@@0ABV12@@Z ENDP ; std::fill<Json::PathArgument *,Json::PathArgument>
_TEXT	ENDS
PUBLIC	??$_Move_backward_opt@PAVPathArgument@Json@@PAV12@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@4@@std@@YAPAVPathArgument@Json@@PAV12@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<Json::PathArgument *,Json::PathArgument *,std::random_access_iterator_tag,std::_Undefined_move_tag>
PUBLIC	??$_Iter_random@PAVPathArgument@Json@@PAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVPathArgument@Json@@0@Z ; std::_Iter_random<Json::PathArgument *,Json::PathArgument *>
PUBLIC	??$_Move_cat@PAVPathArgument@Json@@@std@@YA?AU_Undefined_move_tag@0@ABQAVPathArgument@Json@@@Z ; std::_Move_cat<Json::PathArgument *>
; Function compile flags: /Odtp
;	COMDAT ??$_Unchecked_move_backward@PAVPathArgument@Json@@PAV12@@stdext@@YAPAVPathArgument@Json@@PAV12@00@Z
_TEXT	SEGMENT
$T32483 = -3						; size = 1
$T32482 = -2						; size = 1
$T32481 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Unchecked_move_backward@PAVPathArgument@Json@@PAV12@@stdext@@YAPAVPathArgument@Json@@PAV12@00@Z PROC ; stdext::_Unchecked_move_backward<Json::PathArgument *,Json::PathArgument *>, COMDAT

; 3022 : 	{	// move [_First, _Last) backwards to [..., _Dest)

	push	ebp
	mov	ebp, esp
	push	ecx

; 3023 : 		return (_STD _Move_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3024 : 			_STD _Iter_random(_First, _Dest), _STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T32481[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	??$_Move_cat@PAVPathArgument@Json@@@std@@YA?AU_Undefined_move_tag@0@ABQAVPathArgument@Json@@@Z ; std::_Move_cat<Json::PathArgument *>
	add	esp, 4
	mov	BYTE PTR $T32482[ebp], al
	mov	dl, BYTE PTR $T32481[ebp]
	push	edx
	mov	al, BYTE PTR $T32482[ebp]
	push	eax
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	lea	eax, DWORD PTR $T32483[ebp]
	push	eax
	call	??$_Iter_random@PAVPathArgument@Json@@PAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVPathArgument@Json@@0@Z ; std::_Iter_random<Json::PathArgument *,Json::PathArgument *>
	add	esp, 12					; 0000000cH
	mov	cl, BYTE PTR [eax]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	call	??$_Checked_base@PAVPathArgument@Json@@@std@@YAPAVPathArgument@Json@@AAPAV12@@Z ; std::_Checked_base<Json::PathArgument *>
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Checked_base@PAVPathArgument@Json@@@std@@YAPAVPathArgument@Json@@AAPAV12@@Z ; std::_Checked_base<Json::PathArgument *>
	add	esp, 4
	push	eax
	call	??$_Move_backward_opt@PAVPathArgument@Json@@PAV12@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@4@@std@@YAPAVPathArgument@Json@@PAV12@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<Json::PathArgument *,Json::PathArgument *,std::random_access_iterator_tag,std::_Undefined_move_tag>
	add	esp, 24					; 00000018H

; 3025 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Unchecked_move_backward@PAVPathArgument@Json@@PAV12@@stdext@@YAPAVPathArgument@Json@@PAV12@00@Z ENDP ; stdext::_Unchecked_move_backward<Json::PathArgument *,Json::PathArgument *>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 8\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Allocate@VPathArgument@Json@@@std@@YAPAVPathArgument@Json@@IPAV12@@Z
_TEXT	SEGMENT
$T32486 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@VPathArgument@Json@@@std@@YAPAVPathArgument@Json@@IPAV12@@Z PROC ; std::_Allocate<Json::PathArgument>, COMDAT

; 37   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 38   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate@3

; 39   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate@3
$LN3@Allocate@3:

; 40   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 36					; 00000024H
	jae	SHORT $LN2@Allocate@3

; 41   : 		_THROW_NCEE(std::bad_alloc, NULL);

	push	0
	lea	ecx, DWORD PTR $T32486[ebp]
	call	??0bad_alloc@std@@QAE@PBD@Z		; std::bad_alloc::bad_alloc
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	eax, DWORD PTR $T32486[ebp]
	push	eax
	call	__CxxThrowException@8
$LN2@Allocate@3:

; 42   : 
; 43   : 		// allocate storage for _Count elements of type _Ty
; 44   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	ecx, DWORD PTR __Count$[ebp]
	imul	ecx, 36					; 00000024H
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate@3:

; 45   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@VPathArgument@Json@@@std@@YAPAVPathArgument@Json@@IPAV12@@Z ENDP ; std::_Allocate<Json::PathArgument>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$?0U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@1@@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Node *>::allocator<std::_Tree_nod<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Node *><std::pair<Json::Value::CZString const ,Json::Value> >, COMDAT
; _this$ = ecx

; 129  : 		allocator(const allocator<_Other>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 130  : 		{	// construct from a related allocator (do nothing)
; 131  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@1@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Node *>::allocator<std::_Tree_nod<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Node *><std::pair<Json::Value::CZString const ,Json::Value> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@@Z PROC ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Node *>, COMDAT

; 59   : 	{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp

; 60   : 	_DESTRUCTOR(_Ty, _Ptr);
; 61   : 	}

	pop	ebp
	ret	0
??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@@Z ENDP ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Node *>
_TEXT	ENDS
PUBLIC	??$_Unchecked_uninitialized_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@00AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z ; stdext::_Unchecked_uninitialized_move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 8\vc\include\vector
;	COMDAT ??$_Umove@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PAV21@00@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Umove@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PAV21@00@Z PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Umove<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>, COMDAT
; _this$ = ecx

; 1109 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1110 : 		{	// move initializing [_First, _Last), using allocator
; 1111 : 		return (_STDEXT _Unchecked_uninitialized_move(_First, _Last,
; 1112 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Unchecked_uninitialized_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@00AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z ; stdext::_Unchecked_uninitialized_move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
	add	esp, 16					; 00000010H

; 1113 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??$_Umove@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PAV21@00@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Umove<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
_TEXT	ENDS
PUBLIC	??$_Fill@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0ABV10@@Z ; std::_Fill<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??$_Checked_base@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAPAV10@@Z ; std::_Checked_base<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 8\vc\include\xutility
;	COMDAT ??$fill@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0ABV10@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$fill@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0ABV10@@Z PROC ; std::fill<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT

; 2753 : 	{	// copy _Val through [_First, _Last)

	push	ebp
	mov	ebp, esp

; 2754 : 	_Fill(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAPAV10@@Z ; std::_Checked_base<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAPAV10@@Z ; std::_Checked_base<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
	add	esp, 4
	push	eax
	call	??$_Fill@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0ABV10@@Z ; std::_Fill<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
	add	esp, 12					; 0000000cH

; 2755 : 	}

	pop	ebp
	ret	0
??$fill@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0ABV10@@Z ENDP ; std::fill<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
PUBLIC	??$_Move_backward_opt@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00Urandom_access_iterator_tag@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
PUBLIC	??$_Iter_random@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ; std::_Iter_random<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
PUBLIC	??$_Move_cat@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA?AU_Swap_move_tag@0@ABQAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::_Move_cat<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
; Function compile flags: /Odtp
;	COMDAT ??$_Unchecked_move_backward@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@stdext@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@00@Z
_TEXT	SEGMENT
$T32499 = -3						; size = 1
$T32498 = -2						; size = 1
$T32497 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Unchecked_move_backward@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@stdext@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@00@Z PROC ; stdext::_Unchecked_move_backward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>, COMDAT

; 3022 : 	{	// move [_First, _Last) backwards to [..., _Dest)

	push	ebp
	mov	ebp, esp
	push	ecx

; 3023 : 		return (_STD _Move_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3024 : 			_STD _Iter_random(_First, _Dest), _STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T32497[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	??$_Move_cat@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA?AU_Swap_move_tag@0@ABQAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::_Move_cat<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
	add	esp, 4
	mov	BYTE PTR $T32498[ebp], al
	mov	dl, BYTE PTR $T32497[ebp]
	push	edx
	mov	al, BYTE PTR $T32498[ebp]
	push	eax
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	lea	eax, DWORD PTR $T32499[ebp]
	push	eax
	call	??$_Iter_random@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ; std::_Iter_random<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
	add	esp, 12					; 0000000cH
	mov	cl, BYTE PTR [eax]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	call	??$_Checked_base@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAPAV10@@Z ; std::_Checked_base<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Checked_base@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAPAV10@@Z ; std::_Checked_base<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
	add	esp, 4
	push	eax
	call	??$_Move_backward_opt@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00Urandom_access_iterator_tag@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
	add	esp, 24					; 00000018H

; 3025 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Unchecked_move_backward@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@stdext@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@00@Z ENDP ; stdext::_Unchecked_move_backward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 8\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$?0U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@1@@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Node><std::pair<Json::Value::CZString const ,Json::Value> >, COMDAT
; _this$ = ecx

; 129  : 		allocator(const allocator<_Other>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 130  : 		{	// construct from a related allocator (do nothing)
; 131  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@1@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Node><std::pair<Json::Value::CZString const ,Json::Value> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@IPAU120@@Z
_TEXT	SEGMENT
$T32504 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@IPAU120@@Z PROC ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Node>, COMDAT

; 37   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 38   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate@4

; 39   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate@4
$LN3@Allocate@4:

; 40   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 48					; 00000030H
	jae	SHORT $LN2@Allocate@4

; 41   : 		_THROW_NCEE(std::bad_alloc, NULL);

	push	0
	lea	ecx, DWORD PTR $T32504[ebp]
	call	??0bad_alloc@std@@QAE@PBD@Z		; std::bad_alloc::bad_alloc
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	eax, DWORD PTR $T32504[ebp]
	push	eax
	call	__CxxThrowException@8
$LN2@Allocate@4:

; 42   : 
; 43   : 		// allocate storage for _Count elements of type _Ty
; 44   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	ecx, DWORD PTR __Count$[ebp]
	imul	ecx, 48					; 00000030H
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate@4:

; 45   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@IPAU120@@Z ENDP ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Node>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@ABQAU120@@Z
_TEXT	SEGMENT
tv68 = -12						; size = 4
$T32507 = -8						; size = 4
__Vptr$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@ABQAU120@@Z PROC ; std::_Construct<std::_Tree_nod<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Node *,std::_Tree_nod<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Node *>, COMDAT

; 51   : 	{	// construct object at _Ptr with value _Val

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 52   : 	void _FARQ *_Vptr = _Ptr;

	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR __Vptr$[ebp], eax

; 53   : 	::new (_Vptr) _T1(_Val);

	mov	ecx, DWORD PTR __Vptr$[ebp]
	push	ecx
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T32507[ebp], eax
	cmp	DWORD PTR $T32507[ebp], 0
	je	SHORT $LN3@Construct
	mov	edx, DWORD PTR $T32507[ebp]
	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR $T32507[ebp]
	mov	DWORD PTR tv68[ebp], edx
	jmp	SHORT $LN1@Construct
$LN3@Construct:
	mov	DWORD PTR tv68[ebp], 0
$LN1@Construct:

; 54   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@ABQAU120@@Z ENDP ; std::_Construct<std::_Tree_nod<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Node *,std::_Tree_nod<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Node *>
_TEXT	ENDS
PUBLIC	??1_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE@XZ ; std::_Tree_nod<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Node::~_Node
; Function compile flags: /Odtp
;	COMDAT ??_G_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAEPAXI@Z PROC ; std::_Tree_nod<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Node::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@10
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@10:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_G_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAEPAXI@Z ENDP ; std::_Tree_nod<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Node::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree_nod<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Node::~_Node, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??1?$pair@$$CBVCZString@Value@Json@@V23@@std@@QAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree_nod<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Node::~_Node
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 8\vc\include\xtree
_TEXT	ENDS
;	COMDAT ?begin@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBE?AVconst_iterator@12@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBE?AVconst_iterator@12@XZ PROC ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::begin, COMDAT
; _this$ = ecx

; 546  : 		{	// return iterator for beginning of nonmutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 547  : 		return (_TREE_CONST_ITERATOR(_Lmost()));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lmost@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Lmost
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0const_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PBV12@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator::const_iterator
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 548  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBE?AVconst_iterator@12@XZ ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::begin
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBE?AVconst_iterator@12@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBE?AVconst_iterator@12@XZ PROC ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::end, COMDAT
; _this$ = ecx

; 556  : 		{	// return iterator for end of nonmutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 557  : 		return (_TREE_CONST_ITERATOR(_Myhead));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0const_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PBV12@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator::const_iterator
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 558  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBE?AVconst_iterator@12@XZ ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::end
_TEXT	ENDS
PUBLIC	??$_Lexicographical_compare@Vconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@V123@@std@@YA_NVconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@000@Z ; std::_Lexicographical_compare<std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator,std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator>
PUBLIC	??$_Checked_base@Vconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@std@@YA?AVconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@AAV120@@Z ; std::_Checked_base<std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 8\vc\include\xutility
;	COMDAT ??$lexicographical_compare@Vconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@V123@@std@@YA_NVconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@000@Z
_TEXT	SEGMENT
$T32527 = -32						; size = 8
$T32526 = -24						; size = 8
$T32525 = -16						; size = 8
$T32524 = -8						; size = 8
__First1$ = 8						; size = 8
__Last1$ = 16						; size = 8
__First2$ = 24						; size = 8
__Last2$ = 32						; size = 8
??$lexicographical_compare@Vconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@V123@@std@@YA_NVconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@000@Z PROC ; std::lexicographical_compare<std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator,std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator>, COMDAT

; 2862 : 	{	// order [_First1, _Last1) vs. [First2, Last2)

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H

; 2863 : 	return _Lexicographical_compare(_CHECKED_BASE(_First1), _CHECKED_BASE(_Last1),
; 2864 : 		_CHECKED_BASE(_First2), _CHECKED_BASE(_Last2));

	lea	eax, DWORD PTR __Last2$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T32524[ebp]
	push	ecx
	call	??$_Checked_base@Vconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@std@@YA?AVconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@AAV120@@Z ; std::_Checked_base<std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator>
	add	esp, 8
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	lea	ecx, DWORD PTR __First2$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T32525[ebp]
	push	edx
	call	??$_Checked_base@Vconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@std@@YA?AVconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@AAV120@@Z ; std::_Checked_base<std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator>
	add	esp, 8
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	lea	eax, DWORD PTR __Last1$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T32526[ebp]
	push	ecx
	call	??$_Checked_base@Vconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@std@@YA?AVconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@AAV120@@Z ; std::_Checked_base<std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator>
	add	esp, 8
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	lea	ecx, DWORD PTR __First1$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T32527[ebp]
	push	edx
	call	??$_Checked_base@Vconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@std@@YA?AVconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@AAV120@@Z ; std::_Checked_base<std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator>
	add	esp, 8
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	call	??$_Lexicographical_compare@Vconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@V123@@std@@YA_NVconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@000@Z ; std::_Lexicographical_compare<std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator,std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator>
	add	esp, 32					; 00000020H

; 2865 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$lexicographical_compare@Vconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@V123@@std@@YA_NVconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@000@Z ENDP ; std::lexicographical_compare<std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator,std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator>
_TEXT	ENDS
PUBLIC	??$_Equal@Vconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@V123@Uforward_iterator_tag@3@@std@@YA_NVconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@00Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Equal<std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator,std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator,std::forward_iterator_tag>
PUBLIC	??$_Iter_random@Vconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@V123@@std@@YA?AUforward_iterator_tag@0@ABVconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@0@Z ; std::_Iter_random<std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator,std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator>
PUBLIC	??$_Checked_cat@Vconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@std@@YA?AU_Range_checked_iterator_tag@0@ABVconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@@Z ; std::_Checked_cat<std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator>
; Function compile flags: /Odtp
;	COMDAT ??$equal@Vconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@V123@@std@@YA_NVconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@00@Z
_TEXT	SEGMENT
$T32533 = -20						; size = 8
$T32532 = -12						; size = 8
$T32531 = -2						; size = 1
$T32530 = -1						; size = 1
__First1$ = 8						; size = 8
__Last1$ = 16						; size = 8
__First2$ = 24						; size = 8
??$equal@Vconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@V123@@std@@YA_NVconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@00@Z PROC ; std::equal<std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator,std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator>, COMDAT

; 2672 : 	{	// compare [_First1, _Last1) to [First2, ...)

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 2673 : 	return _Equal(_CHECKED_BASE(_First1), _CHECKED_BASE(_Last1), _First2,
; 2674 : 		_Iter_random(_First1, _First2), _CHECKED_CAT(_First2));

	lea	eax, DWORD PTR __First2$[ebp]
	push	eax
	call	??$_Checked_cat@Vconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@std@@YA?AU_Range_checked_iterator_tag@0@ABVconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@@Z ; std::_Checked_cat<std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator>
	add	esp, 4
	mov	BYTE PTR $T32530[ebp], al
	mov	cl, BYTE PTR $T32530[ebp]
	push	ecx
	lea	edx, DWORD PTR __First2$[ebp]
	push	edx
	lea	eax, DWORD PTR __First1$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T32531[ebp]
	push	ecx
	call	??$_Iter_random@Vconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@V123@@std@@YA?AUforward_iterator_tag@0@ABVconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@0@Z ; std::_Iter_random<std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator,std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator>
	add	esp, 12					; 0000000cH
	mov	dl, BYTE PTR [eax]
	push	edx
	mov	eax, DWORD PTR __First2$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __First2$[ebp]
	push	ecx
	lea	edx, DWORD PTR __Last1$[ebp]
	push	edx
	lea	eax, DWORD PTR $T32532[ebp]
	push	eax
	call	??$_Checked_base@Vconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@std@@YA?AVconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@AAV120@@Z ; std::_Checked_base<std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator>
	add	esp, 8
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	lea	eax, DWORD PTR __First1$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T32533[ebp]
	push	ecx
	call	??$_Checked_base@Vconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@std@@YA?AVconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@AAV120@@Z ; std::_Checked_base<std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator>
	add	esp, 8
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	call	??$_Equal@Vconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@V123@Uforward_iterator_tag@3@@std@@YA_NVconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@00Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Equal<std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator,std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator,std::forward_iterator_tag>
	add	esp, 32					; 00000020H

; 2675 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$equal@Vconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@V123@@std@@YA_NVconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@00@Z ENDP ; std::equal<std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator,std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Iter_cat@Viterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@std@@YA?AUbidirectional_iterator_tag@0@ABViterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??$_Iter_cat@Viterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@std@@YA?AUbidirectional_iterator_tag@0@ABViterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@@Z PROC ; std::_Iter_cat<std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::iterator>, COMDAT

; 760  : 	{	// return category from iterator argument

	push	ebp
	mov	ebp, esp
	push	ecx

; 761  : 	typename iterator_traits<_Iter>::iterator_category _Cat;
; 762  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 763  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Iter_cat@Viterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@std@@YA?AUbidirectional_iterator_tag@0@ABViterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@@Z ENDP ; std::_Iter_cat<std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::iterator>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Distance2@Viterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@I@std@@YAXViterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@0AAIUbidirectional_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
__Off$ = 24						; size = 4
___formal$ = 28						; size = 1
??$_Distance2@Viterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@I@std@@YAXViterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@0AAIUbidirectional_iterator_tag@0@@Z PROC ; std::_Distance2<std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::iterator,unsigned int>, COMDAT

; 1628 : 	{	// add to _Off distance between bidirectional iterators (redundant)

	push	ebp
	mov	ebp, esp

; 1629 : 	for (; _First != _Last; ++_First)

	jmp	SHORT $LN3@Distance2@2
$LN2@Distance2@2:
	lea	ecx, DWORD PTR __First$[ebp]
	call	??Eiterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::iterator::operator++
$LN3@Distance2@2:
	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	call	??9const_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator::operator!=
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN4@Distance2@2

; 1630 : 		++_Off;

	mov	edx, DWORD PTR __Off$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, 1
	mov	ecx, DWORD PTR __Off$[ebp]
	mov	DWORD PTR [ecx], eax
	jmp	SHORT $LN2@Distance2@2
$LN4@Distance2@2:

; 1631 : 	}

	pop	ebp
	ret	0
??$_Distance2@Viterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@I@std@@YAXViterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@0AAIUbidirectional_iterator_tag@0@@Z ENDP ; std::_Distance2<std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::iterator,unsigned int>
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBV10@0PAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	??$_Checked_base@V?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@YAPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
PUBLIC	??$_Ptr_cat@V?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@0@AAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::_Ptr_cat<std::_Vector_const_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 8\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@0PAV12@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z
_TEXT	SEGMENT
$T32541 = -2						; size = 1
$T32540 = -1						; size = 1
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
__Dest$ = 24						; size = 4
__Al$ = 28						; size = 4
??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@0PAV12@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z PROC ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT

; 672  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 673  : 		return (_STD _Uninit_copy(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest, _Al,
; 674  : 			_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T32540[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@V?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@0@AAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::_Ptr_cat<std::_Vector_const_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
	add	esp, 8
	mov	BYTE PTR $T32541[ebp], al
	mov	al, BYTE PTR $T32540[ebp]
	push	eax
	mov	cl, BYTE PTR $T32541[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@V?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@YAPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@V?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@YAPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
	add	esp, 4
	push	eax
	call	??$_Uninit_copy@PBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBV10@0PAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
	add	esp, 24					; 00000018H

; 675  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@0PAV12@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z ENDP ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
PUBLIC	??$_Uninit_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	??$_Checked_base@V?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@0@@Z ; std::_Checked_base<std::_Vector_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
; Function compile flags: /Odtp
;	COMDAT ??$_Unchecked_uninitialized_move@V?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@0PAV12@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z
_TEXT	SEGMENT
$T32545 = -2						; size = 1
$T32544 = -1						; size = 1
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
__Dest$ = 24						; size = 4
__Al$ = 28						; size = 4
??$_Unchecked_uninitialized_move@V?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@0PAV12@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z PROC ; stdext::_Unchecked_uninitialized_move<std::_Vector_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT

; 692  : 	{	// move [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 693  : 		return (_STD _Uninit_move(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest, _Al,
; 694  : 			_STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T32544[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	??$_Move_cat@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA?AU_Swap_move_tag@0@ABQAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::_Move_cat<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
	add	esp, 4
	mov	BYTE PTR $T32545[ebp], al
	mov	dl, BYTE PTR $T32544[ebp]
	push	edx
	mov	al, BYTE PTR $T32545[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	call	??$_Checked_base@V?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@0@@Z ; std::_Checked_base<std::_Vector_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Checked_base@V?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@0@@Z ; std::_Checked_base<std::_Vector_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
	add	esp, 4
	push	eax
	call	??$_Uninit_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
	add	esp, 24					; 00000018H

; 695  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Unchecked_uninitialized_move@V?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@0PAV12@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z ENDP ; stdext::_Unchecked_uninitialized_move<std::_Vector_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 8\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAPBVPathArgument@Json@@PAPBV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPBVPathArgument@Json@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAPBVPathArgument@Json@@PAPBV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPBVPathArgument@Json@@0@Z PROC ; std::_Ptr_cat<Json::PathArgument const * *,Json::PathArgument const * *>, COMDAT

; 1291 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1292 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1293 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1294 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Ptr_cat@PAPBVPathArgument@Json@@PAPBV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPBVPathArgument@Json@@0@Z ENDP ; std::_Ptr_cat<Json::PathArgument const * *,Json::PathArgument const * *>
_TEXT	ENDS
PUBLIC	??$unchecked_fill_n@PAPBVPathArgument@Json@@IPBV12@@stdext@@YAXPAPBVPathArgument@Json@@IABQBV12@@Z ; stdext::unchecked_fill_n<Json::PathArgument const * *,unsigned int,Json::PathArgument const *>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 8\vc\include\memory
;	COMDAT ??$_Uninit_fill_n@PAPBVPathArgument@Json@@IPBV12@V?$allocator@PBVPathArgument@Json@@@std@@@std@@YAXPAPBVPathArgument@Json@@IABQBV12@AAV?$allocator@PBVPathArgument@Json@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_fill_n@PAPBVPathArgument@Json@@IPBV12@V?$allocator@PBVPathArgument@Json@@@std@@@std@@YAXPAPBVPathArgument@Json@@IABQBV12@AAV?$allocator@PBVPathArgument@Json@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<Json::PathArgument const * *,unsigned int,Json::PathArgument const *,std::allocator<Json::PathArgument const *> >, COMDAT

; 327  : 	{	// copy _Count *_Val to raw _First, using _Al, scalar type

	push	ebp
	mov	ebp, esp

; 328  : 		_STDEXT unchecked_fill_n(_First, _Count, _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$unchecked_fill_n@PAPBVPathArgument@Json@@IPBV12@@stdext@@YAXPAPBVPathArgument@Json@@IABQBV12@@Z ; stdext::unchecked_fill_n<Json::PathArgument const * *,unsigned int,Json::PathArgument const *>
	add	esp, 12					; 0000000cH

; 329  : 	}

	pop	ebp
	ret	0
??$_Uninit_fill_n@PAPBVPathArgument@Json@@IPBV12@V?$allocator@PBVPathArgument@Json@@@std@@@std@@YAXPAPBVPathArgument@Json@@IABQBV12@AAV?$allocator@PBVPathArgument@Json@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<Json::PathArgument const * *,unsigned int,Json::PathArgument const *,std::allocator<Json::PathArgument const *> >
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 8\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAVPathArgument@Json@@PAV12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVPathArgument@Json@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAVPathArgument@Json@@PAV12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVPathArgument@Json@@0@Z PROC ; std::_Ptr_cat<Json::PathArgument *,Json::PathArgument *>, COMDAT

; 1291 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1292 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1293 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1294 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Ptr_cat@PAVPathArgument@Json@@PAV12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVPathArgument@Json@@0@Z ENDP ; std::_Ptr_cat<Json::PathArgument *,Json::PathArgument *>
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@VPathArgument@Json@@@std@@QAEXPAVPathArgument@Json@@@Z ; std::allocator<Json::PathArgument>::destroy
PUBLIC	?construct@?$allocator@VPathArgument@Json@@@std@@QAEXPAVPathArgument@Json@@ABV34@@Z ; std::allocator<Json::PathArgument>::construct
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 8\vc\include\memory
xdata$x	SEGMENT
__catchsym$??$_Uninit_fill_n@PAVPathArgument@Json@@IV12@V?$allocator@VPathArgument@Json@@@std@@@std@@YAXPAVPathArgument@Json@@IABV12@AAV?$allocator@VPathArgument@Json@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_fill_n@PAVPathArgument@Json@@IV12@V?$allocator@VPathArgument@Json@@@std@@@std@@YAXPAVPathArgument@Json@@IABV12@AAV?$allocator@VPathArgument@Json@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_fill_n@PAVPathArgument@Json@@IV12@V?$allocator@VPathArgument@Json@@@std@@@std@@YAXPAVPathArgument@Json@@IABV12@AAV?$allocator@VPathArgument@Json@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_fill_n@PAVPathArgument@Json@@IV12@V?$allocator@VPathArgument@Json@@@std@@@std@@YAXPAVPathArgument@Json@@IABV12@AAV?$allocator@VPathArgument@Json@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_fill_n@PAVPathArgument@Json@@IV12@V?$allocator@VPathArgument@Json@@@std@@@std@@YAXPAVPathArgument@Json@@IABV12@AAV?$allocator@VPathArgument@Json@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_fill_n@PAVPathArgument@Json@@IV12@V?$allocator@VPathArgument@Json@@@std@@@std@@YAXPAVPathArgument@Json@@IABV12@AAV?$allocator@VPathArgument@Json@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_fill_n@PAVPathArgument@Json@@IV12@V?$allocator@VPathArgument@Json@@@std@@@std@@YAXPAVPathArgument@Json@@IABV12@AAV?$allocator@VPathArgument@Json@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_fill_n@PAVPathArgument@Json@@IV12@V?$allocator@VPathArgument@Json@@@std@@@std@@YAXPAVPathArgument@Json@@IABV12@AAV?$allocator@VPathArgument@Json@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??$_Uninit_fill_n@PAVPathArgument@Json@@IV12@V?$allocator@VPathArgument@Json@@@std@@@std@@YAXPAVPathArgument@Json@@IABV12@AAV?$allocator@VPathArgument@Json@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_fill_n@PAVPathArgument@Json@@IV12@V?$allocator@VPathArgument@Json@@@std@@@std@@YAXPAVPathArgument@Json@@IABV12@AAV?$allocator@VPathArgument@Json@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<Json::PathArgument *,unsigned int,Json::PathArgument,std::allocator<Json::PathArgument> >, COMDAT

; 302  : 	{	// copy _Count *_Val to raw _First, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_fill_n@PAVPathArgument@Json@@IV12@V?$allocator@VPathArgument@Json@@@std@@@std@@YAXPAVPathArgument@Json@@IABV12@AAV?$allocator@VPathArgument@Json@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 303  : 
; 304  :  #if _HAS_ITERATOR_DEBUGGING
; 305  : //	if (_Count < 0)
; 306  : //		_DEBUG_ERROR("negative count in uninitialized fill");
; 307  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 308  : 
; 309  : 	_FwdIt _Next = _First;

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 310  : 
; 311  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0
	jmp	SHORT $LN6@Uninit_fil
$LN5@Uninit_fil:

; 312  : 	for (; 0 < _Count; --_Count, ++_First)

	mov	ecx, DWORD PTR __Count$[ebp]
	sub	ecx, 1
	mov	DWORD PTR __Count$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 36					; 00000024H
	mov	DWORD PTR __First$[ebp], edx
$LN6@Uninit_fil:
	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN4@Uninit_fil

; 313  : 		_Al.construct(_First, _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?construct@?$allocator@VPathArgument@Json@@@std@@QAEXPAVPathArgument@Json@@ABV34@@Z ; std::allocator<Json::PathArgument>::construct
	jmp	SHORT $LN5@Uninit_fil
$LN4@Uninit_fil:

; 314  : 	_CATCH_ALL

	jmp	SHORT $LN10@Uninit_fil
__catch$??$_Uninit_fill_n@PAVPathArgument@Json@@IV12@V?$allocator@VPathArgument@Json@@@std@@@std@@YAXPAVPathArgument@Json@@IABV12@AAV?$allocator@VPathArgument@Json@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:
	jmp	SHORT $LN3@Uninit_fil
$LN2@Uninit_fil:

; 315  : 	for (; _Next != _First; ++_Next)

	mov	edx, DWORD PTR __Next$[ebp]
	add	edx, 36					; 00000024H
	mov	DWORD PTR __Next$[ebp], edx
$LN3@Uninit_fil:
	mov	eax, DWORD PTR __Next$[ebp]
	cmp	eax, DWORD PTR __First$[ebp]
	je	SHORT $LN1@Uninit_fil

; 316  : 		_Al.destroy(_Next);

	mov	ecx, DWORD PTR __Next$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?destroy@?$allocator@VPathArgument@Json@@@std@@QAEXPAVPathArgument@Json@@@Z ; std::allocator<Json::PathArgument>::destroy
	jmp	SHORT $LN2@Uninit_fil
$LN1@Uninit_fil:

; 317  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
	mov	eax, $LN9@Uninit_fil
	ret	0
$LN10@Uninit_fil:

; 318  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
$LN9@Uninit_fil:

; 319  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_fill_n@PAVPathArgument@Json@@IV12@V?$allocator@VPathArgument@Json@@@std@@@std@@YAXPAVPathArgument@Json@@IABV12@AAV?$allocator@VPathArgument@Json@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_fill_n@PAVPathArgument@Json@@IV12@V?$allocator@VPathArgument@Json@@@std@@@std@@YAXPAVPathArgument@Json@@IABV12@AAV?$allocator@VPathArgument@Json@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_fill_n@PAVPathArgument@Json@@IV12@V?$allocator@VPathArgument@Json@@@std@@@std@@YAXPAVPathArgument@Json@@IABV12@AAV?$allocator@VPathArgument@Json@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<Json::PathArgument *,unsigned int,Json::PathArgument,std::allocator<Json::PathArgument> >
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 8\vc\include\xutility
;	COMDAT ??$_Ptr_cat@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z PROC ; std::_Ptr_cat<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>, COMDAT

; 1291 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1292 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1293 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1294 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Ptr_cat@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ENDP ; std::_Ptr_cat<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::destroy
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 8\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT

; 233  : 	{	// destroy [_First, _Last), arbitrary type

	push	ebp
	mov	ebp, esp

; 234  : 	for (; _First != _Last; ++_First)

	jmp	SHORT $LN3@Destroy_ra
$LN2@Destroy_ra:
	mov	eax, DWORD PTR __First$[ebp]
	add	eax, 28					; 0000001cH
	mov	DWORD PTR __First$[ebp], eax
$LN3@Destroy_ra:
	mov	ecx, DWORD PTR __First$[ebp]
	cmp	ecx, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Destroy_ra

; 235  : 		_Al.destroy(_First);

	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?destroy@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::destroy
	jmp	SHORT $LN2@Destroy_ra
$LN4@Destroy_ra:

; 236  : 	}

	pop	ebp
	ret	0
??$_Destroy_range@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
PUBLIC	?construct@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@ABV32@@Z ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::construct
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 8\vc\include\memory
xdata$x	SEGMENT
__catchsym$??$_Uninit_fill_n@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IABV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_fill_n@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IABV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_fill_n@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IABV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_fill_n@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IABV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_fill_n@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IABV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_fill_n@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IABV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_fill_n@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IABV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_fill_n@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IABV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??$_Uninit_fill_n@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IABV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_fill_n@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IABV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT

; 302  : 	{	// copy _Count *_Val to raw _First, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_fill_n@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IABV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 303  : 
; 304  :  #if _HAS_ITERATOR_DEBUGGING
; 305  : //	if (_Count < 0)
; 306  : //		_DEBUG_ERROR("negative count in uninitialized fill");
; 307  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 308  : 
; 309  : 	_FwdIt _Next = _First;

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 310  : 
; 311  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0
	jmp	SHORT $LN6@Uninit_fil@2
$LN5@Uninit_fil@2:

; 312  : 	for (; 0 < _Count; --_Count, ++_First)

	mov	ecx, DWORD PTR __Count$[ebp]
	sub	ecx, 1
	mov	DWORD PTR __Count$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 28					; 0000001cH
	mov	DWORD PTR __First$[ebp], edx
$LN6@Uninit_fil@2:
	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN4@Uninit_fil@2

; 313  : 		_Al.construct(_First, _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?construct@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@ABV32@@Z ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::construct
	jmp	SHORT $LN5@Uninit_fil@2
$LN4@Uninit_fil@2:

; 314  : 	_CATCH_ALL

	jmp	SHORT $LN10@Uninit_fil@2
__catch$??$_Uninit_fill_n@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IABV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:
	jmp	SHORT $LN3@Uninit_fil@2
$LN2@Uninit_fil@2:

; 315  : 	for (; _Next != _First; ++_Next)

	mov	edx, DWORD PTR __Next$[ebp]
	add	edx, 28					; 0000001cH
	mov	DWORD PTR __Next$[ebp], edx
$LN3@Uninit_fil@2:
	mov	eax, DWORD PTR __Next$[ebp]
	cmp	eax, DWORD PTR __First$[ebp]
	je	SHORT $LN1@Uninit_fil@2

; 316  : 		_Al.destroy(_Next);

	mov	ecx, DWORD PTR __Next$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?destroy@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::destroy
	jmp	SHORT $LN2@Uninit_fil@2
$LN1@Uninit_fil@2:

; 317  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
	mov	eax, $LN9@Uninit_fil@2
	ret	0
$LN10@Uninit_fil@2:

; 318  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
$LN9@Uninit_fil@2:

; 319  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_fill_n@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IABV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_fill_n@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IABV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_fill_n@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IABV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 8\vc\include\xmemory
;	COMDAT ??$_Destroy_range@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@YAXPAPBVPathArgument@Json@@0AAV?$allocator@PBVPathArgument@Json@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@YAXPAPBVPathArgument@Json@@0AAV?$allocator@PBVPathArgument@Json@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >, COMDAT

; 242  : 	{	// destroy [_First, _Last), scalar type (do nothing)

	push	ebp
	mov	ebp, esp

; 243  : 	}

	pop	ebp
	ret	0
??$_Destroy_range@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@YAXPAPBVPathArgument@Json@@0AAV?$allocator@PBVPathArgument@Json@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >
_TEXT	ENDS
PUBLIC	??$_Uninit_move@PAPBVPathArgument@Json@@PAPBV12@V?$allocator@PBVPathArgument@Json@@@std@@U_Undefined_move_tag@4@@std@@YAPAPBVPathArgument@Json@@PAPBV12@00AAV?$allocator@PBVPathArgument@Json@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<Json::PathArgument const * *,Json::PathArgument const * *,std::allocator<Json::PathArgument const *>,std::_Undefined_move_tag>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 8\vc\include\memory
;	COMDAT ??$_Unchecked_uninitialized_move@PAPBVPathArgument@Json@@PAPBV12@V?$allocator@PBVPathArgument@Json@@@std@@@stdext@@YAPAPBVPathArgument@Json@@PAPBV12@00AAV?$allocator@PBVPathArgument@Json@@@std@@@Z
_TEXT	SEGMENT
$T32589 = -2						; size = 1
$T32588 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Unchecked_uninitialized_move@PAPBVPathArgument@Json@@PAPBV12@V?$allocator@PBVPathArgument@Json@@@std@@@stdext@@YAPAPBVPathArgument@Json@@PAPBV12@00AAV?$allocator@PBVPathArgument@Json@@@std@@@Z PROC ; stdext::_Unchecked_uninitialized_move<Json::PathArgument const * *,Json::PathArgument const * *,std::allocator<Json::PathArgument const *> >, COMDAT

; 692  : 	{	// move [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 693  : 		return (_STD _Uninit_move(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest, _Al,
; 694  : 			_STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T32588[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	??$_Move_cat@PAPBVPathArgument@Json@@@std@@YA?AU_Undefined_move_tag@0@ABQAPBVPathArgument@Json@@@Z ; std::_Move_cat<Json::PathArgument const * *>
	add	esp, 4
	mov	BYTE PTR $T32589[ebp], al
	mov	dl, BYTE PTR $T32588[ebp]
	push	edx
	mov	al, BYTE PTR $T32589[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	call	??$_Checked_base@PAPBVPathArgument@Json@@@std@@YAPAPBVPathArgument@Json@@AAPAPBV12@@Z ; std::_Checked_base<Json::PathArgument const * *>
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Checked_base@PAPBVPathArgument@Json@@@std@@YAPAPBVPathArgument@Json@@AAPAPBV12@@Z ; std::_Checked_base<Json::PathArgument const * *>
	add	esp, 4
	push	eax
	call	??$_Uninit_move@PAPBVPathArgument@Json@@PAPBV12@V?$allocator@PBVPathArgument@Json@@@std@@U_Undefined_move_tag@4@@std@@YAPAPBVPathArgument@Json@@PAPBV12@00AAV?$allocator@PBVPathArgument@Json@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<Json::PathArgument const * *,Json::PathArgument const * *,std::allocator<Json::PathArgument const *>,std::_Undefined_move_tag>
	add	esp, 24					; 00000018H

; 695  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Unchecked_uninitialized_move@PAPBVPathArgument@Json@@PAPBV12@V?$allocator@PBVPathArgument@Json@@@std@@@stdext@@YAPAPBVPathArgument@Json@@PAPBV12@00AAV?$allocator@PBVPathArgument@Json@@@std@@@Z ENDP ; stdext::_Unchecked_uninitialized_move<Json::PathArgument const * *,Json::PathArgument const * *,std::allocator<Json::PathArgument const *> >
_TEXT	ENDS
PUBLIC	??$_Checked_base@PAPBVPathArgument@Json@@@std@@YAPAPBVPathArgument@Json@@AAPAPBV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<Json::PathArgument const * *>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 8\vc\include\xutility
;	COMDAT ??$_Checked_base@PAPBVPathArgument@Json@@@std@@YAPAPBVPathArgument@Json@@AAPAPBV12@@Z
_TEXT	SEGMENT
__Base_tag$ = -1					; size = 1
__It$ = 8						; size = 4
??$_Checked_base@PAPBVPathArgument@Json@@@std@@YAPAPBVPathArgument@Json@@AAPAPBV12@@Z PROC ; std::_Checked_base<Json::PathArgument const * *>, COMDAT

; 971  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 972  : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 973  : 		return _Checked_base(_It, _Base_tag);

	mov	al, BYTE PTR __Base_tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR __It$[ebp]
	push	ecx
	call	??$_Checked_base@PAPBVPathArgument@Json@@@std@@YAPAPBVPathArgument@Json@@AAPAPBV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<Json::PathArgument const * *>
	add	esp, 8

; 974  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Checked_base@PAPBVPathArgument@Json@@@std@@YAPAPBVPathArgument@Json@@AAPAPBV12@@Z ENDP ; std::_Checked_base<Json::PathArgument const * *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Fill@PAPBVPathArgument@Json@@PBV12@@std@@YAXPAPBVPathArgument@Json@@0ABQBV12@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$_Fill@PAPBVPathArgument@Json@@PBV12@@std@@YAXPAPBVPathArgument@Json@@0ABQBV12@@Z PROC ; std::_Fill<Json::PathArgument const * *,Json::PathArgument const *>, COMDAT

; 2723 : 	{	// copy _Val through [_First, _Last)

	push	ebp
	mov	ebp, esp

; 2724 : 	_DEBUG_RANGE(_First, _Last);
; 2725 : 	for (; _First != _Last; ++_First)

	jmp	SHORT $LN3@Fill
$LN2@Fill:
	mov	eax, DWORD PTR __First$[ebp]
	add	eax, 4
	mov	DWORD PTR __First$[ebp], eax
$LN3@Fill:
	mov	ecx, DWORD PTR __First$[ebp]
	cmp	ecx, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Fill

; 2726 : 		*_First = _Val;

	mov	edx, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	jmp	SHORT $LN2@Fill
$LN4@Fill:

; 2727 : 	}

	pop	ebp
	ret	0
??$_Fill@PAPBVPathArgument@Json@@PBV12@@std@@YAXPAPBVPathArgument@Json@@0ABQBV12@@Z ENDP ; std::_Fill<Json::PathArgument const * *,Json::PathArgument const *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Iter_random@PAPBVPathArgument@Json@@PAPBV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPBVPathArgument@Json@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAPBVPathArgument@Json@@PAPBV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPBVPathArgument@Json@@0@Z PROC ; std::_Iter_random<Json::PathArgument const * *,Json::PathArgument const * *>, COMDAT

; 801  : 	{	// return category from iterator argument

	push	ebp
	mov	ebp, esp
	push	ecx

; 802  : 	typename _Iter_random_helper<
; 803  : 		iterator_traits<_Iter1>::iterator_category, 
; 804  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 805  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 806  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Iter_random@PAPBVPathArgument@Json@@PAPBV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPBVPathArgument@Json@@0@Z ENDP ; std::_Iter_random<Json::PathArgument const * *,Json::PathArgument const * *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Move_cat@PAPBVPathArgument@Json@@@std@@YA?AU_Undefined_move_tag@0@ABQAPBVPathArgument@Json@@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
??$_Move_cat@PAPBVPathArgument@Json@@@std@@YA?AU_Undefined_move_tag@0@ABQAPBVPathArgument@Json@@@Z PROC ; std::_Move_cat<Json::PathArgument const * *>, COMDAT

; 1008 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1009 : 		typename _Move_operation_category<typename iterator_traits<_Iter>::value_type>::_Move_cat _Cat;
; 1010 : 		return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1011 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Move_cat@PAPBVPathArgument@Json@@@std@@YA?AU_Undefined_move_tag@0@ABQAPBVPathArgument@Json@@@Z ENDP ; std::_Move_cat<Json::PathArgument const * *>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAPBVPathArgument@Json@@PAPBV12@Urandom_access_iterator_tag@std@@@std@@YAPAPBVPathArgument@Json@@PAPBV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<Json::PathArgument const * *,Json::PathArgument const * *,std::random_access_iterator_tag>
; Function compile flags: /Odtp
;	COMDAT ??$_Move_backward_opt@PAPBVPathArgument@Json@@PAPBV12@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@4@@std@@YAPAPBVPathArgument@Json@@PAPBV12@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T32601 = -2						; size = 1
$T32600 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__First_dest_cat$ = 20					; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Move_backward_opt@PAPBVPathArgument@Json@@PAPBV12@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@4@@std@@YAPAPBVPathArgument@Json@@PAPBV12@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Move_backward_opt<Json::PathArgument const * *,Json::PathArgument const * *,std::random_access_iterator_tag,std::_Undefined_move_tag>, COMDAT

; 2412 : 	{	// move defaults to copy if there is not a more effecient way

	push	ebp
	mov	ebp, esp
	push	ecx

; 2413 : 	return _Copy_backward_opt(_First, _Last, _Dest,
; 2414 : 		_First_dest_cat, _Ptr_cat(_First, _Dest), _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T32600[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAPBVPathArgument@Json@@PAPBV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPBVPathArgument@Json@@0@Z ; std::_Ptr_cat<Json::PathArgument const * *,Json::PathArgument const * *>
	add	esp, 8
	mov	BYTE PTR $T32601[ebp], al
	mov	al, BYTE PTR $T32600[ebp]
	push	eax
	mov	cl, BYTE PTR $T32601[ebp]
	push	ecx
	mov	dl, BYTE PTR __First_dest_cat$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Copy_backward_opt@PAPBVPathArgument@Json@@PAPBV12@Urandom_access_iterator_tag@std@@@std@@YAPAPBVPathArgument@Json@@PAPBV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<Json::PathArgument const * *,Json::PathArgument const * *,std::random_access_iterator_tag>
	add	esp, 24					; 00000018H

; 2415 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Move_backward_opt@PAPBVPathArgument@Json@@PAPBV12@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@4@@std@@YAPAPBVPathArgument@Json@@PAPBV12@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Move_backward_opt<Json::PathArgument const * *,Json::PathArgument const * *,std::random_access_iterator_tag,std::_Undefined_move_tag>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 8\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@YAXPAVPathArgument@Json@@0AAV?$allocator@VPathArgument@Json@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@YAXPAVPathArgument@Json@@0AAV?$allocator@VPathArgument@Json@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<Json::PathArgument,std::allocator<Json::PathArgument> >, COMDAT

; 233  : 	{	// destroy [_First, _Last), arbitrary type

	push	ebp
	mov	ebp, esp

; 234  : 	for (; _First != _Last; ++_First)

	jmp	SHORT $LN3@Destroy_ra@2
$LN2@Destroy_ra@2:
	mov	eax, DWORD PTR __First$[ebp]
	add	eax, 36					; 00000024H
	mov	DWORD PTR __First$[ebp], eax
$LN3@Destroy_ra@2:
	mov	ecx, DWORD PTR __First$[ebp]
	cmp	ecx, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Destroy_ra@2

; 235  : 		_Al.destroy(_First);

	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?destroy@?$allocator@VPathArgument@Json@@@std@@QAEXPAVPathArgument@Json@@@Z ; std::allocator<Json::PathArgument>::destroy
	jmp	SHORT $LN2@Destroy_ra@2
$LN4@Destroy_ra@2:

; 236  : 	}

	pop	ebp
	ret	0
??$_Destroy_range@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@YAXPAVPathArgument@Json@@0AAV?$allocator@VPathArgument@Json@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<Json::PathArgument,std::allocator<Json::PathArgument> >
_TEXT	ENDS
PUBLIC	??$_Uninit_move@PAVPathArgument@Json@@PAV12@V?$allocator@VPathArgument@Json@@@std@@U_Undefined_move_tag@4@@std@@YAPAVPathArgument@Json@@PAV12@00AAV?$allocator@VPathArgument@Json@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<Json::PathArgument *,Json::PathArgument *,std::allocator<Json::PathArgument>,std::_Undefined_move_tag>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 8\vc\include\memory
;	COMDAT ??$_Unchecked_uninitialized_move@PAVPathArgument@Json@@PAV12@V?$allocator@VPathArgument@Json@@@std@@@stdext@@YAPAVPathArgument@Json@@PAV12@00AAV?$allocator@VPathArgument@Json@@@std@@@Z
_TEXT	SEGMENT
$T32607 = -2						; size = 1
$T32606 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Unchecked_uninitialized_move@PAVPathArgument@Json@@PAV12@V?$allocator@VPathArgument@Json@@@std@@@stdext@@YAPAVPathArgument@Json@@PAV12@00AAV?$allocator@VPathArgument@Json@@@std@@@Z PROC ; stdext::_Unchecked_uninitialized_move<Json::PathArgument *,Json::PathArgument *,std::allocator<Json::PathArgument> >, COMDAT

; 692  : 	{	// move [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 693  : 		return (_STD _Uninit_move(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest, _Al,
; 694  : 			_STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T32606[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	??$_Move_cat@PAVPathArgument@Json@@@std@@YA?AU_Undefined_move_tag@0@ABQAVPathArgument@Json@@@Z ; std::_Move_cat<Json::PathArgument *>
	add	esp, 4
	mov	BYTE PTR $T32607[ebp], al
	mov	dl, BYTE PTR $T32606[ebp]
	push	edx
	mov	al, BYTE PTR $T32607[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	call	??$_Checked_base@PAVPathArgument@Json@@@std@@YAPAVPathArgument@Json@@AAPAV12@@Z ; std::_Checked_base<Json::PathArgument *>
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Checked_base@PAVPathArgument@Json@@@std@@YAPAVPathArgument@Json@@AAPAV12@@Z ; std::_Checked_base<Json::PathArgument *>
	add	esp, 4
	push	eax
	call	??$_Uninit_move@PAVPathArgument@Json@@PAV12@V?$allocator@VPathArgument@Json@@@std@@U_Undefined_move_tag@4@@std@@YAPAVPathArgument@Json@@PAV12@00AAV?$allocator@VPathArgument@Json@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<Json::PathArgument *,Json::PathArgument *,std::allocator<Json::PathArgument>,std::_Undefined_move_tag>
	add	esp, 24					; 00000018H

; 695  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Unchecked_uninitialized_move@PAVPathArgument@Json@@PAV12@V?$allocator@VPathArgument@Json@@@std@@@stdext@@YAPAVPathArgument@Json@@PAV12@00AAV?$allocator@VPathArgument@Json@@@std@@@Z ENDP ; stdext::_Unchecked_uninitialized_move<Json::PathArgument *,Json::PathArgument *,std::allocator<Json::PathArgument> >
_TEXT	ENDS
PUBLIC	??$_Checked_base@PAVPathArgument@Json@@@std@@YAPAVPathArgument@Json@@AAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<Json::PathArgument *>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 8\vc\include\xutility
;	COMDAT ??$_Checked_base@PAVPathArgument@Json@@@std@@YAPAVPathArgument@Json@@AAPAV12@@Z
_TEXT	SEGMENT
__Base_tag$ = -1					; size = 1
__It$ = 8						; size = 4
??$_Checked_base@PAVPathArgument@Json@@@std@@YAPAVPathArgument@Json@@AAPAV12@@Z PROC ; std::_Checked_base<Json::PathArgument *>, COMDAT

; 971  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 972  : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 973  : 		return _Checked_base(_It, _Base_tag);

	mov	al, BYTE PTR __Base_tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR __It$[ebp]
	push	ecx
	call	??$_Checked_base@PAVPathArgument@Json@@@std@@YAPAVPathArgument@Json@@AAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<Json::PathArgument *>
	add	esp, 8

; 974  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Checked_base@PAVPathArgument@Json@@@std@@YAPAVPathArgument@Json@@AAPAV12@@Z ENDP ; std::_Checked_base<Json::PathArgument *>
_TEXT	ENDS
PUBLIC	??4PathArgument@Json@@QAEAAV01@ABV01@@Z		; Json::PathArgument::operator=
; Function compile flags: /Odtp
;	COMDAT ??$_Fill@PAVPathArgument@Json@@V12@@std@@YAXPAVPathArgument@Json@@0ABV12@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$_Fill@PAVPathArgument@Json@@V12@@std@@YAXPAVPathArgument@Json@@0ABV12@@Z PROC ; std::_Fill<Json::PathArgument *,Json::PathArgument>, COMDAT

; 2723 : 	{	// copy _Val through [_First, _Last)

	push	ebp
	mov	ebp, esp

; 2724 : 	_DEBUG_RANGE(_First, _Last);
; 2725 : 	for (; _First != _Last; ++_First)

	jmp	SHORT $LN3@Fill@2
$LN2@Fill@2:
	mov	eax, DWORD PTR __First$[ebp]
	add	eax, 36					; 00000024H
	mov	DWORD PTR __First$[ebp], eax
$LN3@Fill@2:
	mov	ecx, DWORD PTR __First$[ebp]
	cmp	ecx, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Fill@2

; 2726 : 		*_First = _Val;

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	ecx, DWORD PTR __First$[ebp]
	call	??4PathArgument@Json@@QAEAAV01@ABV01@@Z
	jmp	SHORT $LN2@Fill@2
$LN4@Fill@2:

; 2727 : 	}

	pop	ebp
	ret	0
??$_Fill@PAVPathArgument@Json@@V12@@std@@YAXPAVPathArgument@Json@@0ABV12@@Z ENDP ; std::_Fill<Json::PathArgument *,Json::PathArgument>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Iter_random@PAVPathArgument@Json@@PAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVPathArgument@Json@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAVPathArgument@Json@@PAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVPathArgument@Json@@0@Z PROC ; std::_Iter_random<Json::PathArgument *,Json::PathArgument *>, COMDAT

; 801  : 	{	// return category from iterator argument

	push	ebp
	mov	ebp, esp
	push	ecx

; 802  : 	typename _Iter_random_helper<
; 803  : 		iterator_traits<_Iter1>::iterator_category, 
; 804  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 805  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 806  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Iter_random@PAVPathArgument@Json@@PAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVPathArgument@Json@@0@Z ENDP ; std::_Iter_random<Json::PathArgument *,Json::PathArgument *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Move_cat@PAVPathArgument@Json@@@std@@YA?AU_Undefined_move_tag@0@ABQAVPathArgument@Json@@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
??$_Move_cat@PAVPathArgument@Json@@@std@@YA?AU_Undefined_move_tag@0@ABQAVPathArgument@Json@@@Z PROC ; std::_Move_cat<Json::PathArgument *>, COMDAT

; 1008 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1009 : 		typename _Move_operation_category<typename iterator_traits<_Iter>::value_type>::_Move_cat _Cat;
; 1010 : 		return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1011 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Move_cat@PAVPathArgument@Json@@@std@@YA?AU_Undefined_move_tag@0@ABQAVPathArgument@Json@@@Z ENDP ; std::_Move_cat<Json::PathArgument *>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAVPathArgument@Json@@PAV12@@std@@YAPAVPathArgument@Json@@PAV12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<Json::PathArgument *,Json::PathArgument *>
; Function compile flags: /Odtp
;	COMDAT ??$_Move_backward_opt@PAVPathArgument@Json@@PAV12@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@4@@std@@YAPAVPathArgument@Json@@PAV12@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T32619 = -2						; size = 1
$T32618 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__First_dest_cat$ = 20					; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Move_backward_opt@PAVPathArgument@Json@@PAV12@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@4@@std@@YAPAVPathArgument@Json@@PAV12@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Move_backward_opt<Json::PathArgument *,Json::PathArgument *,std::random_access_iterator_tag,std::_Undefined_move_tag>, COMDAT

; 2412 : 	{	// move defaults to copy if there is not a more effecient way

	push	ebp
	mov	ebp, esp
	push	ecx

; 2413 : 	return _Copy_backward_opt(_First, _Last, _Dest,
; 2414 : 		_First_dest_cat, _Ptr_cat(_First, _Dest), _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T32618[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAVPathArgument@Json@@PAV12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVPathArgument@Json@@0@Z ; std::_Ptr_cat<Json::PathArgument *,Json::PathArgument *>
	add	esp, 8
	mov	BYTE PTR $T32619[ebp], al
	mov	al, BYTE PTR $T32618[ebp]
	push	eax
	mov	cl, BYTE PTR $T32619[ebp]
	push	ecx
	mov	dl, BYTE PTR __First_dest_cat$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Copy_backward_opt@PAVPathArgument@Json@@PAV12@@std@@YAPAVPathArgument@Json@@PAV12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<Json::PathArgument *,Json::PathArgument *>
	add	esp, 24					; 00000018H

; 2415 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Move_backward_opt@PAVPathArgument@Json@@PAV12@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@4@@std@@YAPAVPathArgument@Json@@PAV12@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Move_backward_opt<Json::PathArgument *,Json::PathArgument *,std::random_access_iterator_tag,std::_Undefined_move_tag>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 8\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$_Unchecked_uninitialized_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@00AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z
_TEXT	SEGMENT
$T32623 = -2						; size = 1
$T32622 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Unchecked_uninitialized_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@00AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z PROC ; stdext::_Unchecked_uninitialized_move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT

; 692  : 	{	// move [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 693  : 		return (_STD _Uninit_move(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest, _Al,
; 694  : 			_STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T32622[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	??$_Move_cat@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA?AU_Swap_move_tag@0@ABQAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::_Move_cat<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
	add	esp, 4
	mov	BYTE PTR $T32623[ebp], al
	mov	dl, BYTE PTR $T32622[ebp]
	push	edx
	mov	al, BYTE PTR $T32623[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	call	??$_Checked_base@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAPAV10@@Z ; std::_Checked_base<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Checked_base@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAPAV10@@Z ; std::_Checked_base<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
	add	esp, 4
	push	eax
	call	??$_Uninit_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
	add	esp, 24					; 00000018H

; 695  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Unchecked_uninitialized_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@stdext@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@00AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@Z ENDP ; stdext::_Unchecked_uninitialized_move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
PUBLIC	??$_Checked_base@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAPAV10@U_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 8\vc\include\xutility
;	COMDAT ??$_Checked_base@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAPAV10@@Z
_TEXT	SEGMENT
__Base_tag$ = -1					; size = 1
__It$ = 8						; size = 4
??$_Checked_base@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAPAV10@@Z PROC ; std::_Checked_base<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>, COMDAT

; 971  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 972  : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 973  : 		return _Checked_base(_It, _Base_tag);

	mov	al, BYTE PTR __Base_tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR __It$[ebp]
	push	ecx
	call	??$_Checked_base@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAPAV10@U_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
	add	esp, 8

; 974  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Checked_base@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAPAV10@@Z ENDP ; std::_Checked_base<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
_TEXT	ENDS
EXTRN	__imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z:PROC
; Function compile flags: /Odtp
;	COMDAT ??$_Fill@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0ABV10@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$_Fill@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0ABV10@@Z PROC ; std::_Fill<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT

; 2723 : 	{	// copy _Val through [_First, _Last)

	push	ebp
	mov	ebp, esp

; 2724 : 	_DEBUG_RANGE(_First, _Last);
; 2725 : 	for (; _First != _Last; ++_First)

	jmp	SHORT $LN3@Fill@3
$LN2@Fill@3:
	mov	eax, DWORD PTR __First$[ebp]
	add	eax, 28					; 0000001cH
	mov	DWORD PTR __First$[ebp], eax
$LN3@Fill@3:
	mov	ecx, DWORD PTR __First$[ebp]
	cmp	ecx, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Fill@3

; 2726 : 		*_First = _Val;

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	ecx, DWORD PTR __First$[ebp]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	jmp	SHORT $LN2@Fill@3
$LN4@Fill@3:

; 2727 : 	}

	pop	ebp
	ret	0
??$_Fill@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0ABV10@@Z ENDP ; std::_Fill<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Iter_random@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z PROC ; std::_Iter_random<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>, COMDAT

; 801  : 	{	// return category from iterator argument

	push	ebp
	mov	ebp, esp
	push	ecx

; 802  : 	typename _Iter_random_helper<
; 803  : 		iterator_traits<_Iter1>::iterator_category, 
; 804  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 805  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 806  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Iter_random@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ENDP ; std::_Iter_random<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Move_cat@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA?AU_Swap_move_tag@0@ABQAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
??$_Move_cat@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA?AU_Swap_move_tag@0@ABQAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z PROC ; std::_Move_cat<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>, COMDAT

; 1008 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1009 : 		typename _Move_operation_category<typename iterator_traits<_Iter>::value_type>::_Move_cat _Cat;
; 1010 : 		return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1011 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Move_cat@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA?AU_Swap_move_tag@0@ABQAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ENDP ; std::_Move_cat<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
_TEXT	ENDS
PUBLIC	??$_Move_backward_opt@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@Uforward_iterator_tag@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00Uforward_iterator_tag@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::forward_iterator_tag>
; Function compile flags: /Odtp
;	COMDAT ??$_Move_backward_opt@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00Urandom_access_iterator_tag@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T32635 = -6						; size = 1
$T32634 = -5						; size = 1
__Result$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
__Move_cat$ = 24					; size = 1
___formal$ = 28						; size = 1
??$_Move_backward_opt@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00Urandom_access_iterator_tag@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Move_backward_opt<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>, COMDAT

; 2433 : 	{	// use swap to instead of the copy constructor

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2434 : 	// if _OutIt is range checked, this will make sure there is enough space for the copy
; 2435 : 	_BidIt2 _Result = _Dest - (_Last - _First);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	cdq
	mov	ecx, 28					; 0000001cH
	idiv	ecx
	imul	eax, 28					; 0000001cH
	mov	edx, DWORD PTR __Dest$[ebp]
	sub	edx, eax
	mov	DWORD PTR __Result$[ebp], edx

; 2436 : 	_Move_backward_opt(_First, _Last, _CHECKED_BASE(_Dest),
; 2437 : 		forward_iterator_tag(), _Move_cat, _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T32634[ebp], al
	mov	cl, BYTE PTR $T32634[ebp]
	push	ecx
	mov	dl, BYTE PTR __Move_cat$[ebp]
	push	edx
	mov	al, BYTE PTR $T32635[ebp]
	push	eax
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	??$_Checked_base@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAPAV10@@Z ; std::_Checked_base<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Move_backward_opt@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@Uforward_iterator_tag@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00Uforward_iterator_tag@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::forward_iterator_tag>
	add	esp, 24					; 00000018H

; 2438 : 	return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 2439 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Move_backward_opt@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00Urandom_access_iterator_tag@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Move_backward_opt<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??4PathArgument@Json@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4PathArgument@Json@@QAEAAV01@ABV01@@Z PROC		; Json::PathArgument::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	DWORD PTR [ecx+28], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	DWORD PTR [ecx+32], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4PathArgument@Json@@QAEAAV01@ABV01@@Z ENDP		; Json::PathArgument::operator=
_TEXT	ENDS
PUBLIC	??$_Construct@VPathArgument@Json@@V12@@std@@YAXPAVPathArgument@Json@@ABV12@@Z ; std::_Construct<Json::PathArgument,Json::PathArgument>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 8\vc\include\xmemory
;	COMDAT ?construct@?$allocator@VPathArgument@Json@@@std@@QAEXPAVPathArgument@Json@@ABV34@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@VPathArgument@Json@@@std@@QAEXPAVPathArgument@Json@@ABV34@@Z PROC ; std::allocator<Json::PathArgument>::construct, COMDAT
; _this$ = ecx

; 155  : 		{	// construct object at _Ptr with value _Val

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 156  : 		_Construct(_Ptr, _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	call	??$_Construct@VPathArgument@Json@@V12@@std@@YAXPAVPathArgument@Json@@ABV12@@Z ; std::_Construct<Json::PathArgument,Json::PathArgument>
	add	esp, 8

; 157  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?construct@?$allocator@VPathArgument@Json@@@std@@QAEXPAVPathArgument@Json@@ABV34@@Z ENDP ; std::allocator<Json::PathArgument>::construct
_TEXT	ENDS
PUBLIC	??$_Destroy@VPathArgument@Json@@@std@@YAXPAVPathArgument@Json@@@Z ; std::_Destroy<Json::PathArgument>
; Function compile flags: /Odtp
;	COMDAT ?destroy@?$allocator@VPathArgument@Json@@@std@@QAEXPAVPathArgument@Json@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?destroy@?$allocator@VPathArgument@Json@@@std@@QAEXPAVPathArgument@Json@@@Z PROC ; std::allocator<Json::PathArgument>::destroy, COMDAT
; _this$ = ecx

; 160  : 		{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 161  : 		_Destroy(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??$_Destroy@VPathArgument@Json@@@std@@YAXPAVPathArgument@Json@@@Z ; std::_Destroy<Json::PathArgument>
	add	esp, 4

; 162  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?destroy@?$allocator@VPathArgument@Json@@@std@@QAEXPAVPathArgument@Json@@@Z ENDP ; std::allocator<Json::PathArgument>::destroy
_TEXT	ENDS
PUBLIC	??$_Construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@@Z ; std::_Construct<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
; Function compile flags: /Odtp
;	COMDAT ?construct@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@ABV32@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@ABV32@@Z PROC ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::construct, COMDAT
; _this$ = ecx

; 155  : 		{	// construct object at _Ptr with value _Val

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 156  : 		_Construct(_Ptr, _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	call	??$_Construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@@Z ; std::_Construct<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
	add	esp, 8

; 157  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?construct@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@ABV32@@Z ENDP ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::construct
_TEXT	ENDS
PUBLIC	??$_Destroy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::_Destroy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
; Function compile flags: /Odtp
;	COMDAT ?destroy@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?destroy@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z PROC ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::destroy, COMDAT
; _this$ = ecx

; 160  : 		{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 161  : 		_Destroy(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??$_Destroy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::_Destroy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
	add	esp, 4

; 162  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?destroy@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ENDP ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::destroy
_TEXT	ENDS
PUBLIC	??$_Checked_base@Vconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@std@@YA?AVconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@AAV120@U_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 8\vc\include\xutility
;	COMDAT ??$_Checked_base@Vconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@std@@YA?AVconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@AAV120@@Z
_TEXT	SEGMENT
__Base_tag$ = -1					; size = 1
___$ReturnUdt$ = 8					; size = 4
__It$ = 12						; size = 4
??$_Checked_base@Vconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@std@@YA?AVconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@AAV120@@Z PROC ; std::_Checked_base<std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator>, COMDAT

; 971  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 972  : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 973  : 		return _Checked_base(_It, _Base_tag);

	mov	al, BYTE PTR __Base_tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR __It$[ebp]
	push	ecx
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	call	??$_Checked_base@Vconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@std@@YA?AVconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@AAV120@U_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator>
	add	esp, 12					; 0000000cH
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 974  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Checked_base@Vconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@std@@YA?AVconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@AAV120@@Z ENDP ; std::_Checked_base<std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator>
_TEXT	ENDS
PUBLIC	??$?M$$CBVCZString@Value@Json@@V12@@std@@YA_NABU?$pair@$$CBVCZString@Value@Json@@V23@@0@0@Z ; std::operator<<Json::Value::CZString const ,Json::Value>
; Function compile flags: /Odtp
;	COMDAT ??$_Lexicographical_compare@Vconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@V123@@std@@YA_NVconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@000@Z
_TEXT	SEGMENT
tv136 = -4						; size = 4
__First1$ = 8						; size = 8
__Last1$ = 16						; size = 8
__First2$ = 24						; size = 8
__Last2$ = 32						; size = 8
??$_Lexicographical_compare@Vconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@V123@@std@@YA_NVconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@000@Z PROC ; std::_Lexicographical_compare<std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator,std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator>, COMDAT

; 2848 : 	{	// order [_First1, _Last1) vs. [First2, Last2)

	push	ebp
	mov	ebp, esp
	push	ecx

; 2849 : 	_DEBUG_RANGE(_First1, _Last1);
; 2850 : 	_DEBUG_RANGE(_First2, _Last2);
; 2851 : 	for (; _First1 != _Last1 && _First2 != _Last2; ++_First1, ++_First2)

	jmp	SHORT $LN6@Lexicograp
$LN5@Lexicograp:
	lea	ecx, DWORD PTR __First1$[ebp]
	call	??Econst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator::operator++
	lea	ecx, DWORD PTR __First2$[ebp]
	call	??Econst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator::operator++
$LN6@Lexicograp:
	lea	eax, DWORD PTR __Last1$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First1$[ebp]
	call	??9const_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator::operator!=
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN4@Lexicograp
	lea	edx, DWORD PTR __Last2$[ebp]
	push	edx
	lea	ecx, DWORD PTR __First2$[ebp]
	call	??9const_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator::operator!=
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN4@Lexicograp

; 2852 : 		if (_DEBUG_LT(*_First1, *_First2))

	lea	ecx, DWORD PTR __First2$[ebp]
	call	??Dconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBEABU?$pair@$$CBVCZString@Value@Json@@V23@@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator::operator*
	push	eax
	lea	ecx, DWORD PTR __First1$[ebp]
	call	??Dconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBEABU?$pair@$$CBVCZString@Value@Json@@V23@@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator::operator*
	push	eax
	call	??$?M$$CBVCZString@Value@Json@@V12@@std@@YA_NABU?$pair@$$CBVCZString@Value@Json@@V23@@0@0@Z ; std::operator<<Json::Value::CZString const ,Json::Value>
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN3@Lexicograp

; 2853 : 			return (true);

	mov	al, 1
	jmp	SHORT $LN7@Lexicograp
	jmp	SHORT $LN2@Lexicograp
$LN3@Lexicograp:

; 2854 : 		else if (*_First2 < *_First1)

	lea	ecx, DWORD PTR __First1$[ebp]
	call	??Dconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBEABU?$pair@$$CBVCZString@Value@Json@@V23@@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator::operator*
	push	eax
	lea	ecx, DWORD PTR __First2$[ebp]
	call	??Dconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBEABU?$pair@$$CBVCZString@Value@Json@@V23@@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator::operator*
	push	eax
	call	??$?M$$CBVCZString@Value@Json@@V12@@std@@YA_NABU?$pair@$$CBVCZString@Value@Json@@V23@@0@0@Z ; std::operator<<Json::Value::CZString const ,Json::Value>
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN2@Lexicograp

; 2855 : 			return (false);

	xor	al, al
	jmp	SHORT $LN7@Lexicograp
$LN2@Lexicograp:

; 2856 : 	return (_First1 == _Last1 && _First2 != _Last2);

	jmp	$LN5@Lexicograp
$LN4@Lexicograp:
	lea	eax, DWORD PTR __Last1$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First1$[ebp]
	call	??8const_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator::operator==
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN9@Lexicograp
	lea	edx, DWORD PTR __Last2$[ebp]
	push	edx
	lea	ecx, DWORD PTR __First2$[ebp]
	call	??9const_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator::operator!=
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN9@Lexicograp
	mov	DWORD PTR tv136[ebp], 1
	jmp	SHORT $LN10@Lexicograp
$LN9@Lexicograp:
	mov	DWORD PTR tv136[ebp], 0
$LN10@Lexicograp:
	mov	al, BYTE PTR tv136[ebp]
$LN7@Lexicograp:

; 2857 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Lexicographical_compare@Vconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@V123@@std@@YA_NVconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@000@Z ENDP ; std::_Lexicographical_compare<std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator,std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Iter_random@Vconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@V123@@std@@YA?AUforward_iterator_tag@0@ABVconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@Vconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@V123@@std@@YA?AUforward_iterator_tag@0@ABVconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@0@Z PROC ; std::_Iter_random<std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator,std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator>, COMDAT

; 801  : 	{	// return category from iterator argument

	push	ebp
	mov	ebp, esp
	push	ecx

; 802  : 	typename _Iter_random_helper<
; 803  : 		iterator_traits<_Iter1>::iterator_category, 
; 804  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 805  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 806  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Iter_random@Vconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@V123@@std@@YA?AUforward_iterator_tag@0@ABVconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@0@Z ENDP ; std::_Iter_random<std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator,std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Checked_cat@Vconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@std@@YA?AU_Range_checked_iterator_tag@0@ABVconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
??$_Checked_cat@Vconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@std@@YA?AU_Range_checked_iterator_tag@0@ABVconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@@Z PROC ; std::_Checked_cat<std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator>, COMDAT

; 879  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 880  : 		typename _Checked_iterator_category<_Iter>::_Checked_cat _Cat;
; 881  : 		return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 882  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Checked_cat@Vconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@std@@YA?AU_Range_checked_iterator_tag@0@ABVconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@@Z ENDP ; std::_Checked_cat<std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator>
_TEXT	ENDS
PUBLIC	??$_Mismatch@Vconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@V123@Uforward_iterator_tag@3@@std@@YA?AU?$pair@Vconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@V123@@0@Vconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@00Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Mismatch<std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator,std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator,std::forward_iterator_tag>
; Function compile flags: /Odtp
;	COMDAT ??$_Equal@Vconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@V123@Uforward_iterator_tag@3@@std@@YA_NVconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@00Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T32660 = -20						; size = 16
$T32659 = -2						; size = 1
$T32658 = -1						; size = 1
__First1$ = 8						; size = 8
__Last1$ = 16						; size = 8
__First2$ = 24						; size = 8
___formal$ = 32						; size = 1
___formal$ = 36						; size = 1
??$_Equal@Vconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@V123@Uforward_iterator_tag@3@@std@@YA_NVconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@00Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Equal<std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator,std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator,std::forward_iterator_tag>, COMDAT

; 2600 : 	{	// compare [_First1, _Last1) to [First2, ...)

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 2601 : 	return (_Mismatch(_First1, _Last1, _First2,
; 2602 : 		forward_iterator_tag(), _Range_checked_iterator_tag()).first == _Last1);

	xor	eax, eax
	mov	BYTE PTR $T32658[ebp], al
	lea	ecx, DWORD PTR __Last1$[ebp]
	push	ecx
	mov	dl, BYTE PTR $T32658[ebp]
	push	edx
	mov	al, BYTE PTR $T32659[ebp]
	push	eax
	mov	ecx, DWORD PTR __First2$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR __First2$[ebp]
	push	edx
	mov	eax, DWORD PTR __Last1$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Last1$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First1$[ebp+4]
	push	edx
	mov	eax, DWORD PTR __First1$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T32660[ebp]
	push	ecx
	call	??$_Mismatch@Vconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@V123@Uforward_iterator_tag@3@@std@@YA?AU?$pair@Vconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@V123@@0@Vconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@00Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Mismatch<std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator,std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator,std::forward_iterator_tag>
	add	esp, 36					; 00000024H
	mov	ecx, eax
	call	??8const_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator::operator==

; 2603 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Equal@Vconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@V123@Uforward_iterator_tag@3@@std@@YA_NVconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@00Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Equal<std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator,std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator,std::forward_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Checked_base@V?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@0@U_Different_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::_Different_checked_iterator_base_type_tag>
; Function compile flags: /Odtp
;	COMDAT ??$_Checked_base@V?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@YAPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@0@@Z
_TEXT	SEGMENT
__Base_tag$ = -1					; size = 1
__It$ = 8						; size = 4
??$_Checked_base@V?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@YAPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@0@@Z PROC ; std::_Checked_base<std::_Vector_const_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >, COMDAT

; 971  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 972  : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 973  : 		return _Checked_base(_It, _Base_tag);

	mov	al, BYTE PTR __Base_tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR __It$[ebp]
	push	ecx
	call	??$_Checked_base@V?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@0@U_Different_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::_Different_checked_iterator_base_type_tag>
	add	esp, 8

; 974  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Checked_base@V?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@YAPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@0@@Z ENDP ; std::_Checked_base<std::_Vector_const_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@V?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@0@AAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@V?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@0@AAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z PROC ; std::_Ptr_cat<std::_Vector_const_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>, COMDAT

; 1291 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1292 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1293 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1294 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Ptr_cat@V?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@0@AAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ENDP ; std::_Ptr_cat<std::_Vector_const_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 8\vc\include\memory
xdata$x	SEGMENT
__catchsym$??$_Uninit_copy@PBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBV10@0PAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_copy@PBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBV10@0PAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_copy@PBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBV10@0PAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_copy@PBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBV10@0PAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_copy@PBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBV10@0PAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_copy@PBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBV10@0PAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_copy@PBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBV10@0PAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_copy@PBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBV10@0PAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??$_Uninit_copy@PBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBV10@0PAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBV10@0PAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT

; 102  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_copy@PBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBV10@0PAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 103  : 	_DEBUG_RANGE(_First, _Last);
; 104  : 	_DEBUG_POINTER(_Dest);
; 105  : 	_FwdIt _Next = _Dest;

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 106  : 
; 107  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0
	jmp	SHORT $LN6@Uninit_cop
$LN5@Uninit_cop:

; 108  : 	for (; _First != _Last; ++_Dest, ++_First)

	mov	ecx, DWORD PTR __Dest$[ebp]
	add	ecx, 28					; 0000001cH
	mov	DWORD PTR __Dest$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 28					; 0000001cH
	mov	DWORD PTR __First$[ebp], edx
$LN6@Uninit_cop:
	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Uninit_cop

; 109  : 		_Al.construct(_Dest, *_First);

	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?construct@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@ABV32@@Z ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::construct
	jmp	SHORT $LN5@Uninit_cop
$LN4@Uninit_cop:

; 110  : 	_CATCH_ALL

	jmp	SHORT $LN10@Uninit_cop
__catch$??$_Uninit_copy@PBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBV10@0PAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:
	jmp	SHORT $LN3@Uninit_cop
$LN2@Uninit_cop:

; 111  : 	for (; _Next != _Dest; ++_Next)

	mov	eax, DWORD PTR __Next$[ebp]
	add	eax, 28					; 0000001cH
	mov	DWORD PTR __Next$[ebp], eax
$LN3@Uninit_cop:
	mov	ecx, DWORD PTR __Next$[ebp]
	cmp	ecx, DWORD PTR __Dest$[ebp]
	je	SHORT $LN1@Uninit_cop

; 112  : 		_Al.destroy(_Next);

	mov	edx, DWORD PTR __Next$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?destroy@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::destroy
	jmp	SHORT $LN2@Uninit_cop
$LN1@Uninit_cop:

; 113  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
	mov	eax, __tryend$??$_Uninit_copy@PBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBV10@0PAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1
	ret	0
$LN10@Uninit_cop:

; 114  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Uninit_copy@PBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBV10@0PAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1:

; 115  : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]
$LN9@Uninit_cop:

; 116  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_copy@PBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBV10@0PAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_copy@PBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBV10@0PAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_copy@PBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBV10@0PAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	??$_Checked_base@V?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@0@U_Different_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<std::_Vector_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::_Different_checked_iterator_base_type_tag>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 8\vc\include\xutility
;	COMDAT ??$_Checked_base@V?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@0@@Z
_TEXT	SEGMENT
__Base_tag$ = -1					; size = 1
__It$ = 8						; size = 4
??$_Checked_base@V?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@0@@Z PROC ; std::_Checked_base<std::_Vector_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >, COMDAT

; 971  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 972  : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 973  : 		return _Checked_base(_It, _Base_tag);

	mov	al, BYTE PTR __Base_tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR __It$[ebp]
	push	ecx
	call	??$_Checked_base@V?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@0@U_Different_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<std::_Vector_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::_Different_checked_iterator_base_type_tag>
	add	esp, 8

; 974  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Checked_base@V?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@0@@Z ENDP ; std::_Checked_base<std::_Vector_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
_TEXT	ENDS
PUBLIC	??$swap@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAXAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ; std::swap<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	__$ArrayPad$
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 8\vc\include\memory
xdata$x	SEGMENT
__catchsym$??$_Uninit_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z$3 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__tryblocktable$??$_Uninit_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z$3
__unwindtable$??$_Uninit_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Uninit_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z$2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
__ehfuncinfo$??$_Uninit_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$_Uninit_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??$_Uninit_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T32684 = -56						; size = 4
__Val$ = -52						; size = 28
__$ArrayPad$ = -24					; size = 4
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT

; 167  : 	{	// use swap to instead of the copy constructor

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 40					; 00000028H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 168  : 	_DEBUG_RANGE(_First, _Last);
; 169  : 	_DEBUG_POINTER(_Dest);
; 170  : 	_FwdIt _Next = _Dest;

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 171  : 	// empty value used in the construction
; 172  : 	typename _Alloc::value_type _Val;

	lea	ecx, DWORD PTR __Val$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 173  : 
; 174  : 	_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 1
	jmp	SHORT $LN6@Uninit_mov
$LN5@Uninit_mov:

; 175  : 	for (; _First != _Last; ++_Dest, ++_First)

	mov	ecx, DWORD PTR __Dest$[ebp]
	add	ecx, 28					; 0000001cH
	mov	DWORD PTR __Dest$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 28					; 0000001cH
	mov	DWORD PTR __First$[ebp], edx
$LN6@Uninit_mov:
	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Uninit_mov

; 176  : 		{
; 177  : 		_Al.construct(_Dest, _Val);

	lea	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?construct@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@ABV32@@Z ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::construct

; 178  : 		_STD swap(*_Dest, *_First);

	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	??$swap@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAXAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ; std::swap<char,std::char_traits<char>,std::allocator<char> >
	add	esp, 8

; 179  : 		}

	jmp	SHORT $LN5@Uninit_mov
$LN4@Uninit_mov:

; 180  : 	_CATCH_ALL

	jmp	SHORT $LN10@Uninit_mov
__catch$??$_Uninit_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z$0:
	jmp	SHORT $LN3@Uninit_mov
$LN2@Uninit_mov:

; 181  : 	for (; _Next != _Dest; ++_Next)

	mov	edx, DWORD PTR __Next$[ebp]
	add	edx, 28					; 0000001cH
	mov	DWORD PTR __Next$[ebp], edx
$LN3@Uninit_mov:
	mov	eax, DWORD PTR __Next$[ebp]
	cmp	eax, DWORD PTR __Dest$[ebp]
	je	SHORT $LN1@Uninit_mov

; 182  : 		_Al.destroy(_Next);

	mov	ecx, DWORD PTR __Next$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?destroy@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::destroy
	jmp	SHORT $LN2@Uninit_mov
$LN1@Uninit_mov:

; 183  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
	mov	eax, __tryend$??$_Uninit_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z$1
	ret	0
$LN10@Uninit_mov:

; 184  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], 0
__tryend$??$_Uninit_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z$1:

; 185  : 	return (_Dest);

	mov	edx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR $T32684[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	lea	ecx, DWORD PTR __Val$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	eax, DWORD PTR $T32684[ebp]
$LN9@Uninit_mov:

; 186  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Uninit_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z$2:
	lea	ecx, DWORD PTR __Val$[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$??$_Uninit_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-60]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	??$_Fill_n@PAPBVPathArgument@Json@@IPBV12@@std@@YAXPAPBVPathArgument@Json@@IABQBV12@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<Json::PathArgument const * *,unsigned int,Json::PathArgument const *>
PUBLIC	??$_Iter_cat@PAPBVPathArgument@Json@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPBVPathArgument@Json@@@Z ; std::_Iter_cat<Json::PathArgument const * *>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 8\vc\include\xutility
;	COMDAT ??$unchecked_fill_n@PAPBVPathArgument@Json@@IPBV12@@stdext@@YAXPAPBVPathArgument@Json@@IABQBV12@@Z
_TEXT	SEGMENT
$T32701 = -2						; size = 1
$T32700 = -1						; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
??$unchecked_fill_n@PAPBVPathArgument@Json@@IPBV12@@stdext@@YAXPAPBVPathArgument@Json@@IABQBV12@@Z PROC ; stdext::unchecked_fill_n<Json::PathArgument const * *,unsigned int,Json::PathArgument const *>, COMDAT

; 3039 : 	{	// copy _Val _Count times through [_First, ...)

	push	ebp
	mov	ebp, esp
	push	ecx

; 3040 : 		_STD _Fill_n(_First, _Count, _Val, _STD _Iter_cat(_First), _STD _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T32700[ebp], al
	mov	cl, BYTE PTR $T32700[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	lea	eax, DWORD PTR $T32701[ebp]
	push	eax
	call	??$_Iter_cat@PAPBVPathArgument@Json@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPBVPathArgument@Json@@@Z ; std::_Iter_cat<Json::PathArgument const * *>
	add	esp, 8
	mov	cl, BYTE PTR [eax]
	push	ecx
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Fill_n@PAPBVPathArgument@Json@@IPBV12@@std@@YAXPAPBVPathArgument@Json@@IABQBV12@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<Json::PathArgument const * *,unsigned int,Json::PathArgument const *>
	add	esp, 20					; 00000014H

; 3041 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_fill_n@PAPBVPathArgument@Json@@IPBV12@@stdext@@YAXPAPBVPathArgument@Json@@IABQBV12@@Z ENDP ; stdext::unchecked_fill_n<Json::PathArgument const * *,unsigned int,Json::PathArgument const *>
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@PAPBVPathArgument@Json@@PAPBV12@V?$allocator@PBVPathArgument@Json@@@std@@@stdext@@YAPAPBVPathArgument@Json@@PAPBV12@00AAV?$allocator@PBVPathArgument@Json@@@std@@@Z ; stdext::unchecked_uninitialized_copy<Json::PathArgument const * *,Json::PathArgument const * *,std::allocator<Json::PathArgument const *> >
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 8\vc\include\memory
;	COMDAT ??$_Uninit_move@PAPBVPathArgument@Json@@PAPBV12@V?$allocator@PBVPathArgument@Json@@@std@@U_Undefined_move_tag@4@@std@@YAPAPBVPathArgument@Json@@PAPBV12@00AAV?$allocator@PBVPathArgument@Json@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_move@PAPBVPathArgument@Json@@PAPBV12@V?$allocator@PBVPathArgument@Json@@@std@@U_Undefined_move_tag@4@@std@@YAPAPBVPathArgument@Json@@PAPBV12@00AAV?$allocator@PBVPathArgument@Json@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_move<Json::PathArgument const * *,Json::PathArgument const * *,std::allocator<Json::PathArgument const *>,std::_Undefined_move_tag>, COMDAT

; 159  : 	{	// move defaults to copy if there is not a more effecient way

	push	ebp
	mov	ebp, esp

; 160  : 	return _STDEXT unchecked_uninitialized_copy(_First, _Last, _Dest, _Al);

	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$unchecked_uninitialized_copy@PAPBVPathArgument@Json@@PAPBV12@V?$allocator@PBVPathArgument@Json@@@std@@@stdext@@YAPAPBVPathArgument@Json@@PAPBV12@00AAV?$allocator@PBVPathArgument@Json@@@std@@@Z ; stdext::unchecked_uninitialized_copy<Json::PathArgument const * *,Json::PathArgument const * *,std::allocator<Json::PathArgument const *> >
	add	esp, 16					; 00000010H

; 161  : 	}

	pop	ebp
	ret	0
??$_Uninit_move@PAPBVPathArgument@Json@@PAPBV12@V?$allocator@PBVPathArgument@Json@@@std@@U_Undefined_move_tag@4@@std@@YAPAPBVPathArgument@Json@@PAPBV12@00AAV?$allocator@PBVPathArgument@Json@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_move<Json::PathArgument const * *,Json::PathArgument const * *,std::allocator<Json::PathArgument const *>,std::_Undefined_move_tag>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 8\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Checked_base@PAPBVPathArgument@Json@@@std@@YAPAPBVPathArgument@Json@@AAPAPBV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Checked_base@PAPBVPathArgument@Json@@@std@@YAPAPBVPathArgument@Json@@AAPAPBV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<Json::PathArgument const * *>, COMDAT

; 954  : 	{

	push	ebp
	mov	ebp, esp

; 955  : 		return _It;

	mov	eax, DWORD PTR __It$[ebp]
	mov	eax, DWORD PTR [eax]

; 956  : 	}

	pop	ebp
	ret	0
??$_Checked_base@PAPBVPathArgument@Json@@@std@@YAPAPBVPathArgument@Json@@AAPAPBV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<Json::PathArgument const * *>
_TEXT	ENDS
EXTRN	__imp__memmove_s:PROC
; Function compile flags: /Odtp
;	COMDAT ??$_Copy_backward_opt@PAPBVPathArgument@Json@@PAPBV12@Urandom_access_iterator_tag@std@@@std@@YAPAPBVPathArgument@Json@@PAPBV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Off$ = -8						; size = 4
__Result$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_backward_opt@PAPBVPathArgument@Json@@PAPBV12@Urandom_access_iterator_tag@std@@@std@@YAPAPBVPathArgument@Json@@PAPBV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<Json::PathArgument const * *,Json::PathArgument const * *,std::random_access_iterator_tag>, COMDAT

; 2369 : 	{	// copy [_First, _Last) backwards to [..., _Dest), pointers to scalars

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2370 : 
; 2371 :  #if _HAS_ITERATOR_DEBUGGING
; 2372 : 	_DEBUG_RANGE(_First, _Last);
; 2373 : 	if (_First != _Last)
; 2374 : 		_DEBUG_POINTER(_Dest);
; 2375 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2376 : 
; 2377 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 2
	mov	DWORD PTR __Off$[ebp], eax

; 2378 : 	/* if _OutIt is range checked, this will make sure there is enough space for 
; 2379 : 	 * the memmove
; 2380 : 	 */
; 2381 : 	_OutIt _Result = _Dest - _Off;

	mov	ecx, DWORD PTR __Off$[ebp]
	shl	ecx, 2
	mov	edx, DWORD PTR __Dest$[ebp]
	sub	edx, ecx
	mov	DWORD PTR __Result$[ebp], edx

; 2382 : 	if (_Off > 0)

	cmp	DWORD PTR __Off$[ebp], 0
	jle	SHORT $LN1@Copy_backw

; 2383 : 		_CRT_SECURE_MEMMOVE(&*_Result, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	mov	eax, DWORD PTR __Off$[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Off$[ebp]
	shl	edx, 2
	push	edx
	mov	eax, DWORD PTR __Result$[ebp]
	push	eax
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN1@Copy_backw:

; 2384 : 	return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 2385 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Copy_backward_opt@PAPBVPathArgument@Json@@PAPBV12@Urandom_access_iterator_tag@std@@@std@@YAPAPBVPathArgument@Json@@PAPBV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<Json::PathArgument const * *,Json::PathArgument const * *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@PAVPathArgument@Json@@PAV12@V?$allocator@VPathArgument@Json@@@std@@@stdext@@YAPAVPathArgument@Json@@PAV12@00AAV?$allocator@VPathArgument@Json@@@std@@@Z ; stdext::unchecked_uninitialized_copy<Json::PathArgument *,Json::PathArgument *,std::allocator<Json::PathArgument> >
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 8\vc\include\memory
;	COMDAT ??$_Uninit_move@PAVPathArgument@Json@@PAV12@V?$allocator@VPathArgument@Json@@@std@@U_Undefined_move_tag@4@@std@@YAPAVPathArgument@Json@@PAV12@00AAV?$allocator@VPathArgument@Json@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_move@PAVPathArgument@Json@@PAV12@V?$allocator@VPathArgument@Json@@@std@@U_Undefined_move_tag@4@@std@@YAPAVPathArgument@Json@@PAV12@00AAV?$allocator@VPathArgument@Json@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_move<Json::PathArgument *,Json::PathArgument *,std::allocator<Json::PathArgument>,std::_Undefined_move_tag>, COMDAT

; 159  : 	{	// move defaults to copy if there is not a more effecient way

	push	ebp
	mov	ebp, esp

; 160  : 	return _STDEXT unchecked_uninitialized_copy(_First, _Last, _Dest, _Al);

	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$unchecked_uninitialized_copy@PAVPathArgument@Json@@PAV12@V?$allocator@VPathArgument@Json@@@std@@@stdext@@YAPAVPathArgument@Json@@PAV12@00AAV?$allocator@VPathArgument@Json@@@std@@@Z ; stdext::unchecked_uninitialized_copy<Json::PathArgument *,Json::PathArgument *,std::allocator<Json::PathArgument> >
	add	esp, 16					; 00000010H

; 161  : 	}

	pop	ebp
	ret	0
??$_Uninit_move@PAVPathArgument@Json@@PAV12@V?$allocator@VPathArgument@Json@@@std@@U_Undefined_move_tag@4@@std@@YAPAVPathArgument@Json@@PAV12@00AAV?$allocator@VPathArgument@Json@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_move<Json::PathArgument *,Json::PathArgument *,std::allocator<Json::PathArgument>,std::_Undefined_move_tag>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 8\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Checked_base@PAVPathArgument@Json@@@std@@YAPAVPathArgument@Json@@AAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Checked_base@PAVPathArgument@Json@@@std@@YAPAVPathArgument@Json@@AAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<Json::PathArgument *>, COMDAT

; 954  : 	{

	push	ebp
	mov	ebp, esp

; 955  : 		return _It;

	mov	eax, DWORD PTR __It$[ebp]
	mov	eax, DWORD PTR [eax]

; 956  : 	}

	pop	ebp
	ret	0
??$_Checked_base@PAVPathArgument@Json@@@std@@YAPAVPathArgument@Json@@AAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<Json::PathArgument *>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAVPathArgument@Json@@PAV12@Uforward_iterator_tag@std@@@std@@YAPAVPathArgument@Json@@PAV12@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<Json::PathArgument *,Json::PathArgument *,std::forward_iterator_tag>
; Function compile flags: /Odtp
;	COMDAT ??$_Copy_backward_opt@PAVPathArgument@Json@@PAV12@@std@@YAPAVPathArgument@Json@@PAV12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T32716 = -7						; size = 1
$T32715 = -6						; size = 1
$T32714 = -5						; size = 1
__Result$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_backward_opt@PAVPathArgument@Json@@PAV12@@std@@YAPAVPathArgument@Json@@PAV12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<Json::PathArgument *,Json::PathArgument *>, COMDAT

; 2356 : 	{	// copy [_First, _Last) backwards to [..., _Dest), arbitrary iterators

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2357 : 	// if _OutIt is range checked, this will make sure there is enough space for the copy
; 2358 : 	_OutIt _Result = _Dest - (_Last - _First);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	cdq
	mov	ecx, 36					; 00000024H
	idiv	ecx
	imul	eax, 36					; 00000024H
	mov	edx, DWORD PTR __Dest$[ebp]
	sub	edx, eax
	mov	DWORD PTR __Result$[ebp], edx

; 2359 : 	_Copy_backward_opt(_First, _Last, _CHECKED_BASE(_Dest),
; 2360 : 		forward_iterator_tag(), _Nonscalar_ptr_iterator_tag(), _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T32714[ebp], al
	xor	ecx, ecx
	mov	BYTE PTR $T32715[ebp], cl
	mov	dl, BYTE PTR $T32714[ebp]
	push	edx
	mov	al, BYTE PTR $T32715[ebp]
	push	eax
	mov	cl, BYTE PTR $T32716[ebp]
	push	ecx
	lea	edx, DWORD PTR __Dest$[ebp]
	push	edx
	call	??$_Checked_base@PAVPathArgument@Json@@@std@@YAPAVPathArgument@Json@@AAPAV12@@Z ; std::_Checked_base<Json::PathArgument *>
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Copy_backward_opt@PAVPathArgument@Json@@PAV12@Uforward_iterator_tag@std@@@std@@YAPAVPathArgument@Json@@PAV12@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<Json::PathArgument *,Json::PathArgument *,std::forward_iterator_tag>
	add	esp, 24					; 00000018H

; 2361 : 	return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 2362 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Copy_backward_opt@PAVPathArgument@Json@@PAV12@@std@@YAPAVPathArgument@Json@@PAV12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<Json::PathArgument *,Json::PathArgument *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Checked_base@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAPAV10@U_Unchanged_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Checked_base@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAPAV10@U_Unchanged_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>, COMDAT

; 954  : 	{

	push	ebp
	mov	ebp, esp

; 955  : 		return _It;

	mov	eax, DWORD PTR __It$[ebp]
	mov	eax, DWORD PTR [eax]

; 956  : 	}

	pop	ebp
	ret	0
??$_Checked_base@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAPAV10@U_Unchanged_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Move_backward_opt@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@Uforward_iterator_tag@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00Uforward_iterator_tag@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Move_backward_opt@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@Uforward_iterator_tag@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00Uforward_iterator_tag@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Move_backward_opt<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::forward_iterator_tag>, COMDAT

; 2421 : 	{	// use swap instead of the copy constructor

	push	ebp
	mov	ebp, esp
$LN2@Move_backw:

; 2422 : 	_DEBUG_RANGE(_First, _Last);
; 2423 : 	while (_First != _Last)

	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN1@Move_backw

; 2424 : 		_STD swap(*--_Dest, *--_Last);

	mov	ecx, DWORD PTR __Last$[ebp]
	sub	ecx, 28					; 0000001cH
	mov	DWORD PTR __Last$[ebp], ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	sub	edx, 28					; 0000001cH
	mov	DWORD PTR __Dest$[ebp], edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	??$swap@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAXAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ; std::swap<char,std::char_traits<char>,std::allocator<char> >
	add	esp, 8
	jmp	SHORT $LN2@Move_backw
$LN1@Move_backw:

; 2425 : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]

; 2426 : 	}

	pop	ebp
	ret	0
??$_Move_backward_opt@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@Uforward_iterator_tag@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00Uforward_iterator_tag@0@U_Swap_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Move_backward_opt<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::forward_iterator_tag>
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 8\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$??$_Construct@VPathArgument@Json@@V12@@std@@YAXPAVPathArgument@Json@@ABV12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Construct@VPathArgument@Json@@V12@@std@@YAXPAVPathArgument@Json@@ABV12@@Z$0
__ehfuncinfo$??$_Construct@VPathArgument@Json@@V12@@std@@YAXPAVPathArgument@Json@@ABV12@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Construct@VPathArgument@Json@@V12@@std@@YAXPAVPathArgument@Json@@ABV12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??$_Construct@VPathArgument@Json@@V12@@std@@YAXPAVPathArgument@Json@@ABV12@@Z
_TEXT	SEGMENT
tv74 = -28						; size = 4
$T32724 = -24						; size = 4
$T32723 = -20						; size = 4
__Vptr$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@VPathArgument@Json@@V12@@std@@YAXPAVPathArgument@Json@@ABV12@@Z PROC ; std::_Construct<Json::PathArgument,Json::PathArgument>, COMDAT

; 51   : 	{	// construct object at _Ptr with value _Val

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Construct@VPathArgument@Json@@V12@@std@@YAXPAVPathArgument@Json@@ABV12@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 52   : 	void _FARQ *_Vptr = _Ptr;

	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR __Vptr$[ebp], eax

; 53   : 	::new (_Vptr) _T1(_Val);

	mov	ecx, DWORD PTR __Vptr$[ebp]
	push	ecx
	push	36					; 00000024H
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T32724[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T32724[ebp], 0
	je	SHORT $LN3@Construct@2
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T32724[ebp]
	call	??0PathArgument@Json@@QAE@ABV01@@Z
	mov	DWORD PTR tv74[ebp], eax
	jmp	SHORT $LN4@Construct@2
$LN3@Construct@2:
	mov	DWORD PTR tv74[ebp], 0
$LN4@Construct@2:
	mov	eax, DWORD PTR tv74[ebp]
	mov	DWORD PTR $T32723[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1

; 54   : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Construct@VPathArgument@Json@@V12@@std@@YAXPAVPathArgument@Json@@ABV12@@Z$0:
	mov	eax, DWORD PTR __Vptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T32724[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$_Construct@VPathArgument@Json@@V12@@std@@YAXPAVPathArgument@Json@@ABV12@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Construct@VPathArgument@Json@@V12@@std@@YAXPAVPathArgument@Json@@ABV12@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Construct@VPathArgument@Json@@V12@@std@@YAXPAVPathArgument@Json@@ABV12@@Z ENDP ; std::_Construct<Json::PathArgument,Json::PathArgument>
PUBLIC	??_GPathArgument@Json@@QAEPAXI@Z		; Json::PathArgument::`scalar deleting destructor'
; Function compile flags: /Odtp
;	COMDAT ??$_Destroy@VPathArgument@Json@@@std@@YAXPAVPathArgument@Json@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@VPathArgument@Json@@@std@@YAXPAVPathArgument@Json@@@Z PROC ; std::_Destroy<Json::PathArgument>, COMDAT

; 59   : 	{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp

; 60   : 	_DESTRUCTOR(_Ty, _Ptr);

	push	0
	mov	ecx, DWORD PTR __Ptr$[ebp]
	call	??_GPathArgument@Json@@QAEPAXI@Z

; 61   : 	}

	pop	ebp
	ret	0
??$_Destroy@VPathArgument@Json@@@std@@YAXPAVPathArgument@Json@@@Z ENDP ; std::_Destroy<Json::PathArgument>
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@@Z$0
__ehfuncinfo$??$_Construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??$_Construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@@Z
_TEXT	SEGMENT
tv74 = -28						; size = 4
$T32739 = -24						; size = 4
$T32738 = -20						; size = 4
__Vptr$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@@Z PROC ; std::_Construct<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT

; 51   : 	{	// construct object at _Ptr with value _Val

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 52   : 	void _FARQ *_Vptr = _Ptr;

	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR __Vptr$[ebp], eax

; 53   : 	::new (_Vptr) _T1(_Val);

	mov	ecx, DWORD PTR __Vptr$[ebp]
	push	ecx
	push	28					; 0000001cH
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T32739[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T32739[ebp], 0
	je	SHORT $LN3@Construct@3
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T32739[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	DWORD PTR tv74[ebp], eax
	jmp	SHORT $LN4@Construct@3
$LN3@Construct@3:
	mov	DWORD PTR tv74[ebp], 0
$LN4@Construct@3:
	mov	eax, DWORD PTR tv74[ebp]
	mov	DWORD PTR $T32738[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1

; 54   : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@@Z$0:
	mov	eax, DWORD PTR __Vptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T32739[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$_Construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@@Z ENDP ; std::_Construct<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??_G?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPAXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::`scalar deleting destructor'
; Function compile flags: /Odtp
;	COMDAT ??$_Destroy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z PROC ; std::_Destroy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT

; 59   : 	{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp

; 60   : 	_DESTRUCTOR(_Ty, _Ptr);

	push	0
	mov	ecx, DWORD PTR __Ptr$[ebp]
	call	??_G?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPAXI@Z

; 61   : 	}

	pop	ebp
	ret	0
??$_Destroy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ENDP ; std::_Destroy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_GPathArgument@Json@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GPathArgument@Json@@QAEPAXI@Z PROC			; Json::PathArgument::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1PathArgument@Json@@QAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@11
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@11:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GPathArgument@Json@@QAEPAXI@Z ENDP			; Json::PathArgument::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_G?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPAXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@12
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@12:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_G?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPAXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::`scalar deleting destructor'
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 8\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Checked_base@Vconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@std@@YA?AVconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@AAV120@U_Unchanged_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__It$ = 12						; size = 4
___formal$ = 16						; size = 1
??$_Checked_base@Vconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@std@@YA?AVconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@AAV120@U_Unchanged_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator>, COMDAT

; 954  : 	{

	push	ebp
	mov	ebp, esp

; 955  : 		return _It;

	mov	eax, DWORD PTR __It$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 956  : 	}

	pop	ebp
	ret	0
??$_Checked_base@Vconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@std@@YA?AVconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@AAV120@U_Unchanged_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 8\vc\include\utility
_TEXT	ENDS
;	COMDAT ??$?M$$CBVCZString@Value@Json@@V12@@std@@YA_NABU?$pair@$$CBVCZString@Value@Json@@V23@@0@0@Z
_TEXT	SEGMENT
tv81 = -4						; size = 4
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$?M$$CBVCZString@Value@Json@@V12@@std@@YA_NABU?$pair@$$CBVCZString@Value@Json@@V23@@0@0@Z PROC ; std::operator<<Json::Value::CZString const ,Json::Value>, COMDAT

; 78   : 	{	// test if _Left < _Right for pairs

	push	ebp
	mov	ebp, esp
	push	ecx

; 79   : 	return (_Left.first < _Right.first ||
; 80   : 		!(_Right.first < _Left.first) && _Left.second < _Right.second);

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Left$[ebp]
	call	??MCZString@Value@Json@@QBE_NABV012@@Z	; Json::Value::CZString::operator<
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN4@operator@22
	mov	edx, DWORD PTR __Left$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	??MCZString@Value@Json@@QBE_NABV012@@Z	; Json::Value::CZString::operator<
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@operator@22
	mov	ecx, DWORD PTR __Right$[ebp]
	add	ecx, 8
	push	ecx
	mov	ecx, DWORD PTR __Left$[ebp]
	add	ecx, 8
	call	??MValue@Json@@QBE_NABV01@@Z		; Json::Value::operator<
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN4@operator@22
$LN3@operator@22:
	mov	DWORD PTR tv81[ebp], 0
	jmp	SHORT $LN5@operator@22
$LN4@operator@22:
	mov	DWORD PTR tv81[ebp], 1
$LN5@operator@22:
	mov	al, BYTE PTR tv81[ebp]

; 81   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$?M$$CBVCZString@Value@Json@@V12@@std@@YA_NABU?$pair@$$CBVCZString@Value@Json@@V23@@0@0@Z ENDP ; std::operator<<Json::Value::CZString const ,Json::Value>
_TEXT	ENDS
PUBLIC	??0?$pair@Vconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@V123@@std@@QAE@ABVconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@1@0@Z ; std::pair<std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator,std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator>::pair<std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator,std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator>
PUBLIC	??$?8$$CBVCZString@Value@Json@@V12@@std@@YA_NABU?$pair@$$CBVCZString@Value@Json@@V23@@0@0@Z ; std::operator==<Json::Value::CZString const ,Json::Value>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 8\vc\include\xutility
;	COMDAT ??$_Mismatch@Vconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@V123@Uforward_iterator_tag@3@@std@@YA?AU?$pair@Vconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@V123@@0@Vconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@00Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First1$ = 12						; size = 8
__Last1$ = 20						; size = 8
__First2$ = 28						; size = 8
___formal$ = 36						; size = 1
___formal$ = 40						; size = 1
??$_Mismatch@Vconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@V123@Uforward_iterator_tag@3@@std@@YA?AU?$pair@Vconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@V123@@0@Vconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@00Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Mismatch<std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator,std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator,std::forward_iterator_tag>, COMDAT

; 2468 : 	{	// return [_First1, _Last1) and [_First2, _Last2) mismatch

	push	ebp
	mov	ebp, esp
$LN2@Mismatch:

; 2469 : 
; 2470 :  #if _HAS_ITERATOR_DEBUGGING
; 2471 : 	_DEBUG_RANGE(_First1, _Last1);
; 2472 : 	if (_First1 != _Last1)
; 2473 : 		_DEBUG_POINTER(_First2);
; 2474 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2475 : 
; 2476 : 	for (; _First1 != _Last1 && *_First1 == *_First2; )

	lea	eax, DWORD PTR __Last1$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First1$[ebp]
	call	??9const_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator::operator!=
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@Mismatch
	lea	ecx, DWORD PTR __First2$[ebp]
	call	??Dconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBEABU?$pair@$$CBVCZString@Value@Json@@V23@@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator::operator*
	push	eax
	lea	ecx, DWORD PTR __First1$[ebp]
	call	??Dconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBEABU?$pair@$$CBVCZString@Value@Json@@V23@@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator::operator*
	push	eax
	call	??$?8$$CBVCZString@Value@Json@@V12@@std@@YA_NABU?$pair@$$CBVCZString@Value@Json@@V23@@0@0@Z ; std::operator==<Json::Value::CZString const ,Json::Value>
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN1@Mismatch

; 2477 : 		++_First1, ++_First2;

	lea	ecx, DWORD PTR __First1$[ebp]
	call	??Econst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator::operator++
	lea	ecx, DWORD PTR __First2$[ebp]
	call	??Econst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator::operator++
	jmp	SHORT $LN2@Mismatch
$LN1@Mismatch:

; 2478 : 	return (pair<_InIt1, _InIt2>(_First1, _First2));

	lea	eax, DWORD PTR __First2$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First1$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$pair@Vconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@V123@@std@@QAE@ABVconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@1@0@Z ; std::pair<std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator,std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator>::pair<std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator,std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator>
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2479 : 	}

	pop	ebp
	ret	0
??$_Mismatch@Vconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@V123@Uforward_iterator_tag@3@@std@@YA?AU?$pair@Vconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@V123@@0@Vconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@00Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Mismatch<std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator,std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator,std::forward_iterator_tag>
_TEXT	ENDS
PUBLIC	?_Checked_iterator_base@?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::_Vector_const_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Checked_iterator_base
; Function compile flags: /Odtp
;	COMDAT ??$_Checked_base@V?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@0@U_Different_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Checked_base@V?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@0@U_Different_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<std::_Vector_const_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::_Different_checked_iterator_base_type_tag>, COMDAT

; 946  : 	{

	push	ebp
	mov	ebp, esp

; 947  : 		return _It._Checked_iterator_base();

	mov	ecx, DWORD PTR __It$[ebp]
	call	?_Checked_iterator_base@?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::_Vector_const_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Checked_iterator_base

; 948  : 	}

	pop	ebp
	ret	0
??$_Checked_base@V?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@0@U_Different_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<std::_Vector_const_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::_Different_checked_iterator_base_type_tag>
_TEXT	ENDS
PUBLIC	?_Checked_iterator_base@?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::_Vector_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Checked_iterator_base
; Function compile flags: /Odtp
;	COMDAT ??$_Checked_base@V?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@0@U_Different_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Checked_base@V?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@0@U_Different_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<std::_Vector_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::_Different_checked_iterator_base_type_tag>, COMDAT

; 946  : 	{

	push	ebp
	mov	ebp, esp

; 947  : 		return _It._Checked_iterator_base();

	mov	ecx, DWORD PTR __It$[ebp]
	call	?_Checked_iterator_base@?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::_Vector_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Checked_iterator_base

; 948  : 	}

	pop	ebp
	ret	0
??$_Checked_base@V?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@0@U_Different_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<std::_Vector_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::_Different_checked_iterator_base_type_tag>
_TEXT	ENDS
EXTRN	__imp_?swap@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXAAV12@@Z:PROC
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 8\vc\include\xstring
;	COMDAT ??$swap@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAXAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAXAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z PROC ; std::swap<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 2085 : 	{	// swap _Left and _Right strings

	push	ebp
	mov	ebp, esp

; 2086 : 	_Left.swap(_Right);

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Left$[ebp]
	call	DWORD PTR __imp_?swap@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXAAV12@@Z

; 2087 : 	}

	pop	ebp
	ret	0
??$swap@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAXAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ENDP ; std::swap<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 8\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Iter_cat@PAPBVPathArgument@Json@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPBVPathArgument@Json@@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??$_Iter_cat@PAPBVPathArgument@Json@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPBVPathArgument@Json@@@Z PROC ; std::_Iter_cat<Json::PathArgument const * *>, COMDAT

; 760  : 	{	// return category from iterator argument

	push	ebp
	mov	ebp, esp
	push	ecx

; 761  : 	typename iterator_traits<_Iter>::iterator_category _Cat;
; 762  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 763  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Iter_cat@PAPBVPathArgument@Json@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPBVPathArgument@Json@@@Z ENDP ; std::_Iter_cat<Json::PathArgument const * *>
_TEXT	ENDS
PUBLIC	??$_Fill_n@PAPBVPathArgument@Json@@IPBV12@@std@@YAXPAPBVPathArgument@Json@@IABQBV12@U_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<Json::PathArgument const * *,unsigned int,Json::PathArgument const *>
; Function compile flags: /Odtp
;	COMDAT ??$_Fill_n@PAPBVPathArgument@Json@@IPBV12@@std@@YAXPAPBVPathArgument@Json@@IABQBV12@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T32774 = -5						; size = 1
__Last$ = -4						; size = 4
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
??$_Fill_n@PAPBVPathArgument@Json@@IPBV12@@std@@YAXPAPBVPathArgument@Json@@IABQBV12@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Fill_n<Json::PathArgument const * *,unsigned int,Json::PathArgument const *>, COMDAT

; 2817 : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2818 : 		// if _OutIt is checked, this will ensure we have enough space
; 2819 : 		_OutIt _Last = _First + _Count; (_Last);

	mov	eax, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR __First$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR __Last$[ebp], edx

; 2820 : 		_Fill_n(_CHECKED_BASE(_First), _Count, _Val,
; 2821 : 			_Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T32774[ebp], al
	mov	cl, BYTE PTR $T32774[ebp]
	push	ecx
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Checked_base@PAPBVPathArgument@Json@@@std@@YAPAPBVPathArgument@Json@@AAPAPBV12@@Z ; std::_Checked_base<Json::PathArgument const * *>
	add	esp, 4
	push	eax
	call	??$_Fill_n@PAPBVPathArgument@Json@@IPBV12@@std@@YAXPAPBVPathArgument@Json@@IABQBV12@U_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<Json::PathArgument const * *,unsigned int,Json::PathArgument const *>
	add	esp, 16					; 00000010H

; 2822 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Fill_n@PAPBVPathArgument@Json@@IPBV12@@std@@YAXPAPBVPathArgument@Json@@IABQBV12@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Fill_n<Json::PathArgument const * *,unsigned int,Json::PathArgument const *>
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAPBVPathArgument@Json@@PAPBV12@V?$allocator@PBVPathArgument@Json@@@std@@@std@@YAPAPBVPathArgument@Json@@PAPBV12@00AAV?$allocator@PBVPathArgument@Json@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Json::PathArgument const * *,Json::PathArgument const * *,std::allocator<Json::PathArgument const *> >
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 8\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_copy@PAPBVPathArgument@Json@@PAPBV12@V?$allocator@PBVPathArgument@Json@@@std@@@stdext@@YAPAPBVPathArgument@Json@@PAPBV12@00AAV?$allocator@PBVPathArgument@Json@@@std@@@Z
_TEXT	SEGMENT
$T32778 = -2						; size = 1
$T32777 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAPBVPathArgument@Json@@PAPBV12@V?$allocator@PBVPathArgument@Json@@@std@@@stdext@@YAPAPBVPathArgument@Json@@PAPBV12@00AAV?$allocator@PBVPathArgument@Json@@@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<Json::PathArgument const * *,Json::PathArgument const * *,std::allocator<Json::PathArgument const *> >, COMDAT

; 672  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 673  : 		return (_STD _Uninit_copy(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest, _Al,
; 674  : 			_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T32777[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAPBVPathArgument@Json@@PAPBV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPBVPathArgument@Json@@0@Z ; std::_Ptr_cat<Json::PathArgument const * *,Json::PathArgument const * *>
	add	esp, 8
	mov	BYTE PTR $T32778[ebp], al
	mov	al, BYTE PTR $T32777[ebp]
	push	eax
	mov	cl, BYTE PTR $T32778[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAPBVPathArgument@Json@@@std@@YAPAPBVPathArgument@Json@@AAPAPBV12@@Z ; std::_Checked_base<Json::PathArgument const * *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAPBVPathArgument@Json@@@std@@YAPAPBVPathArgument@Json@@AAPAPBV12@@Z ; std::_Checked_base<Json::PathArgument const * *>
	add	esp, 4
	push	eax
	call	??$_Uninit_copy@PAPBVPathArgument@Json@@PAPBV12@V?$allocator@PBVPathArgument@Json@@@std@@@std@@YAPAPBVPathArgument@Json@@PAPBV12@00AAV?$allocator@PBVPathArgument@Json@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Json::PathArgument const * *,Json::PathArgument const * *,std::allocator<Json::PathArgument const *> >
	add	esp, 24					; 00000018H

; 675  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@PAPBVPathArgument@Json@@PAPBV12@V?$allocator@PBVPathArgument@Json@@@std@@@stdext@@YAPAPBVPathArgument@Json@@PAPBV12@00AAV?$allocator@PBVPathArgument@Json@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<Json::PathArgument const * *,Json::PathArgument const * *,std::allocator<Json::PathArgument const *> >
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAVPathArgument@Json@@PAV12@V?$allocator@VPathArgument@Json@@@std@@@std@@YAPAVPathArgument@Json@@PAV12@00AAV?$allocator@VPathArgument@Json@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Json::PathArgument *,Json::PathArgument *,std::allocator<Json::PathArgument> >
; Function compile flags: /Odtp
;	COMDAT ??$unchecked_uninitialized_copy@PAVPathArgument@Json@@PAV12@V?$allocator@VPathArgument@Json@@@std@@@stdext@@YAPAVPathArgument@Json@@PAV12@00AAV?$allocator@VPathArgument@Json@@@std@@@Z
_TEXT	SEGMENT
$T32782 = -2						; size = 1
$T32781 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAVPathArgument@Json@@PAV12@V?$allocator@VPathArgument@Json@@@std@@@stdext@@YAPAVPathArgument@Json@@PAV12@00AAV?$allocator@VPathArgument@Json@@@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<Json::PathArgument *,Json::PathArgument *,std::allocator<Json::PathArgument> >, COMDAT

; 672  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 673  : 		return (_STD _Uninit_copy(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest, _Al,
; 674  : 			_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T32781[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAVPathArgument@Json@@PAV12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVPathArgument@Json@@0@Z ; std::_Ptr_cat<Json::PathArgument *,Json::PathArgument *>
	add	esp, 8
	mov	BYTE PTR $T32782[ebp], al
	mov	al, BYTE PTR $T32781[ebp]
	push	eax
	mov	cl, BYTE PTR $T32782[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAVPathArgument@Json@@@std@@YAPAVPathArgument@Json@@AAPAV12@@Z ; std::_Checked_base<Json::PathArgument *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAVPathArgument@Json@@@std@@YAPAVPathArgument@Json@@AAPAV12@@Z ; std::_Checked_base<Json::PathArgument *>
	add	esp, 4
	push	eax
	call	??$_Uninit_copy@PAVPathArgument@Json@@PAV12@V?$allocator@VPathArgument@Json@@@std@@@std@@YAPAVPathArgument@Json@@PAV12@00AAV?$allocator@VPathArgument@Json@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Json::PathArgument *,Json::PathArgument *,std::allocator<Json::PathArgument> >
	add	esp, 24					; 00000018H

; 675  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@PAVPathArgument@Json@@PAV12@V?$allocator@VPathArgument@Json@@@std@@@stdext@@YAPAVPathArgument@Json@@PAV12@00AAV?$allocator@VPathArgument@Json@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<Json::PathArgument *,Json::PathArgument *,std::allocator<Json::PathArgument> >
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 8\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@PAVPathArgument@Json@@PAV12@Uforward_iterator_tag@std@@@std@@YAPAVPathArgument@Json@@PAV12@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_backward_opt@PAVPathArgument@Json@@PAV12@Uforward_iterator_tag@std@@@std@@YAPAVPathArgument@Json@@PAV12@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<Json::PathArgument *,Json::PathArgument *,std::forward_iterator_tag>, COMDAT

; 2344 : 	{	// copy [_First, _Last) backwards to [..., _Dest), arbitrary iterators

	push	ebp
	mov	ebp, esp
$LN2@Copy_backw@2:

; 2345 : 	_DEBUG_RANGE(_First, _Last);
; 2346 : 	while (_First != _Last)

	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN1@Copy_backw@2

; 2347 : 		*--_Dest = *--_Last;

	mov	ecx, DWORD PTR __Last$[ebp]
	sub	ecx, 36					; 00000024H
	mov	DWORD PTR __Last$[ebp], ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	sub	edx, 36					; 00000024H
	mov	DWORD PTR __Dest$[ebp], edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	call	??4PathArgument@Json@@QAEAAV01@ABV01@@Z
	jmp	SHORT $LN2@Copy_backw@2
$LN1@Copy_backw@2:

; 2348 : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]

; 2349 : 	}

	pop	ebp
	ret	0
??$_Copy_backward_opt@PAVPathArgument@Json@@PAV12@Uforward_iterator_tag@std@@@std@@YAPAVPathArgument@Json@@PAV12@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<Json::PathArgument *,Json::PathArgument *,std::forward_iterator_tag>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 8\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Checked_iterator_base@?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Checked_iterator_base@?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::_Vector_const_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Checked_iterator_base, COMDAT
; _this$ = ecx

; 47   : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 48   : 		return _Myptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 49   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Checked_iterator_base@?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::_Vector_const_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Checked_iterator_base
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Checked_iterator_base@?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Checked_iterator_base@?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::_Vector_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Checked_iterator_base, COMDAT
; _this$ = ecx

; 291  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 292  : 		return this->_Myptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 293  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Checked_iterator_base@?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::_Vector_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Checked_iterator_base
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 8\vc\include\utility
_TEXT	ENDS
;	COMDAT ??0?$pair@Vconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@V123@@std@@QAE@ABVconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@1@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??0?$pair@Vconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@V123@@std@@QAE@ABVconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@1@0@Z PROC ; std::pair<std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator,std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator>::pair<std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator,std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator>, COMDAT
; _this$ = ecx

; 37   : 		{	// construct from specified values

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Val1$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR __Val2$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], edx
	mov	DWORD PTR [ecx+12], eax

; 38   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$pair@Vconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@V123@@std@@QAE@ABVconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@1@0@Z ENDP ; std::pair<std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator,std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator>::pair<std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator,std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$?8$$CBVCZString@Value@Json@@V12@@std@@YA_NABU?$pair@$$CBVCZString@Value@Json@@V23@@0@0@Z
_TEXT	SEGMENT
tv76 = -4						; size = 4
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$?8$$CBVCZString@Value@Json@@V12@@std@@YA_NABU?$pair@$$CBVCZString@Value@Json@@V23@@0@0@Z PROC ; std::operator==<Json::Value::CZString const ,Json::Value>, COMDAT

; 62   : 	{	// test for pair equality

	push	ebp
	mov	ebp, esp
	push	ecx

; 63   : 	return (_Left.first == _Right.first && _Left.second == _Right.second);

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Left$[ebp]
	call	??8CZString@Value@Json@@QBE_NABV012@@Z	; Json::Value::CZString::operator==
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN3@operator@23
	mov	edx, DWORD PTR __Right$[ebp]
	add	edx, 8
	push	edx
	mov	ecx, DWORD PTR __Left$[ebp]
	add	ecx, 8
	call	??8Value@Json@@QBE_NABV01@@Z		; Json::Value::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@operator@23
	mov	DWORD PTR tv76[ebp], 1
	jmp	SHORT $LN4@operator@23
$LN3@operator@23:
	mov	DWORD PTR tv76[ebp], 0
$LN4@operator@23:
	mov	al, BYTE PTR tv76[ebp]

; 64   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$?8$$CBVCZString@Value@Json@@V12@@std@@YA_NABU?$pair@$$CBVCZString@Value@Json@@V23@@0@0@Z ENDP ; std::operator==<Json::Value::CZString const ,Json::Value>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 8\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Fill_n@PAPBVPathArgument@Json@@IPBV12@@std@@YAXPAPBVPathArgument@Json@@IABQBV12@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Fill_n@PAPBVPathArgument@Json@@IPBV12@@std@@YAXPAPBVPathArgument@Json@@IABQBV12@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Fill_n<Json::PathArgument const * *,unsigned int,Json::PathArgument const *>, COMDAT

; 2763 : 	{	// copy _Val _Count times through [_First, ...)

	push	ebp
	mov	ebp, esp

; 2764 : 	for (; 0 < _Count; --_Count, ++_First)

	jmp	SHORT $LN3@Fill_n
$LN2@Fill_n:
	mov	eax, DWORD PTR __Count$[ebp]
	sub	eax, 1
	mov	DWORD PTR __Count$[ebp], eax
	mov	ecx, DWORD PTR __First$[ebp]
	add	ecx, 4
	mov	DWORD PTR __First$[ebp], ecx
$LN3@Fill_n:
	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN4@Fill_n

; 2765 : 		*_First = _Val;

	mov	edx, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	jmp	SHORT $LN2@Fill_n
$LN4@Fill_n:

; 2766 : 	}

	pop	ebp
	ret	0
??$_Fill_n@PAPBVPathArgument@Json@@IPBV12@@std@@YAXPAPBVPathArgument@Json@@IABQBV12@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Fill_n<Json::PathArgument const * *,unsigned int,Json::PathArgument const *>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 8\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PAPBVPathArgument@Json@@PAPBV12@V?$allocator@PBVPathArgument@Json@@@std@@@std@@YAPAPBVPathArgument@Json@@PAPBV12@00AAV?$allocator@PBVPathArgument@Json@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Result$ = -8						; size = 4
__Count$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAPBVPathArgument@Json@@PAPBV12@V?$allocator@PBVPathArgument@Json@@@std@@@std@@YAPAPBVPathArgument@Json@@PAPBV12@00AAV?$allocator@PBVPathArgument@Json@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<Json::PathArgument const * *,Json::PathArgument const * *,std::allocator<Json::PathArgument const *> >, COMDAT

; 123  : 	{	// copy [_First, _Last) to raw _Dest, scalar type

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 124  : 	_DEBUG_RANGE(_First, _Last);
; 125  : 	_DEBUG_POINTER(_Dest);
; 126  : 	size_t _Count = (size_t)(_Last - _First);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 2
	mov	DWORD PTR __Count$[ebp], eax

; 127  : 	_FwdIt _Result = _Dest + _Count;

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Dest$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR __Result$[ebp], eax

; 128  : 	if (_Count > 0)

	je	SHORT $LN1@Uninit_cop@2

; 129  : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Count * sizeof (*_First), &*_First, _Count * sizeof (*_First));	// NB: non-overlapping move

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN1@Uninit_cop@2:

; 130  : 	return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 131  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninit_copy@PAPBVPathArgument@Json@@PAPBV12@V?$allocator@PBVPathArgument@Json@@@std@@@std@@YAPAPBVPathArgument@Json@@PAPBV12@00AAV?$allocator@PBVPathArgument@Json@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<Json::PathArgument const * *,Json::PathArgument const * *,std::allocator<Json::PathArgument const *> >
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Uninit_copy@PAVPathArgument@Json@@PAV12@V?$allocator@VPathArgument@Json@@@std@@@std@@YAPAVPathArgument@Json@@PAV12@00AAV?$allocator@VPathArgument@Json@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_copy@PAVPathArgument@Json@@PAV12@V?$allocator@VPathArgument@Json@@@std@@@std@@YAPAVPathArgument@Json@@PAV12@00AAV?$allocator@VPathArgument@Json@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_copy@PAVPathArgument@Json@@PAV12@V?$allocator@VPathArgument@Json@@@std@@@std@@YAPAVPathArgument@Json@@PAV12@00AAV?$allocator@VPathArgument@Json@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_copy@PAVPathArgument@Json@@PAV12@V?$allocator@VPathArgument@Json@@@std@@@std@@YAPAVPathArgument@Json@@PAV12@00AAV?$allocator@VPathArgument@Json@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_copy@PAVPathArgument@Json@@PAV12@V?$allocator@VPathArgument@Json@@@std@@@std@@YAPAVPathArgument@Json@@PAV12@00AAV?$allocator@VPathArgument@Json@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_copy@PAVPathArgument@Json@@PAV12@V?$allocator@VPathArgument@Json@@@std@@@std@@YAPAVPathArgument@Json@@PAV12@00AAV?$allocator@VPathArgument@Json@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_copy@PAVPathArgument@Json@@PAV12@V?$allocator@VPathArgument@Json@@@std@@@std@@YAPAVPathArgument@Json@@PAV12@00AAV?$allocator@VPathArgument@Json@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_copy@PAVPathArgument@Json@@PAV12@V?$allocator@VPathArgument@Json@@@std@@@std@@YAPAVPathArgument@Json@@PAV12@00AAV?$allocator@VPathArgument@Json@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??$_Uninit_copy@PAVPathArgument@Json@@PAV12@V?$allocator@VPathArgument@Json@@@std@@@std@@YAPAVPathArgument@Json@@PAV12@00AAV?$allocator@VPathArgument@Json@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAVPathArgument@Json@@PAV12@V?$allocator@VPathArgument@Json@@@std@@@std@@YAPAVPathArgument@Json@@PAV12@00AAV?$allocator@VPathArgument@Json@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<Json::PathArgument *,Json::PathArgument *,std::allocator<Json::PathArgument> >, COMDAT

; 102  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_copy@PAVPathArgument@Json@@PAV12@V?$allocator@VPathArgument@Json@@@std@@@std@@YAPAVPathArgument@Json@@PAV12@00AAV?$allocator@VPathArgument@Json@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 103  : 	_DEBUG_RANGE(_First, _Last);
; 104  : 	_DEBUG_POINTER(_Dest);
; 105  : 	_FwdIt _Next = _Dest;

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 106  : 
; 107  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0
	jmp	SHORT $LN6@Uninit_cop@3
$LN5@Uninit_cop@3:

; 108  : 	for (; _First != _Last; ++_Dest, ++_First)

	mov	ecx, DWORD PTR __Dest$[ebp]
	add	ecx, 36					; 00000024H
	mov	DWORD PTR __Dest$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 36					; 00000024H
	mov	DWORD PTR __First$[ebp], edx
$LN6@Uninit_cop@3:
	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Uninit_cop@3

; 109  : 		_Al.construct(_Dest, *_First);

	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?construct@?$allocator@VPathArgument@Json@@@std@@QAEXPAVPathArgument@Json@@ABV34@@Z ; std::allocator<Json::PathArgument>::construct
	jmp	SHORT $LN5@Uninit_cop@3
$LN4@Uninit_cop@3:

; 110  : 	_CATCH_ALL

	jmp	SHORT $LN10@Uninit_cop@3
__catch$??$_Uninit_copy@PAVPathArgument@Json@@PAV12@V?$allocator@VPathArgument@Json@@@std@@@std@@YAPAVPathArgument@Json@@PAV12@00AAV?$allocator@VPathArgument@Json@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:
	jmp	SHORT $LN3@Uninit_cop@3
$LN2@Uninit_cop@3:

; 111  : 	for (; _Next != _Dest; ++_Next)

	mov	eax, DWORD PTR __Next$[ebp]
	add	eax, 36					; 00000024H
	mov	DWORD PTR __Next$[ebp], eax
$LN3@Uninit_cop@3:
	mov	ecx, DWORD PTR __Next$[ebp]
	cmp	ecx, DWORD PTR __Dest$[ebp]
	je	SHORT $LN1@Uninit_cop@3

; 112  : 		_Al.destroy(_Next);

	mov	edx, DWORD PTR __Next$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?destroy@?$allocator@VPathArgument@Json@@@std@@QAEXPAVPathArgument@Json@@@Z ; std::allocator<Json::PathArgument>::destroy
	jmp	SHORT $LN2@Uninit_cop@3
$LN1@Uninit_cop@3:

; 113  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
	mov	eax, __tryend$??$_Uninit_copy@PAVPathArgument@Json@@PAV12@V?$allocator@VPathArgument@Json@@@std@@@std@@YAPAVPathArgument@Json@@PAV12@00AAV?$allocator@VPathArgument@Json@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1
	ret	0
$LN10@Uninit_cop@3:

; 114  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Uninit_copy@PAVPathArgument@Json@@PAV12@V?$allocator@VPathArgument@Json@@@std@@@std@@YAPAVPathArgument@Json@@PAV12@00AAV?$allocator@VPathArgument@Json@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1:

; 115  : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]
$LN9@Uninit_cop@3:

; 116  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_copy@PAVPathArgument@Json@@PAV12@V?$allocator@VPathArgument@Json@@@std@@@std@@YAPAVPathArgument@Json@@PAV12@00AAV?$allocator@VPathArgument@Json@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_copy@PAVPathArgument@Json@@PAV12@V?$allocator@VPathArgument@Json@@@std@@@std@@YAPAVPathArgument@Json@@PAV12@00AAV?$allocator@VPathArgument@Json@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_copy@PAVPathArgument@Json@@PAV12@V?$allocator@VPathArgument@Json@@@std@@@std@@YAPAVPathArgument@Json@@PAV12@00AAV?$allocator@VPathArgument@Json@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<Json::PathArgument *,Json::PathArgument *,std::allocator<Json::PathArgument> >
; Function compile flags: /Odtp
; File d:\git_zqprojs\zqproj\generic\cdmifuse\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp
;	COMDAT ??__E?null@Value@Json@@2V12@B@@YAXXZ
text$yc	SEGMENT
??__E?null@Value@Json@@2V12@B@@YAXXZ PROC		; `dynamic initializer for 'Json::Value::null'', COMDAT

; 22   : const Value Value::null;

	push	ebp
	mov	ebp, esp
	push	0
	mov	ecx, OFFSET ?null@Value@Json@@2V12@B	; Json::Value::null
	call	??0Value@Json@@QAE@W4ValueType@1@@Z	; Json::Value::Value
	push	OFFSET ??__F?null@Value@Json@@2V12@B@@YAXXZ ; `dynamic atexit destructor for 'Json::Value::null''
	call	_atexit
	add	esp, 4
	pop	ebp
	ret	0
??__E?null@Value@Json@@2V12@B@@YAXXZ ENDP		; `dynamic initializer for 'Json::Value::null''
text$yc	ENDS
PUBLIC	??0DummyValueAllocatorInitializer@Json@@QAE@XZ	; Json::DummyValueAllocatorInitializer::DummyValueAllocatorInitializer
; Function compile flags: /Odtp
;	COMDAT ??__EdummyValueAllocatorInitializer@Json@@YAXXZ
text$yc	SEGMENT
??__EdummyValueAllocatorInitializer@Json@@YAXXZ PROC	; Json::`dynamic initializer for 'dummyValueAllocatorInitializer'', COMDAT

; 114  : } dummyValueAllocatorInitializer;

	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET _dummyValueAllocatorInitializer
	call	??0DummyValueAllocatorInitializer@Json@@QAE@XZ ; Json::DummyValueAllocatorInitializer::DummyValueAllocatorInitializer
	pop	ebp
	ret	0
??__EdummyValueAllocatorInitializer@Json@@YAXXZ ENDP	; Json::`dynamic initializer for 'dummyValueAllocatorInitializer''
; Function compile flags: /Odtp
text$yc	ENDS
;	COMDAT ??0DummyValueAllocatorInitializer@Json@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0DummyValueAllocatorInitializer@Json@@QAE@XZ PROC	; Json::DummyValueAllocatorInitializer::DummyValueAllocatorInitializer, COMDAT
; _this$ = ecx

; 110  :    DummyValueAllocatorInitializer() 

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 111  :    {
; 112  :       valueAllocator();      // ensure valueAllocator() statics are initialized before main().

	call	?valueAllocator@Json@@YAAAPAVValueAllocator@1@XZ ; Json::valueAllocator

; 113  :    }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0DummyValueAllocatorInitializer@Json@@QAE@XZ ENDP	; Json::DummyValueAllocatorInitializer::DummyValueAllocatorInitializer
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??__F?null@Value@Json@@2V12@B@@YAXXZ
text$yd	SEGMENT
??__F?null@Value@Json@@2V12@B@@YAXXZ PROC		; `dynamic atexit destructor for 'Json::Value::null'', COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?null@Value@Json@@2V12@B	; Json::Value::null
	call	??1Value@Json@@QAE@XZ			; Json::Value::~Value
	pop	ebp
	ret	0
??__F?null@Value@Json@@2V12@B@@YAXXZ ENDP		; `dynamic atexit destructor for 'Json::Value::null''
; Function compile flags: /Odtp
text$yd	ENDS
;	COMDAT ??__FdefaultAllocator@?1??valueAllocator@Json@@YAAAPAVValueAllocator@1@XZ@YAXXZ
text$yd	SEGMENT
??__FdefaultAllocator@?1??valueAllocator@Json@@YAAAPAVValueAllocator@1@XZ@YAXXZ PROC ; `Json::valueAllocator'::`2'::`dynamic atexit destructor for 'defaultAllocator'', COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?defaultAllocator@?1??valueAllocator@Json@@YAAAPAVValueAllocator@2@XZ@4VDefaultValueAllocator@2@A
	call	??1DefaultValueAllocator@Json@@UAE@XZ	; Json::DefaultValueAllocator::~DefaultValueAllocator
	pop	ebp
	ret	0
??__FdefaultAllocator@?1??valueAllocator@Json@@YAAAPAVValueAllocator@1@XZ@YAXXZ ENDP ; `Json::valueAllocator'::`2'::`dynamic atexit destructor for 'defaultAllocator''
text$yd	ENDS
PUBLIC	?null@Value@Json@@2V12@B			; Json::Value::null
_BSS	SEGMENT
?null@Value@Json@@2V12@B DB 010H DUP (?)		; Json::Value::null
_dummyValueAllocatorInitializer DB 01H DUP (?)
_BSS	ENDS
CRT$XCU	SEGMENT
?null$initializer$@Value@Json@@2P6AXXZA DD FLAT:??__E?null@Value@Json@@2V12@B@@YAXXZ ; Json::Value::null$initializer$
_dummyValueAllocatorInitializer$initializer$ DD FLAT:??__EdummyValueAllocatorInitializer@Json@@YAXXZ
CRT$XCU	ENDS
END
